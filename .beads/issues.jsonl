{"id":"test-e1","title":"Project Foundation \u0026 Core Setup","description":"Initialize Next.js 16 project with Convex backend, Clerk authentication, and basic dashboard shell. Establish project structure, install core dependencies, and configure development environment.\n\n**Context:** Before any feature can be built, the project infrastructure must exist. This includes the frontend framework, real-time database, authentication system, and basic UI components following RealHerd brand guidelines.\n\n**Testing Requirements:**\n- **Unit Tests:** Convex schema validation, utility functions, theme configuration\n- **Integration Tests:** Clerk auth flow with Convex user creation, protected route access\n- **Type Tests:** TypeScript strict mode enabled, Convex schema types generated\n- **E2E Tests:** User can sign up, see dashboard, sign out","acceptance_criteria":"- Can run npm dev and see branded login page with Clerk\n- Convex backend is connected and basic schema is deployed\n- Clerk authentication works (sign up, sign in, sign out)\n- Dashboard shell renders with RealHerd branding (Warm Cream background, Terracotta accents)\n- Tailwind v4 + shadcn/ui configured with custom theme\n- Basic navigation structure in place","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1440,"created_at":"2026-01-30T12:47:16.71566-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:16.71566-06:00","labels":["auth","foundation","infrastructure"]}
{"id":"test-e10","title":"Brokerage Dashboard \u0026 Visibility","description":"Build the broker and team lead dashboard views providing activity feeds, pipeline overview, agent summaries, stale lead alerts, and compliance reporting.\n\n**Context:** Brokers pay for RealHerd to get visibility they've never had. The dashboard is where they see ROI - which agents are using it, what's in the pipeline, which deals need attention. This is the 'killer feature' for decision makers.\n\n**Testing Requirements:**\n- **Unit Tests:** Activity feed filtering logic, compliance calculation, pipeline aggregation\n- **Integration Tests:** Real-time updates via Convex subscriptions, cross-agent data aggregation\n- **Type Tests:** Dashboard data shapes, filter parameter validation\n- **E2E Tests:** Broker views activity across all agents, filters work, exports download correctly","acceptance_criteria":"- Activity feed shows all calls across org/team with filtering\n- Pipeline overview displays leads by stage and temperature\n- Agent activity summary shows call counts, compliance rates\n- Stale lead alerts highlight leads needing attention\n- Check-in compliance report shows who's taking calls\n- Filtering by agent, date range, lead temperature\n- Export capabilities for reports\n- Mobile-responsive design for on-the-go checking","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:47:21.316174-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:21.316174-06:00","labels":["dashboard","reporting","visibility"],"dependencies":[{"issue_id":"test-e10","depends_on_id":"test-e9","type":"blocks","created_at":"2026-01-30T12:52:24.067258-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t1","title":"Build activity feed component with real-time updates","description":"Create the core activity feed component that displays all call activity across the organization. Must support real-time updates via Convex subscriptions as new calls come in, showing call summaries, agent names, lead info, timestamps, and outcomes.\n\n**Context:** Brokers pay for RealHerd to get visibility they've never had. The activity feed is the heart of the dashboard - it's the first thing brokers see and proves the system is working. Real-time updates make it feel alive and valuable.\n\n**Testing Requirements:**\n- **Unit Tests:** ActivityFeedItem rendering, filter logic functions, date formatting, outcome badge mapping, pagination/infinite scroll logic\n- **Integration Tests:** Real-time subscription updates when new calls added, filter combinations (agent + date + temperature), data loading states","design":"Use Convex useQuery with live subscriptions for real-time updates. Create ActivityFeedItem component with call metadata, agent avatar, lead name, call duration, and outcome badge. Implement virtualized list for performance with many items. Filter state managed via URL params for shareability.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:57.447772-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:57.447772-06:00","labels":["dashboard","frontend","real-time"],"dependencies":[{"issue_id":"test-e10t1","depends_on_id":"test-e10","type":"parent-child","created_at":"2026-01-30T12:47:57.597723-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t1s1","title":"Create ActivityFeedItem component with call metadata display","description":"Build the ActivityFeedItem component that displays a single call activity entry. Include agent avatar (using initials or placeholder), lead name, call duration formatted as mm:ss, timestamp with relative time (e.g., '5 min ago'), and outcome badge with color coding (connected=green, voicemail=yellow, no-answer=red). Use shadcn/ui Card component as base. Create TypeScript types for ActivityItem matching Convex schema fields.\n\n**Context:** Each feed item needs to convey call status at a glance - brokers scanning the feed should immediately see who called whom and what happened without clicking. This is the atomic unit of the activity feed.\n\n**Testing Requirements:**\n- **Unit Tests:** Test ActivityFeedItem renders all props correctly, test duration formatting (0s, 59s, 1:00, 59:59), test relative timestamp display, test outcome badge color mapping for each outcome type, test missing/null field handling","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:39.82757-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:39.82757-06:00","labels":["component","frontend"],"dependencies":[{"issue_id":"test-e10t1s1","depends_on_id":"test-e10t1","type":"parent-child","created_at":"2026-01-30T12:50:40.034729-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t1s2","title":"Implement Convex useQuery subscription for real-time call activity","description":"Create useActivityFeed hook that uses Convex useQuery with live subscription to calls table. Query should return recent calls (last 24h default) ordered by timestamp desc, joining agent and lead data. Include pagination cursor for loading older items. Handle loading and error states. The hook should accept filter params (agentId, outcome, dateRange) that map to URL search params.\n\n**Context:** Real-time updates are what make the dashboard feel alive - when an agent finishes a call, brokers see it appear instantly. This proves the system is working and creates urgency around pipeline management.\n\n**Testing Requirements:**\n- **Unit Tests:** Test hook returns loading state initially, test data transformation from Convex response, test filter params are passed to query correctly, test subscription updates when new calls arrive (mock Convex subscription behavior)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:40.242264-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:40.242264-06:00","labels":["convex","data","frontend"],"dependencies":[{"issue_id":"test-e10t1s2","depends_on_id":"test-e10t1","type":"parent-child","created_at":"2026-01-30T12:50:40.414508-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t1s2","depends_on_id":"test-e10t1s1","type":"blocks","created_at":"2026-01-30T12:52:24.35091-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t1s3","title":"Build virtualized ActivityFeed list with infinite scroll","description":"Create ActivityFeed container component using @tanstack/react-virtual for virtualized rendering. Implement infinite scroll that loads more items when user scrolls near bottom using the pagination cursor from useActivityFeed. Show skeleton loaders during initial load and 'Loading more...' indicator when fetching next page. Handle empty state with helpful message. Estimated row height ~80px for virtualization.\n\n**Context:** Brokerages can have hundreds of calls per day across 20-100 agents. Without virtualization, rendering all items kills performance. Infinite scroll keeps initial load fast while allowing full history access.\n\n**Testing Requirements:**\n- **Unit Tests:** Test virtualized list only renders visible items (check DOM node count), test infinite scroll triggers loadMore at threshold, test skeleton loading state, test empty state message, test scroll position preservation on data update","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:40.737322-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:40.737322-06:00","labels":["component","frontend","performance"],"dependencies":[{"issue_id":"test-e10t1s3","depends_on_id":"test-e10t1","type":"parent-child","created_at":"2026-01-30T12:50:40.898315-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t1s3","depends_on_id":"test-e10t1s1","type":"blocks","created_at":"2026-01-30T12:52:24.634189-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t1s3","depends_on_id":"test-e10t1s2","type":"blocks","created_at":"2026-01-30T12:52:25.035117-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t1s4","title":"Add URL-synced filters and verify real-time behavior end-to-end","description":"Implement filter controls (agent dropdown, outcome multi-select, date range picker) that sync to URL search params using nuqs or useSearchParams. Filters should update the useActivityFeed query params reactively. Add filter reset button. Verify complete flow: start dev server, confirm real-time subscription works (can simulate by adding test data to Convex), confirm filters update feed immediately, confirm URL is shareable.\n\n**Context:** URL-synced filters let brokers share specific views with team leads ('here's all voicemails from yesterday'). This is a power-user feature that increases stickiness and proves sophistication.\n\n**Testing Requirements:**\n- **Unit Tests:** Test filter state syncs to URL params, test URL params restore filter state on page load, test filter changes trigger query update, test reset clears all filters and URL params, test multiple filters combine correctly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:41.132298-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:41.132298-06:00","labels":["frontend","integration","ux"],"dependencies":[{"issue_id":"test-e10t1s4","depends_on_id":"test-e10t1","type":"parent-child","created_at":"2026-01-30T12:50:41.4283-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t1s4","depends_on_id":"test-e10t1s3","type":"blocks","created_at":"2026-01-30T12:52:25.397681-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t2","title":"Create pipeline overview with stage visualization","description":"Build pipeline overview component showing leads organized by stage (New, Contacted, Qualified, Proposal, Closing) with temperature indicators (hot/warm/cold). Include counts per stage and visual representation of pipeline health.\n\n**Context:** The pipeline overview gives brokers the 30,000ft view they've always wanted - how many deals are in flight, where they are, which are hot. This is the ROI visualization that justifies the software purchase.\n\n**Testing Requirements:**\n- **Unit Tests:** Stage count calculations, temperature color mapping, lead card rendering, stage transition display\n- **Integration Tests:** Pipeline data accuracy against actual lead counts, click-through to filtered views, real-time count updates","design":"Use Convex aggregation queries to count leads by stage/temperature. Create Kanban-style columns or funnel visualization using shadcn/ui cards. Color-code temperature (red/orange/blue). Make stages clickable to filter the activity feed. Consider both card view and table view options.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:57.820364-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:57.820364-06:00","labels":["dashboard","frontend","visualization"],"dependencies":[{"issue_id":"test-e10t2","depends_on_id":"test-e10","type":"parent-child","created_at":"2026-01-30T12:47:57.982807-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t2","depends_on_id":"test-e10t1","type":"blocks","created_at":"2026-01-30T12:52:25.953503-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t2s1","title":"Create Convex aggregation queries for pipeline statistics","description":"Build Convex query functions to aggregate leads by stage and temperature. Create queries: getPipelineStats() returning counts per stage (New, Contacted, Qualified, Proposal, Closing), getTemperatureCounts() returning hot/warm/cold counts per stage, and getPipelineHealth() combining both for dashboard consumption. Use Convex's built-in aggregation patterns with proper indexing for performance.\n\n**Context:** The pipeline overview needs real-time data aggregation. These queries power both the visual display and the counts, so they need to be efficient and accurate. Brokers will trust these numbers for business decisions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getPipelineStats() returns correct counts with mock leads across all stages, test getTemperatureCounts() correctly groups by temperature within each stage, test empty state returns zeros not nulls, test queries handle 1000+ leads performantly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:41.64287-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:41.64287-06:00","labels":["backend","convex"],"dependencies":[{"issue_id":"test-e10t2s1","depends_on_id":"test-e10t2","type":"parent-child","created_at":"2026-01-30T12:50:41.813554-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t2s2","title":"Build PipelineStageColumn component with temperature indicators","description":"Create a reusable PipelineStageColumn component using shadcn/ui Card as the base. Display stage name, lead count badge, and a mini temperature breakdown (colored dots or bar showing hot/warm/cold distribution). Props: stageName, leadCount, temperatureCounts, onClick. Style temperature indicators: red for hot, orange for warm, blue for cold. Make the entire column clickable to trigger filtering.\n\n**Context:** Each column represents a stage in the sales pipeline. The temperature visualization within each column is crucial - brokers need to see at a glance which stages have hot leads that need immediate attention versus cold leads that might be stalling.\n\n**Testing Requirements:**\n- **Unit Tests:** Test renders stage name and count correctly, test temperature indicators show correct colors, test onClick fires with stage identifier, test handles zero counts gracefully, test accessibility labels present","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:42.096795-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:42.096795-06:00","labels":["components","frontend"],"dependencies":[{"issue_id":"test-e10t2s2","depends_on_id":"test-e10t2","type":"parent-child","created_at":"2026-01-30T12:50:42.288277-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t2s2","depends_on_id":"test-e10t2s1","type":"blocks","created_at":"2026-01-30T12:52:26.246158-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t2s3","title":"Assemble PipelineOverview container with Kanban layout","description":"Create PipelineOverview component that fetches data using the Convex queries and renders 5 PipelineStageColumn components in a horizontal Kanban-style layout. Use CSS Grid or Flexbox for responsive columns. Add a header showing total pipeline count and overall health indicator. Wire up column clicks to emit onStageFilter events that parent components can use to filter the activity feed. Include loading skeleton state.\n\n**Context:** This is the main dashboard widget brokers see first. The Kanban layout is intuitive for sales pipeline visualization and matches mental models from tools like Trello or Pipedrive. The stage filter connection is key for drilling down from overview to specifics.\n\n**Testing Requirements:**\n- **Unit Tests:** Test renders all 5 stage columns with correct data, test loading state shows skeletons, test onStageFilter callback fires with correct stage, test responsive layout adjusts for mobile, test error state displays user-friendly message","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:42.511165-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:42.511165-06:00","labels":["components","frontend"],"dependencies":[{"issue_id":"test-e10t2s3","depends_on_id":"test-e10t2","type":"parent-child","created_at":"2026-01-30T12:50:42.704422-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t2s3","depends_on_id":"test-e10t2s1","type":"blocks","created_at":"2026-01-30T12:52:26.510832-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t2s3","depends_on_id":"test-e10t2s2","type":"blocks","created_at":"2026-01-30T12:52:26.816963-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t2s4","title":"Integrate pipeline overview into dashboard and verify end-to-end","description":"Add PipelineOverview to the main dashboard page layout. Connect the onStageFilter event to update the activity feed filter state. Add sample/seed data with leads in various stages and temperatures. Start dev server and manually verify: columns display correct counts, temperature colors render, clicking a stage filters the activity feed, loading states work, responsive on mobile viewport.\n\n**Context:** Integration testing ensures the ROI visualization actually works for brokers. This is where we prove the 30,000ft view they've always wanted is real and responsive. Any disconnect between overview and activity feed would break trust.\n\n**Testing Requirements:**\n- **Unit Tests:** Test dashboard renders PipelineOverview without errors, test stage filter state propagates to activity feed component, test seed data produces expected visual output","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:42.915636-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:42.915636-06:00","labels":["frontend","integration"],"dependencies":[{"issue_id":"test-e10t2s4","depends_on_id":"test-e10t2","type":"parent-child","created_at":"2026-01-30T12:50:43.088597-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t2s4","depends_on_id":"test-e10t2s3","type":"blocks","created_at":"2026-01-30T12:52:27.18127-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t3","title":"Implement agent activity summary and compliance reporting","description":"Build agent performance cards showing call counts, compliance rates, average call duration, and leads contacted per agent. Include check-in compliance report showing which agents are taking calls vs. ignoring them.\n\n**Context:** Brokers need to know WHO is using RealHerd and who isn't. The agent summary answers 'is my team actually using this?' and the compliance report shows who needs a talking-to. This drives CRM adoption - the core problem we're solving.\n\n**Testing Requirements:**\n- **Unit Tests:** Compliance rate calculation, stats aggregation functions, threshold badge logic, date range filtering\n- **Integration Tests:** Agent metrics accuracy, compliance report data correctness, filtering by date range","design":"Create AgentSummaryCard with avatar, stats grid, and compliance indicator. Build aggregation queries in Convex for per-agent metrics. Compliance calculated as (calls taken / check-ins received). Use color-coded badges for compliance thresholds (green \u003e80%, yellow 50-80%, red \u003c50%).","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:58.192376-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:58.192376-06:00","labels":["compliance","dashboard","frontend"],"dependencies":[{"issue_id":"test-e10t3","depends_on_id":"test-e10","type":"parent-child","created_at":"2026-01-30T12:47:58.353031-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t3","depends_on_id":"test-e10t1","type":"blocks","created_at":"2026-01-30T12:52:27.544593-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t3s1","title":"Create TypeScript types and Convex schema for agent metrics","description":"Define TypeScript interfaces for AgentMetrics (callCount, complianceRate, avgCallDuration, leadsContacted, checkInsReceived, callsTaken). Add any needed indexes to Convex schema for efficient per-agent aggregation queries. Include ComplianceThreshold enum (green \u003e80%, yellow 50-80%, red \u003c50%).\n\n**Context:** Type-safe foundation ensures the metrics we display match what we calculate. These types will be shared between Convex queries and React components.\n\n**Testing Requirements:**\n- **Unit Tests:** Test ComplianceThreshold calculation function with edge cases: 0/0 check-ins, 100% compliance, boundary values (exactly 50%, exactly 80%), and typical values. Verify TypeScript compilation succeeds.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:43.323753-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:43.323753-06:00","labels":["backend","types"],"dependencies":[{"issue_id":"test-e10t3s1","depends_on_id":"test-e10t3","type":"parent-child","created_at":"2026-01-30T12:50:43.499328-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t3s2","title":"Build Convex aggregation queries for per-agent metrics","description":"Create Convex query functions: getAgentMetrics(agentId, dateRange) returning call counts, avg duration, leads contacted; getAgentCompliance(agentId, dateRange) calculating calls taken / check-ins received; getTeamAgentsSummary(brokerId) returning all agents' metrics for dashboard. Use efficient aggregation patterns, consider pagination for large teams.\n\n**Context:** These queries power the entire agent dashboard. Performance matters because brokers will view this frequently. The compliance calculation (calls taken / check-ins received) is the key metric showing who's actually using RealHerd.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getAgentMetrics with mock data: agent with 0 calls, agent with typical activity, date range filtering. Test getAgentCompliance edge cases: 0 check-ins (avoid division by zero), 100% compliance, partial compliance. Test getTeamAgentsSummary returns correct agent count and aggregated data.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:43.801599-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:43.801599-06:00","labels":["backend","convex"],"dependencies":[{"issue_id":"test-e10t3s2","depends_on_id":"test-e10t3","type":"parent-child","created_at":"2026-01-30T12:50:43.963222-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t3s2","depends_on_id":"test-e10t3s1","type":"blocks","created_at":"2026-01-30T12:52:27.81512-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t3s3","title":"Create AgentSummaryCard component with stats and compliance indicator","description":"Build React component AgentSummaryCard displaying: agent avatar/name, stats grid (call count, avg duration, leads contacted), compliance rate with color-coded badge (green/yellow/red per thresholds). Use existing design system components. Component should accept AgentMetrics props and handle loading/error states.\n\n**Context:** This card is the visual answer to 'is this agent using RealHerd?' Brokers will scan these cards daily to spot underperformers. The color-coded compliance badge provides instant visual feedback without reading numbers.\n\n**Testing Requirements:**\n- **Unit Tests:** Test AgentSummaryCard renders correctly with: full metrics data, zero values, loading state, error state. Test compliance badge shows correct color at boundaries (79% = yellow, 80% = green, 49% = red, 50% = yellow). Snapshot test for visual regression.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:44.304886-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:44.304886-06:00","labels":["frontend","react"],"dependencies":[{"issue_id":"test-e10t3s3","depends_on_id":"test-e10t3","type":"parent-child","created_at":"2026-01-30T12:50:44.607988-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t3s3","depends_on_id":"test-e10t3s1","type":"blocks","created_at":"2026-01-30T12:52:28.073287-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t3s4","title":"Wire up agent summary dashboard and verify end-to-end","description":"Create AgentComplianceReport page/section that uses getTeamAgentsSummary query and renders grid of AgentSummaryCard components. Add sorting (by compliance rate, call count) and filtering (by compliance threshold). Connect to broker dashboard navigation. Run dev server and verify with test data.\n\n**Context:** This brings everything together into the actual feature brokers will use. The sorting and filtering let brokers quickly find agents who need attention - the whole point of this visibility feature.\n\n**Testing Requirements:**\n- **Unit Tests:** Test AgentComplianceReport renders correct number of cards, test sorting logic (compliance ascending/descending, call count), test filtering by threshold. Integration test: verify Convex query is called with correct broker ID, cards render with query data. Manual verification: start dev server, navigate to report, confirm cards display with test data.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:44.901515-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:44.901515-06:00","labels":["frontend","integration"],"dependencies":[{"issue_id":"test-e10t3s4","depends_on_id":"test-e10t3","type":"parent-child","created_at":"2026-01-30T12:50:45.0826-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t3s4","depends_on_id":"test-e10t3s2","type":"blocks","created_at":"2026-01-30T12:52:28.385118-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t3s4","depends_on_id":"test-e10t3s3","type":"blocks","created_at":"2026-01-30T12:52:28.783457-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t4","title":"Build stale lead alerts and attention-needed queue","description":"Create alert system highlighting leads that need attention - no contact in X days, hot leads going cold, scheduled follow-ups missed. Display as prioritized queue with one-click actions to assign or contact.\n\n**Context:** Stale leads are lost deals. Brokers lose money when hot leads go cold because no one followed up. This alert system turns passive visibility into active deal-saving, directly impacting brokerage revenue.\n\n**Testing Requirements:**\n- **Unit Tests:** Staleness calculation logic, urgency scoring algorithm, alert filtering, snooze functionality\n- **Integration Tests:** Alert accuracy against actual lead data, action buttons trigger correct operations, real-time alert updates","design":"Define staleness rules: no contact in 7 days for hot, 14 for warm, 30 for cold. Query Convex for leads matching staleness criteria. Create AlertCard with lead info, days stale, last contact, and action buttons. Sort by urgency (temperature × days stale). Include 'snooze' and 'assign to agent' quick actions.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:58.630516-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:58.630516-06:00","labels":["alerts","dashboard","frontend"],"dependencies":[{"issue_id":"test-e10t4","depends_on_id":"test-e10","type":"parent-child","created_at":"2026-01-30T12:47:59.119895-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t4","depends_on_id":"test-e10t2","type":"blocks","created_at":"2026-01-30T12:52:29.055158-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t4s1","title":"Define staleness rules and TypeScript types for alert system","description":"Create TypeScript types for stale lead alerts including StalenessRule interface (temperature, daysThreshold), StaleLeadAlert interface (leadId, leadName, temperature, daysSinceContact, lastContactDate, urgencyScore, assignedAgent). Define the staleness thresholds as constants: HOT_STALE_DAYS=7, WARM_STALE_DAYS=14, COLD_STALE_DAYS=30. Include urgency calculation formula: urgencyScore = temperatureWeight × daysSinceContact (where hot=3, warm=2, cold=1).\n\n**Context:** Type-safe foundation ensures the alert system correctly identifies and prioritizes stale leads. The urgency formula makes hot leads going stale surface faster than cold leads, which matches business priority.\n\n**Testing Requirements:**\n- **Unit Tests:** Test urgencyScore calculation: hot lead 7 days stale should score higher than warm lead 14 days stale. Test type validation for StaleLeadAlert interface. Verify threshold constants are correctly typed.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:50:45.392255-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:45.392255-06:00","labels":["backend","types"],"dependencies":[{"issue_id":"test-e10t4s1","depends_on_id":"test-e10t4","type":"parent-child","created_at":"2026-01-30T12:50:45.630918-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t4s2","title":"Create Convex query for stale leads matching staleness criteria","description":"Build Convex query 'getStaleLeads' that: 1) Fetches all active leads with their last contact date and temperature, 2) Filters leads where daysSinceLastContact exceeds their temperature's threshold, 3) Calculates urgency score for each, 4) Returns sorted by urgencyScore descending. Include optional brokerage filter for multi-tenant support. Handle edge case of leads with no contact history (treat as infinitely stale).\n\n**Context:** This query powers the attention-needed queue. Sorting by urgency ensures brokers see the most critical leads first - a hot lead going cold is more urgent than an already-cold lead sitting longer.\n\n**Testing Requirements:**\n- **Unit Tests:** Test query returns leads exceeding threshold (hot lead at 8 days appears, hot lead at 6 days doesn't). Test urgency sorting (hot 10-day stale ranks above warm 20-day stale). Test no-contact leads appear with high urgency. Test brokerage filter isolation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:45.958597-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:45.958597-06:00","labels":["backend","convex"],"dependencies":[{"issue_id":"test-e10t4s2","depends_on_id":"test-e10t4","type":"parent-child","created_at":"2026-01-30T12:50:46.193856-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t4s2","depends_on_id":"test-e10t4s1","type":"blocks","created_at":"2026-01-30T12:52:29.339649-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t4s3","title":"Build AlertCard component with lead info and action buttons","description":"Create AlertCard React component displaying: lead name, temperature badge (color-coded), days stale with warning intensity, last contact date/type, assigned agent (if any). Include action buttons: 'Contact Now' (opens lead detail/contact flow), 'Assign to Agent' (dropdown of available agents), 'Snooze' (options: 1 day, 3 days, 1 week with visual indicator). Style urgency visually - more stale = more prominent warning styling.\n\n**Context:** One-click actions are critical. A broker seeing 20 stale leads won't act if each requires 3 clicks. Snooze prevents alert fatigue for leads intentionally waiting (e.g., 'call back next week').\n\n**Testing Requirements:**\n- **Unit Tests:** Test AlertCard renders all lead info correctly. Test temperature badge shows correct color. Test action button click handlers fire with correct lead ID. Test snooze dropdown options appear. Test urgency styling changes with days stale value.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:46.522608-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:46.522608-06:00","labels":["component","frontend"],"dependencies":[{"issue_id":"test-e10t4s3","depends_on_id":"test-e10t4","type":"parent-child","created_at":"2026-01-30T12:50:46.935884-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t4s3","depends_on_id":"test-e10t4s1","type":"blocks","created_at":"2026-01-30T12:52:29.59395-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t4s4","title":"Build StaleLeadQueue container with real-time updates and mutations","description":"Create StaleLeadQueue component that: 1) Uses Convex useQuery to fetch stale leads with real-time updates, 2) Renders AlertCard list sorted by urgency, 3) Implements 'Assign to Agent' mutation updating lead's assignedAgent field, 4) Implements 'Snooze' mutation that sets snoozedUntil timestamp (query filters out snoozed leads), 5) Shows empty state when no stale leads ('All leads are being actively worked!'). Add count badge showing total stale leads for dashboard summary.\n\n**Context:** Real-time updates mean when an agent contacts a lead, it disappears from the queue instantly. This creates a satisfying 'inbox zero' dynamic that encourages action. The count badge gives brokers at-a-glance health metrics.\n\n**Testing Requirements:**\n- **Unit Tests:** Test queue renders AlertCards in urgency order. Test assign mutation updates lead and removes from queue. Test snooze mutation hides lead until snoozeUntil passes. Test empty state appears when no stale leads. Test count badge matches visible items. Test real-time update removes lead when contacted.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:47.185686-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:47.185686-06:00","labels":["convex","frontend"],"dependencies":[{"issue_id":"test-e10t4s4","depends_on_id":"test-e10t4","type":"parent-child","created_at":"2026-01-30T12:50:47.426286-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t4s4","depends_on_id":"test-e10t4s2","type":"blocks","created_at":"2026-01-30T12:52:29.877933-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t4s4","depends_on_id":"test-e10t4s3","type":"blocks","created_at":"2026-01-30T12:52:30.342634-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t5","title":"Add filtering, export, and mobile-responsive layout","description":"Implement comprehensive filtering (agent, date range, lead temperature, stage), CSV/PDF export for reports, and ensure entire dashboard is mobile-responsive for brokers checking on-the-go.\n\n**Context:** Brokers check dashboards from their phones between meetings. Team leads need to export reports for weekly meetings. Without mobile and export, the dashboard is limited to desk use - missing half the value proposition.\n\n**Testing Requirements:**\n- **Unit Tests:** Filter logic functions, CSV generation, URL param parsing/serialization, responsive breakpoint utilities\n- **Integration Tests:** Filter combinations across all dashboard components, export data accuracy, mobile layout at various breakpoints","design":"Build FilterBar component with agent multi-select, date picker, temperature toggles. Use URL search params for filter state (shareable links). Export via client-side CSV generation and server-side PDF (if needed). Mobile: stack columns vertically, collapsible filter panel, touch-friendly action buttons. Use shadcn/ui Sheet for mobile filters.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:59.337159-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:59.337159-06:00","labels":["dashboard","export","frontend","mobile"],"dependencies":[{"issue_id":"test-e10t5","depends_on_id":"test-e10","type":"parent-child","created_at":"2026-01-30T12:47:59.475657-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5","depends_on_id":"test-e10t1","type":"blocks","created_at":"2026-01-30T12:52:30.880731-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5","depends_on_id":"test-e10t2","type":"blocks","created_at":"2026-01-30T12:52:31.230016-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5","depends_on_id":"test-e10t3","type":"blocks","created_at":"2026-01-30T12:52:31.519736-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5","depends_on_id":"test-e10t4","type":"blocks","created_at":"2026-01-30T12:52:31.779962-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t5s1","title":"Build FilterBar component with URL state management","description":"Create FilterBar component with agent multi-select dropdown, date range picker, lead temperature toggles (hot/warm/cold), and pipeline stage filter. Use URL search params (useSearchParams) to persist filter state so links are shareable. Include a 'Clear filters' button. For mobile, wrap in shadcn/ui Sheet component that slides in from left with a filter icon trigger.\n\n**Context:** URL-based filter state lets brokers share specific views with team leads ('here's our hot leads this month'). Essential for collaboration and bookmarking common views.\n\n**Testing Requirements:**\n- **Unit Tests:** Test filter state serialization to/from URL params, test multi-select agent filtering, test date range validation (end \u003e= start), test temperature toggle combinations, test clear filters resets all state","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:47.664941-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:47.664941-06:00","labels":["dashboard","frontend"],"dependencies":[{"issue_id":"test-e10t5s1","depends_on_id":"test-e10t5","type":"parent-child","created_at":"2026-01-30T12:50:47.852324-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t5s2","title":"Wire FilterBar to dashboard data queries","description":"Connect FilterBar state to the dashboard's data fetching layer. Modify existing queries (metrics, pipeline, agent performance) to accept filter parameters. Ensure filtered state updates all dashboard cards/charts simultaneously. Add loading states during filter changes. Debounce rapid filter changes to avoid excessive API calls.\n\n**Context:** Filters must affect the entire dashboard view consistently - brokers expect clicking 'Agent: John' to show only John's metrics everywhere, not just one section.\n\n**Testing Requirements:**\n- **Unit Tests:** Test query parameters are correctly passed to API calls, test debounce prevents multiple rapid calls, test all dashboard sections receive filtered data, test empty state when filters return no results","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:48.286239-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:48.286239-06:00","labels":["backend","dashboard","frontend"],"dependencies":[{"issue_id":"test-e10t5s2","depends_on_id":"test-e10t5","type":"parent-child","created_at":"2026-01-30T12:50:48.602234-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5s2","depends_on_id":"test-e10t5s1","type":"blocks","created_at":"2026-01-30T12:52:32.080169-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t5s3","title":"Implement CSV and PDF export functionality","description":"Add export dropdown with CSV and PDF options. CSV: client-side generation using current filtered view data - include metrics summary, pipeline deals, and agent stats in separate sheets. PDF: generate via server-side API route using filtered data, return downloadable file. Include current filter context in export filename (e.g., 'dashboard-2024-01-hot-leads.csv'). Add loading spinner during PDF generation.\n\n**Context:** Team leads export reports for weekly meetings. CSV for spreadsheet analysis, PDF for printing/sharing. Filename with filter context prevents confusion when multiple exports are saved.\n\n**Testing Requirements:**\n- **Unit Tests:** Test CSV generation includes all visible data, test CSV handles special characters and commas in data, test PDF API route returns valid file, test filename includes current filter parameters, test export respects current filter state","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:48.975893-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:48.975893-06:00","labels":["backend","dashboard","frontend"],"dependencies":[{"issue_id":"test-e10t5s3","depends_on_id":"test-e10t5","type":"parent-child","created_at":"2026-01-30T12:50:49.224927-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5s3","depends_on_id":"test-e10t5s2","type":"blocks","created_at":"2026-01-30T12:52:32.367985-06:00","created_by":"David Habedank"}]}
{"id":"test-e10t5s4","title":"Make dashboard fully mobile-responsive with touch-friendly interactions","description":"Apply responsive layout to entire dashboard: stack metric cards vertically on mobile, make charts full-width with horizontal scroll for data tables, ensure touch targets are minimum 44px. FilterBar becomes collapsible Sheet on mobile (from 10.5.1). Add swipe gestures for pipeline stage navigation if applicable. Test on actual mobile viewport sizes (375px, 414px). Ensure action buttons (export, filters) are thumb-reachable at bottom of screen on mobile.\n\n**Context:** Brokers check dashboards from phones between client meetings - if it's not mobile-friendly, they won't use it in the field where quick decisions matter most.\n\n**Testing Requirements:**\n- **Unit Tests:** Test responsive breakpoints render correct layouts (mobile/tablet/desktop), test touch targets meet 44px minimum, test Sheet filter panel opens/closes correctly on mobile, test charts remain readable at mobile widths, test export buttons are accessible on small screens","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:49.649577-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:49.649577-06:00","labels":["dashboard","frontend","mobile"],"dependencies":[{"issue_id":"test-e10t5s4","depends_on_id":"test-e10t5","type":"parent-child","created_at":"2026-01-30T12:50:49.888765-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5s4","depends_on_id":"test-e10t5s1","type":"blocks","created_at":"2026-01-30T12:52:32.646564-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5s4","depends_on_id":"test-e10t5s2","type":"blocks","created_at":"2026-01-30T12:52:32.951403-06:00","created_by":"David Habedank"},{"issue_id":"test-e10t5s4","depends_on_id":"test-e10t5s3","type":"blocks","created_at":"2026-01-30T12:52:33.327441-06:00","created_by":"David Habedank"}]}
{"id":"test-e11","title":"Polish, Empty States \u0026 Production Readiness","description":"Final polish including Shep mascot empty states, comprehensive error handling, loading states, settings pages, help integration, and performance optimization for production launch.\n\n**Context:** A product that works isn't enough - it needs to feel delightful and handle edge cases gracefully. Empty states with Shep, clear error recovery, and smooth onboarding are what turn a functional tool into a product people love.\n\n**Testing Requirements:**\n- **Unit Tests:** Error boundary behavior, loading state transitions, settings validation\n- **Integration Tests:** Full onboarding flow timing, error recovery paths, settings persistence\n- **Type Tests:** Settings schema validation, error message types\n- **E2E Tests:** New user complete onboarding in \u003c30 min, empty states display correctly, errors recover gracefully","acceptance_criteria":"- Shep mascot appears in all empty states (no calls yet, no leads, etc.)\n- Comprehensive error handling with friendly recovery messages\n- Loading states feel smooth, not jarring\n- All settings pages complete (org, team, personal preferences)\n- Help/support integration for stuck users\n- Mobile-responsive polish across all views\n- Performance optimized (\u003c2s page loads)\n- New brokerage can go live within 30 minutes","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:47:21.729357-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:21.729357-06:00","labels":["polish","production","ux"],"dependencies":[{"issue_id":"test-e11","depends_on_id":"test-e10","type":"blocks","created_at":"2026-01-30T12:52:33.766558-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t1","title":"Design and implement Shep mascot empty states","description":"Create the Shep mascot component and implement it across all empty state scenarios throughout the app. This includes designing the mascot's various expressions/poses and integrating them with contextual messaging.\n\n**Context:** Empty states are critical user experience moments - they're when users first encounter features or when they've completed work. A friendly mascot transforms these from dead-ends into engaging moments that guide users forward. This directly impacts first impressions and user delight.\n\n**Testing Requirements:**\n- **Unit Tests:** EmptyState component renders correct variant, displays appropriate message and CTA, accessibility testing for alt text\n- **Integration Tests:** Empty states appear correctly when data is empty in CallList, LeadList, Dashboard, Pipeline views","design":"Create a reusable EmptyState component with Shep mascot SVG/illustration that accepts variants (welcome, no-calls, no-leads, all-caught-up, error). Each variant should have appropriate messaging and a clear CTA. Consider animation on mascot for extra polish. Store mascot assets in public folder or as React components.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:59.721845-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:59.721845-06:00","labels":["design","frontend","ui"],"dependencies":[{"issue_id":"test-e11t1","depends_on_id":"test-e11","type":"parent-child","created_at":"2026-01-30T12:47:59.926147-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t1s1","title":"Create Shep mascot SVG assets with variant expressions","description":"Design and create the Shep mascot SVG illustrations for each empty state variant: welcome (friendly wave), no-calls (curious/encouraging), no-leads (searching pose), all-caught-up (celebrating/relaxed), and error (apologetic/helpful). Export as optimized SVGs. Store in src/components/ui/shep/ as individual React components for flexibility.\n\n**Context:** The mascot needs distinct expressions to convey different emotional states - welcoming new users, encouraging action, celebrating completion, or softening errors. Having these as React components allows for future animation and dynamic styling.\n\n**Testing Requirements:**\n- **Unit Tests:** Test each Shep variant component renders without errors, accepts className prop for styling, renders valid SVG elements, snapshot tests for visual regression","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:50.275393-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:50.275393-06:00","labels":["design","frontend"],"dependencies":[{"issue_id":"test-e11t1s1","depends_on_id":"test-e11t1","type":"parent-child","created_at":"2026-01-30T12:50:50.625791-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t1s2","title":"Build reusable EmptyState component with Shep integration","description":"Create EmptyState component that accepts variant prop ('welcome' | 'no-calls' | 'no-leads' | 'all-caught-up' | 'error'), renders appropriate Shep mascot, displays contextual title and description, and includes optional CTA button. Use composition pattern for flexibility. Include subtle CSS animation on Shep (gentle bounce or float) using Tailwind animate classes.\n\n**Context:** A single reusable component ensures consistent empty state UX across the app. The variant system makes it easy to add new states while maintaining the Shep personality throughout.\n\n**Testing Requirements:**\n- **Unit Tests:** Test EmptyState renders correct Shep variant for each variant prop, test title/description/CTA rendering, test CTA onClick callback fires, test animation classes are applied, test accessibility (proper heading hierarchy, button labeling)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:51.091119-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:51.091119-06:00","labels":["frontend"],"dependencies":[{"issue_id":"test-e11t1s2","depends_on_id":"test-e11t1","type":"parent-child","created_at":"2026-01-30T12:50:51.588315-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t1s2","depends_on_id":"test-e11t1s1","type":"blocks","created_at":"2026-01-30T12:52:34.086042-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t1s3","title":"Integrate EmptyState component across app screens","description":"Replace existing empty states or add EmptyState component to: Dashboard (welcome state for new users, all-caught-up when no pending items), Calls list (no-calls variant), Leads/Contacts list (no-leads variant), and any error boundaries (error variant). Wire up CTAs to appropriate actions (e.g., 'Import contacts' button, 'Make your first call').\n\n**Context:** Empty states should guide users to the next logical action. Each placement needs a thoughtful CTA that moves users forward rather than leaving them stranded.\n\n**Testing Requirements:**\n- **Unit Tests:** Test each page component renders EmptyState when data is empty, test CTA buttons navigate/trigger correct actions, test conditional rendering logic (show EmptyState only when truly empty, not during loading)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:52.255644-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:52.255644-06:00","labels":["frontend"],"dependencies":[{"issue_id":"test-e11t1s3","depends_on_id":"test-e11t1","type":"parent-child","created_at":"2026-01-30T12:50:52.722676-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t1s3","depends_on_id":"test-e11t1s2","type":"blocks","created_at":"2026-01-30T12:52:34.389165-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t1s4","title":"Visual QA and polish empty states across all viewports","description":"Test all EmptyState implementations across mobile, tablet, and desktop breakpoints. Verify Shep animations perform well (no jank), mascot scales appropriately, text remains readable, and CTAs are easily tappable on mobile. Fix any responsive issues. Take screenshots for documentation.\n\n**Context:** Empty states are often the first thing users see - they need to look polished across all devices. Mobile is especially important as agents may check the app from their phones.\n\n**Testing Requirements:**\n- **Unit Tests:** Test responsive classes are applied correctly, verify animation keyframes exist in CSS, run Lighthouse accessibility audit on pages with empty states","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:53.361679-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:53.361679-06:00","labels":["frontend","qa"],"dependencies":[{"issue_id":"test-e11t1s4","depends_on_id":"test-e11t1","type":"parent-child","created_at":"2026-01-30T12:50:53.575372-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t1s4","depends_on_id":"test-e11t1s3","type":"blocks","created_at":"2026-01-30T12:52:34.736122-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t2","title":"Implement comprehensive error handling and recovery UI","description":"Create a unified error boundary system with friendly error messages, recovery actions, and fallback UI. Handle API failures, network issues, auth errors, and unexpected exceptions gracefully.\n\n**Context:** When things go wrong, users need to understand what happened and have a clear path forward. Cryptic errors or blank screens destroy trust. Friendly recovery messaging is especially important for less tech-savvy brokerage owners who may panic at errors.\n\n**Testing Requirements:**\n- **Unit Tests:** ErrorBoundary catches errors and renders fallback, retry button triggers refetch, toast notifications display and dismiss correctly\n- **Integration Tests:** Simulate API failures, network disconnection, auth expiration - verify graceful degradation and recovery flows","design":"Create ErrorBoundary wrapper components at route and feature levels. Build toast notification system for transient errors. Implement retry mechanisms for failed API calls. Create dedicated error page for unrecoverable states. Use Shep mascot in error states where appropriate. Log errors to monitoring service.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:48:00.264767-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:00.264767-06:00","labels":["error-handling","frontend","ux"],"dependencies":[{"issue_id":"test-e11t2","depends_on_id":"test-e11","type":"parent-child","created_at":"2026-01-30T12:48:00.519352-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t2","depends_on_id":"test-e11t1","type":"blocks","created_at":"2026-01-30T12:52:35.131633-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t2s1","title":"Create ErrorBoundary component system with fallback UI","description":"Build React ErrorBoundary components for route-level and feature-level error catching. Create friendly fallback UI components that display the Shep mascot, human-readable error messages, and clear recovery actions (retry, go home, contact support). Include different severity levels: warning (yellow), error (red), info (blue).\n\n**Context:** ErrorBoundaries are React's way to catch JavaScript errors anywhere in the component tree. Without them, a single component crash takes down the whole app - terrifying for non-technical brokerage owners.\n\n**Testing Requirements:**\n- **Unit Tests:** Test ErrorBoundary catches thrown errors, test fallback UI renders correctly, test recovery button calls reset function, test different error severity levels display correct styling, test Shep mascot renders in error state","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:53.863684-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:53.863684-06:00","labels":["error-handling","frontend"],"dependencies":[{"issue_id":"test-e11t2s1","depends_on_id":"test-e11t2","type":"parent-child","created_at":"2026-01-30T12:50:54.064636-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t2s2","title":"Implement toast notification system for transient errors","description":"Create a toast/snackbar notification system for non-blocking errors and status messages. Use react-hot-toast or similar library. Implement toast types: success (green), error (red), warning (yellow), info (blue). Include auto-dismiss timers, manual dismiss, and optional action buttons. Position toasts consistently (top-right or bottom-right).\n\n**Context:** Transient errors like 'Failed to save, retrying...' shouldn't block the UI. Toasts let users continue working while being informed. Critical for busy team leads who can't afford workflow interruptions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test toast appears on trigger, test auto-dismiss after timeout, test manual dismiss works, test action button callback fires, test multiple toasts stack correctly, test different toast types have correct styling","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:54.331446-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:54.331446-06:00","labels":["error-handling","frontend"],"dependencies":[{"issue_id":"test-e11t2s2","depends_on_id":"test-e11t2","type":"parent-child","created_at":"2026-01-30T12:50:54.552966-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t2s3","title":"Build API error handling utilities with retry logic","description":"Create centralized error handling utilities for API calls. Implement exponential backoff retry for network failures (max 3 retries). Build error classification: isNetworkError, isAuthError (401), isRateLimited (429), isServerError (5xx). Create user-friendly error message mapper that converts technical errors to plain English. Integrate with toast system for automatic error notifications.\n\n**Context:** API calls fail for many reasons - network blips, auth expiration, rate limits. Smart retry logic with friendly messages prevents users from seeing cryptic 'Error 500' messages that cause panic.\n\n**Testing Requirements:**\n- **Unit Tests:** Test retry logic attempts correct number of times, test exponential backoff timing, test error classification correctly identifies error types, test auth errors (401) trigger logout flow, test rate limit (429) shows appropriate message, test error message mapper returns friendly strings for each error type","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:54.86304-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:54.86304-06:00","labels":["api","error-handling","frontend"],"dependencies":[{"issue_id":"test-e11t2s3","depends_on_id":"test-e11t2","type":"parent-child","created_at":"2026-01-30T12:50:55.099561-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t2s3","depends_on_id":"test-e11t2s2","type":"blocks","created_at":"2026-01-30T12:52:35.475236-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t2s4","title":"Create dedicated error pages and wire up error logging","description":"Build dedicated error pages: 404 Not Found, 500 Server Error, Network Offline, Session Expired. Each page includes Shep mascot, friendly explanation, and clear next steps. Implement error logging utility that captures errors with context (user ID, route, action attempted) ready for future monitoring service integration. Wire ErrorBoundaries to use these pages for unrecoverable errors.\n\n**Context:** When something truly breaks, users need a friendly dead-end that explains what happened and what to do. Logging captures the details developers need to fix issues users report.\n\n**Testing Requirements:**\n- **Unit Tests:** Test 404 page renders with correct messaging, test 500 page shows retry and contact support options, test offline page detects network restoration, test session expired page has login redirect, test error logger captures error stack and context, test ErrorBoundary routes to correct error page based on error type","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:55.342943-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:55.342943-06:00","labels":["error-handling","frontend","logging"],"dependencies":[{"issue_id":"test-e11t2s4","depends_on_id":"test-e11t2","type":"parent-child","created_at":"2026-01-30T12:50:55.587564-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t2s4","depends_on_id":"test-e11t2s1","type":"blocks","created_at":"2026-01-30T12:52:35.815694-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t2s4","depends_on_id":"test-e11t2s3","type":"blocks","created_at":"2026-01-30T12:52:36.085958-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t3","title":"Polish loading states and skeleton screens","description":"Replace spinner-only loading states with contextual skeleton screens. Ensure loading states feel smooth with appropriate animations and don't cause layout shift.\n\n**Context:** Perceived performance is as important as actual performance. Users feel like the app is faster when they see meaningful skeleton content rather than spinners. Smooth transitions prevent the 'jarring' feeling that makes apps feel cheap.\n\n**Testing Requirements:**\n- **Unit Tests:** Skeleton components render with correct dimensions, shimmer animation runs, Suspense boundaries trigger skeletons\n- **Integration Tests:** Loading states appear during data fetches, no layout shift when content loads, transitions feel smooth on throttled network","design":"Create skeleton variants for each major component (CallCard, LeadCard, DashboardStats, etc.). Use CSS shimmer animation for skeletons. Implement Suspense boundaries strategically. Ensure skeleton dimensions match loaded content to prevent layout shift. Consider optimistic UI updates for user actions.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:48:00.74951-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:00.74951-06:00","labels":["frontend","performance","ui"],"dependencies":[{"issue_id":"test-e11t3","depends_on_id":"test-e11","type":"parent-child","created_at":"2026-01-30T12:48:00.914522-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t3s1","title":"Create base skeleton component with shimmer animation","description":"Build a reusable Skeleton component with CSS shimmer animation. Support variants: 'text' (single line), 'title' (larger text), 'circle' (avatar), 'rectangle' (card/image). Props should include width, height, and className for customization. Use CSS keyframes for the shimmer effect - gradient that moves left to right. Match Tailwind's color system (gray-200 base, gray-100 shimmer highlight).\n\n**Context:** A consistent skeleton component ensures all loading states look cohesive and professional. The shimmer animation gives visual feedback that something is happening, reducing perceived wait time.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Skeleton renders each variant correctly, test custom width/height props apply, test className prop merges correctly, verify shimmer animation CSS class is applied","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:55.907161-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:55.907161-06:00","labels":["components","frontend"],"dependencies":[{"issue_id":"test-e11t3s1","depends_on_id":"test-e11t3","type":"parent-child","created_at":"2026-01-30T12:50:56.089168-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t3s2","title":"Create skeleton variants for CallCard and LeadCard","description":"Build CallCardSkeleton and LeadCardSkeleton components that exactly match the dimensions of their loaded counterparts. CallCardSkeleton: avatar circle, title line, two smaller text lines, action button area. LeadCardSkeleton: name line, property address line, status badge placeholder, contact info lines. Use flexbox/grid matching actual components to prevent layout shift. Export from same files as real components.\n\n**Context:** These are the most frequently seen components in the app. Their skeletons need to exactly match dimensions to prevent jarring layout shifts when data loads.\n\n**Testing Requirements:**\n- **Unit Tests:** Test CallCardSkeleton renders correct number of skeleton elements, test LeadCardSkeleton structure matches LeadCard, verify skeleton height matches loaded component height (snapshot or computed style), test components render without props","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:56.332461-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:56.332461-06:00","labels":["components","frontend"],"dependencies":[{"issue_id":"test-e11t3s2","depends_on_id":"test-e11t3","type":"parent-child","created_at":"2026-01-30T12:50:56.552197-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t3s2","depends_on_id":"test-e11t3s1","type":"blocks","created_at":"2026-01-30T12:52:36.378745-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t3s3","title":"Create skeleton variants for DashboardStats and list views","description":"Build DashboardStatsSkeleton (grid of stat card skeletons with number + label placeholders), CallListSkeleton (renders 3-5 CallCardSkeleton items), and LeadListSkeleton (renders 4-6 LeadCardSkeleton items). List skeletons should accept optional 'count' prop to customize number of items. Add subtle stagger to shimmer animations on list items for visual polish.\n\n**Context:** Dashboard is the first thing users see - its skeleton sets the tone for perceived performance. List skeletons prevent the empty void feeling while data loads.\n\n**Testing Requirements:**\n- **Unit Tests:** Test DashboardStatsSkeleton renders correct grid structure, test list skeletons render default item count, test custom count prop works, verify stagger animation delay increases per item","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:56.782552-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:56.782552-06:00","labels":["components","frontend"],"dependencies":[{"issue_id":"test-e11t3s3","depends_on_id":"test-e11t3","type":"parent-child","created_at":"2026-01-30T12:50:57.135502-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t3s3","depends_on_id":"test-e11t3s2","type":"blocks","created_at":"2026-01-30T12:52:36.647857-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t3s4","title":"Replace existing loading states with skeleton screens and add Suspense boundaries","description":"Audit all current loading states (search for 'loading', 'isLoading', 'Spinner'). Replace each with appropriate skeleton component. Add React Suspense boundaries around: dashboard sections, call lists, lead lists, agent views. Ensure fallback props use correct skeleton components. Test that layout doesn't shift when data loads. Remove old spinner-only implementations. Add 150ms minimum display time for skeletons to prevent flash for fast loads.\n\n**Context:** This is where the UX improvement actually lands. Users will now see meaningful skeleton content instead of generic spinners, making the app feel faster and more polished.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Suspense boundaries render skeleton fallbacks, test skeleton-to-content transition doesn't cause layout shift (measure container dimensions), test minimum display time prevents skeleton flash, verify no remaining spinner-only loading states in codebase","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:57.403873-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:57.403873-06:00","labels":["frontend","ux"],"dependencies":[{"issue_id":"test-e11t3s4","depends_on_id":"test-e11t3","type":"parent-child","created_at":"2026-01-30T12:50:57.585478-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t3s4","depends_on_id":"test-e11t3s3","type":"blocks","created_at":"2026-01-30T12:52:37.006764-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t4","title":"Build settings pages (org, team, personal preferences)","description":"Create complete settings interface including organization settings (branding, integrations), team management (roles, permissions), and personal preferences (notifications, display). Include FUB connection management.\n\n**Context:** Settings are where admins configure the product for their brokerage. Without complete settings pages, customers can't customize their experience or manage their team - blocking production deployment for any brokerage with specific needs.\n\n**Testing Requirements:**\n- **Unit Tests:** Settings forms validate input, save handlers update Convex, role-based visibility works correctly\n- **Integration Tests:** Full settings flow - update org name, invite team member, change personal preferences, reconnect FUB integration","design":"Create tabbed settings layout with sections: Organization (name, logo, FUB integration status), Team (member list, role assignment, invites), Personal (notification preferences, timezone, display settings). Use forms with validation. Show current FUB sync status and reconnection options. Implement role-based access to different settings sections.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":420,"created_at":"2026-01-30T12:48:01.158488-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:01.158488-06:00","labels":["backend","frontend","settings"],"dependencies":[{"issue_id":"test-e11t4","depends_on_id":"test-e11","type":"parent-child","created_at":"2026-01-30T12:48:01.348962-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t4s1","title":"Create settings layout with tabbed navigation structure","description":"Build the main settings page layout with tab navigation for Organization, Team, and Personal sections. Create the routing structure (/settings, /settings/organization, /settings/team, /settings/personal). Implement tab component that highlights active section and handles navigation. Include role-based visibility logic to hide tabs users don't have access to (e.g., non-admins can't see Organization tab).\n\n**Context:** The tabbed layout is the foundation for all settings content. Getting the navigation and access control right first means subsequent subtasks can focus purely on form content without worrying about structure or permissions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test tab navigation renders correct tabs based on user role, test route changes update active tab, test unauthorized users are redirected from restricted tabs, test tab keyboard navigation accessibility","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:57.855603-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:57.855603-06:00","labels":["frontend","navigation"],"dependencies":[{"issue_id":"test-e11t4s1","depends_on_id":"test-e11t4","type":"parent-child","created_at":"2026-01-30T12:50:58.149611-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t4s2","title":"Build Organization settings section with FUB integration status","description":"Create Organization settings tab content with forms for: brokerage name, logo upload, and FUB integration management. Display current FUB sync status (connected/disconnected, last sync time, sync health). Include reconnect button that triggers OAuth flow and disconnect option with confirmation. Show API usage stats if available. Use react-hook-form with zod validation for all form fields.\n\n**Context:** Organization settings control the brokerage's identity and their crucial FUB connection. FUB integration status is especially important since the entire product depends on this data pipeline working - admins need visibility into sync health and easy recovery options.\n\n**Testing Requirements:**\n- **Unit Tests:** Test form validation for org name (required, max length), test logo upload preview and file type validation, test FUB status display for connected/disconnected states, test reconnect button triggers auth flow, test disconnect shows confirmation modal","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:58.387648-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:58.387648-06:00","labels":["forms","frontend","integrations"],"dependencies":[{"issue_id":"test-e11t4s2","depends_on_id":"test-e11t4","type":"parent-child","created_at":"2026-01-30T12:50:58.712817-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t4s2","depends_on_id":"test-e11t4s1","type":"blocks","created_at":"2026-01-30T12:52:37.385759-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t4s3","title":"Build Team management section with roles and invites","description":"Create Team settings tab with: member list table showing name, email, role, and status; role assignment dropdown (Admin, Manager, Agent); invite new member form with email and role selection; pending invites list with resend/revoke options. Implement bulk actions for role changes. Show last active timestamp for each member. Include search/filter for larger teams.\n\n**Context:** Team management is how brokerage owners control who has access and what they can do. With teams of 20-100 agents, the list needs to be scannable and bulk operations save significant time. Role assignments directly affect what settings users can access.\n\n**Testing Requirements:**\n- **Unit Tests:** Test member list renders with correct columns, test role dropdown updates member role, test invite form validates email format, test pending invites show resend/revoke actions, test search filters member list correctly, test bulk role change applies to selected members","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:59.286608-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:59.286608-06:00","labels":["forms","frontend","team-management"],"dependencies":[{"issue_id":"test-e11t4s3","depends_on_id":"test-e11t4","type":"parent-child","created_at":"2026-01-30T12:50:59.46929-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t4s3","depends_on_id":"test-e11t4s1","type":"blocks","created_at":"2026-01-30T12:52:37.960513-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t4s4","title":"Build Personal preferences section and verify all settings save correctly","description":"Create Personal settings tab with: notification preferences (email frequency, alert types toggles), timezone selection dropdown, display settings (date format, default view preferences). All forms should auto-save or have explicit save buttons with loading states. Add success/error toast notifications for all save operations. Run through all three tabs ensuring forms submit correctly, validation works, and saved values persist on page refresh.\n\n**Context:** Personal preferences let each user customize their experience without affecting others. This is also the verification step - settings that don't actually save are worse than no settings at all. Testing the full save/load cycle ensures the settings pages actually work end-to-end.\n\n**Testing Requirements:**\n- **Unit Tests:** Test notification toggles save state correctly, test timezone dropdown shows user's current selection, test display format changes apply immediately, test form submission shows loading state, test success toast appears after save, test error toast appears on API failure, test refreshing page loads previously saved values","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:59.84296-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:59.84296-06:00","labels":["forms","frontend","preferences"],"dependencies":[{"issue_id":"test-e11t4s4","depends_on_id":"test-e11t4","type":"parent-child","created_at":"2026-01-30T12:51:00.090073-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t4s4","depends_on_id":"test-e11t4s1","type":"blocks","created_at":"2026-01-30T12:52:38.224017-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t5","title":"Mobile responsive polish and help/support integration","description":"Audit and fix mobile responsiveness across all views. Add help integration points including contextual tooltips, help links, and support contact options for stuck users.\n\n**Context:** Agents and team leads often check pipeline on mobile between showings. Broken mobile views mean lost engagement. Help integration ensures users can self-serve or reach support rather than churning when confused.\n\n**Testing Requirements:**\n- **Unit Tests:** Components render correctly at mobile breakpoints, HelpTooltip displays on hover/tap, help drawer opens and closes\n- **Integration Tests:** Full mobile user flow - login, view dashboard, check calls, access settings on mobile viewport. Help integration accessible from all main views.","design":"Audit each view at 375px, 768px, 1024px breakpoints. Fix navigation collapse, table responsiveness, modal sizing. Add HelpTooltip component for complex features. Create help drawer/modal with FAQ and support contact. Consider Intercom or similar for chat support. Add onboarding tour for first-time users.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:48:01.563908-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:01.563908-06:00","labels":["frontend","mobile","support","ux"],"dependencies":[{"issue_id":"test-e11t5","depends_on_id":"test-e11","type":"parent-child","created_at":"2026-01-30T12:48:01.726723-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t5","depends_on_id":"test-e11t1","type":"blocks","created_at":"2026-01-30T12:52:38.519322-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t5","depends_on_id":"test-e11t2","type":"blocks","created_at":"2026-01-30T12:52:38.899756-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t5","depends_on_id":"test-e11t3","type":"blocks","created_at":"2026-01-30T12:52:39.144799-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t5","depends_on_id":"test-e11t4","type":"blocks","created_at":"2026-01-30T12:52:39.44223-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t5s1","title":"Audit and fix mobile responsive issues across all views","description":"Systematically test all views at 375px, 768px, and 1024px breakpoints. Document issues in each view (dashboard, pipeline, agent detail, settings). Fix navigation collapse behavior, ensure hamburger menu works correctly. Fix table responsiveness - consider horizontal scroll or card layout for narrow screens. Fix modal sizing to not overflow on mobile. Ensure touch targets are minimum 44px. Test form inputs don't zoom on iOS.\n\n**Context:** Agents check pipeline between showings on mobile. Broken layouts mean they won't use the app, defeating the accountability purpose. Mobile-first real estate workflows are common.\n\n**Testing Requirements:**\n- **Unit Tests:** Test responsive breakpoint CSS classes apply correctly. Test navigation collapse state management. Test table component renders card view below 768px. Visual regression tests at each breakpoint.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:51:00.413378-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:00.413378-06:00","labels":["frontend","mobile","polish"],"dependencies":[{"issue_id":"test-e11t5s1","depends_on_id":"test-e11t5","type":"parent-child","created_at":"2026-01-30T12:51:00.614837-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t5s2","title":"Create HelpTooltip component for contextual help","description":"Build a reusable HelpTooltip component that shows explanatory text on hover/tap. Props: content (string or ReactNode), placement (top/bottom/left/right), trigger (hover/click for mobile). Use Radix UI Tooltip or similar accessible primitive. Style consistently with design system. Add to complex features: pipeline stages, score explanations, sync status indicators, filter options.\n\n**Context:** Users need in-context help for domain-specific concepts like 'stale contact' or 'pipeline stage'. Tooltips reduce confusion without requiring users to leave their workflow.\n\n**Testing Requirements:**\n- **Unit Tests:** Test tooltip renders on hover, test click trigger for mobile, test keyboard accessibility (focus shows tooltip), test placement options, test custom content renders correctly.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:51:00.924165-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:00.924165-06:00","labels":["accessibility","component","frontend"],"dependencies":[{"issue_id":"test-e11t5s2","depends_on_id":"test-e11t5","type":"parent-child","created_at":"2026-01-30T12:51:01.162709-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t5s3","title":"Build help drawer with FAQ and support contact","description":"Create a HelpDrawer component accessible from header help icon (?). Include: searchable FAQ section with common questions (What does stale mean? How do I sync? Why is my data delayed?), support contact form or mailto link, link to documentation/guides. Use Sheet/Drawer pattern for mobile-friendly slide-in. Consider keyboard shortcut (? key) to open. Store FAQ content in separate file for easy updates.\n\n**Context:** When users are stuck, they need a clear path to answers or support. A help drawer keeps them in the app rather than abandoning. Self-serve FAQ reduces support load.\n\n**Testing Requirements:**\n- **Unit Tests:** Test drawer opens/closes correctly, test FAQ search filters results, test support form validation, test keyboard shortcut opens drawer, test focus trap when open.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:51:01.46216-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:01.46216-06:00","labels":["component","frontend","support"],"dependencies":[{"issue_id":"test-e11t5s3","depends_on_id":"test-e11t5","type":"parent-child","created_at":"2026-01-30T12:51:01.640616-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t5s3","depends_on_id":"test-e11t5s2","type":"blocks","created_at":"2026-01-30T12:52:39.759478-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t5s4","title":"Add onboarding tour for first-time users","description":"Implement a guided tour using react-joyride or similar library. Tour should highlight: main navigation, pipeline overview, how to view agent details, where to find help. Trigger on first login (check localStorage or user metadata). Allow skip and 'don't show again'. Show progress indicators (step 3 of 5). Ensure tour works on mobile with appropriate positioning. Add 'Restart tour' option in help drawer.\n\n**Context:** First-time users need orientation to understand what RealHerd offers. A quick tour increases activation and reduces early churn from confusion.\n\n**Testing Requirements:**\n- **Unit Tests:** Test tour starts on first visit, test skip functionality persists preference, test tour step navigation (next/prev/skip), test mobile positioning doesn't overflow, test 'restart tour' resets state.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:51:01.931575-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:01.931575-06:00","labels":["frontend","onboarding","ux"],"dependencies":[{"issue_id":"test-e11t5s4","depends_on_id":"test-e11t5","type":"parent-child","created_at":"2026-01-30T12:51:02.123353-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t5s4","depends_on_id":"test-e11t5s3","type":"blocks","created_at":"2026-01-30T12:52:40.027223-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t6","title":"Performance optimization and production readiness verification","description":"Optimize for \u003c2s page loads including bundle analysis, image optimization, query efficiency, and caching. Verify new brokerage onboarding completes within 30 minutes. Create production checklist.\n\n**Context:** Performance directly impacts user perception and engagement. The 30-minute onboarding target is a business commitment - new customers need to see value quickly or they'll churn before they've even started. This task gates production launch.\n\n**Testing Requirements:**\n- **Unit Tests:** Lazy-loaded components load correctly, image optimization applied, query performance within bounds\n- **Integration Tests:** Lighthouse performance score \u003e80, full page loads \u003c2s on average connection, complete new brokerage setup (Clerk org → FUB connection → first sync → dashboard view) under 30 minutes","design":"Run Lighthouse audits, analyze bundle with @next/bundle-analyzer. Implement dynamic imports for heavy components. Optimize images with Next.js Image. Review Convex queries for N+1 problems. Add appropriate caching headers. Test onboarding flow end-to-end and document steps. Create production deployment checklist.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:48:02.224573-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:02.224573-06:00","labels":["devops","performance","production"],"dependencies":[{"issue_id":"test-e11t6","depends_on_id":"test-e11","type":"parent-child","created_at":"2026-01-30T12:48:02.599635-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t6","depends_on_id":"test-e11t5","type":"blocks","created_at":"2026-01-30T12:52:40.384501-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t6s1","title":"Bundle analysis and code splitting optimization","description":"Install and configure @next/bundle-analyzer. Run analysis to identify large dependencies. Implement dynamic imports for heavy components (charts, rich text editors, modals). Split code by route. Target: main bundle under 200KB gzipped.\n\n**Context:** Large bundles are the #1 cause of slow initial loads. Identifying and splitting heavy dependencies is the foundation for meeting the \u003c2s target.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify dynamic imports load correctly with React.lazy/Suspense. Test that split chunks load on demand. Verify no import errors in console during navigation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:51:02.364274-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:02.364274-06:00","labels":["frontend","performance"],"dependencies":[{"issue_id":"test-e11t6s1","depends_on_id":"test-e11t6","type":"parent-child","created_at":"2026-01-30T12:51:02.540941-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t6s2","title":"Image optimization and asset performance","description":"Audit all images and convert to Next.js Image component with proper sizing, formats (WebP/AVIF), and lazy loading. Implement blur placeholders for above-fold images. Add appropriate Cache-Control headers for static assets. Optimize any SVG icons.\n\n**Context:** Images often account for 50%+ of page weight. Next.js Image provides automatic optimization but requires proper configuration for each use case.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Image components render with correct dimensions and srcset. Verify lazy loading triggers on scroll. Check blur placeholders display during load.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:51:02.841103-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:02.841103-06:00","labels":["frontend","performance"],"dependencies":[{"issue_id":"test-e11t6s2","depends_on_id":"test-e11t6","type":"parent-child","created_at":"2026-01-30T12:51:03.040902-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t6s3","title":"Convex query optimization and caching","description":"Review all Convex queries for N+1 problems using Convex dashboard. Add indexes for frequently filtered/sorted fields. Implement query result caching where appropriate. Optimize subscription patterns to avoid over-fetching. Test with realistic data volumes (100 agents, 1000 deals).\n\n**Context:** Database queries are often the bottleneck in perceived performance. N+1 queries multiply latency and Convex's real-time subscriptions need careful management to avoid unnecessary re-renders.\n\n**Testing Requirements:**\n- **Unit Tests:** Test queries return expected data with mock Convex. Verify index usage via Convex dashboard. Test query performance with 100+ records returns in \u003c100ms.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:51:03.291214-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:03.291214-06:00","labels":["backend","performance"],"dependencies":[{"issue_id":"test-e11t6s3","depends_on_id":"test-e11t6","type":"parent-child","created_at":"2026-01-30T12:51:03.481761-06:00","created_by":"David Habedank"}]}
{"id":"test-e11t6s4","title":"Lighthouse audits, onboarding verification, and production checklist","description":"Run Lighthouse audits on key pages (dashboard, pipeline, agent detail). Fix any performance, accessibility, or SEO issues until scores are 90+. Time complete onboarding flow end-to-end (FUB connection, agent import, first pipeline view) - must complete in \u003c30 minutes. Create production checklist covering: environment variables, DNS/SSL, error tracking, analytics, backup verification, rollback procedure.\n\n**Context:** This is the final gate before production. Lighthouse provides objective performance metrics, the onboarding timing validates the business commitment, and the checklist ensures nothing is forgotten during deployment.\n\n**Testing Requirements:**\n- **Unit Tests:** Document Lighthouse scores for each key page (target 90+). Record onboarding completion time with timestamps for each step. Verify checklist items are actionable and complete.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:51:03.848488-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:51:03.848488-06:00","labels":["devops","documentation","frontend"],"dependencies":[{"issue_id":"test-e11t6s4","depends_on_id":"test-e11t6","type":"parent-child","created_at":"2026-01-30T12:51:04.080082-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t6s4","depends_on_id":"test-e11t6s1","type":"blocks","created_at":"2026-01-30T12:52:40.834894-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t6s4","depends_on_id":"test-e11t6s2","type":"blocks","created_at":"2026-01-30T12:52:41.125083-06:00","created_by":"David Habedank"},{"issue_id":"test-e11t6s4","depends_on_id":"test-e11t6s3","type":"blocks","created_at":"2026-01-30T12:52:41.453603-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1","title":"Initialize Next.js 16 project with Tailwind v4 and TypeScript","description":"Create new Next.js 16 project with App Router, TypeScript strict mode, Tailwind CSS v4, and ESLint configuration. Set up project structure following Next.js best practices with src/ directory organization.\n\n**Context:** Foundation task that everything else depends on. Without a working Next.js app, no other code can be written or tested. RealHerd needs a modern, performant frontend framework to deliver the real-time pipeline visibility that brokers and team leads require.\n\n**Testing Requirements:**\n- **Unit Tests:** TypeScript compilation succeeds, ESLint passes with no errors\n- **Integration Tests:** npm run dev starts successfully, page renders at localhost:3000","design":"Use `npx create-next-app@latest` with TypeScript and App Router. Configure Tailwind v4 using the new CSS-based configuration approach. Set up path aliases in tsconfig.json for clean imports (@/components, @/lib, etc.).","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:47:21.889247-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:21.889247-06:00","labels":["foundation","frontend","infrastructure","setup"],"dependencies":[{"issue_id":"test-e1t1","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:47:22.068123-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s1","title":"Create Next.js 16 project with TypeScript and App Router","description":"Run `npx create-next-app@latest realherd` with the following options: TypeScript (Yes), ESLint (Yes), Tailwind CSS (Yes), src/ directory (Yes), App Router (Yes), import alias (@/*). This creates the base project structure with all required tooling pre-configured.\n\n**Context:** This is the absolute foundation - without this command completing successfully, nothing else can be built. Next.js 16 with App Router is chosen for its server components, streaming, and modern React patterns that will power RealHerd's real-time features.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify project created: check package.json exists with next/react/typescript deps, check tsconfig.json exists with strict mode, check src/app/page.tsx exists, check tailwind.config.ts exists","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":15,"created_at":"2026-01-30T12:48:03.380351-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:03.380351-06:00","labels":["backend","frontend","setup"],"dependencies":[{"issue_id":"test-e1t1s1","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:48:05.421502-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s2","title":"Configure TypeScript strict mode and path aliases","description":"Update tsconfig.json to enable strict mode options: strict: true, noUncheckedIndexedAccess: true, exactOptionalPropertyTypes: true. Verify path aliases are configured: @/components/*, @/lib/*, @/hooks/*, @/types/*. Create placeholder directories: src/components/, src/lib/, src/hooks/, src/types/.\n\n**Context:** Strict TypeScript catches bugs at compile time rather than runtime. Path aliases enable clean imports like `import { Button } from '@/components/ui'` instead of relative path hell. These conventions must be established before any code is written.\n\n**Testing Requirements:**\n- **Unit Tests:** Create test file src/lib/test.ts with intentional type error, verify `npx tsc --noEmit` fails. Fix error, verify it passes. Test import alias by importing from @/lib/test in page.tsx.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":20,"created_at":"2026-01-30T12:48:06.914944-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:06.914944-06:00","labels":["backend","frontend","schema","styling","typescript"],"dependencies":[{"issue_id":"test-e1t1s2","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:48:07.466682-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s2","depends_on_id":"test-e1t1s1","type":"blocks","created_at":"2026-01-30T12:51:04.253278-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s3","title":"Configure Tailwind CSS v4 with CSS-based configuration","description":"Tailwind v4 uses CSS-based configuration instead of JS config. Update src/app/globals.css to use @theme directive for customization. Add RealHerd brand color placeholders (primary, secondary, accent). Configure dark mode support. Remove or update tailwind.config.ts if create-next-app generated the old format.\n\n**Context:** Tailwind v4's CSS-first approach is a major shift from v3. Getting this right now prevents confusion later. RealHerd's UI needs consistent theming that can be easily customized per-brokerage in the future.\n\n**Testing Requirements:**\n- **Unit Tests:** Add test utility class to globals.css, use it in page.tsx, run `npm run dev` and verify styles apply in browser. Test dark mode toggle works. Verify no Tailwind config errors in console.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:08.179057-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:08.179057-06:00","labels":["backend","components","frontend","relationships","schema","styling"],"dependencies":[{"issue_id":"test-e1t1s3","depends_on_id":"test-e1t1s2","type":"blocks","created_at":"2026-01-30T12:09:13.72196-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s3","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:48:08.941718-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s3","depends_on_id":"test-e1t1s1","type":"blocks","created_at":"2026-01-30T12:51:04.514415-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s4","title":"Verify complete setup with dev server and production build","description":"Run `npm run dev` and verify the app loads at localhost:3000 without errors. Run `npm run build` to verify production build succeeds with no TypeScript or ESLint errors. Run `npm run lint` to verify ESLint configuration works. Document any configuration choices in README.md.\n\n**Context:** A project that can't build is worthless. This verification step ensures the foundation is solid before any feature work begins. Catching build issues now saves hours of debugging later when the codebase is larger.\n\n**Testing Requirements:**\n- **Unit Tests:** Dev server starts without errors (check terminal output), page renders in browser, production build completes with exit code 0, lint passes with no errors, build output shows TypeScript compilation success","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":15,"created_at":"2026-01-30T12:48:09.729672-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:09.729672-06:00","labels":["backend","documentation","frontend","setup","testing","verification"],"dependencies":[{"issue_id":"test-e1t1s4","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:48:09.955932-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s4","depends_on_id":"test-e1t1s2","type":"blocks","created_at":"2026-01-30T12:51:04.863513-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s4","depends_on_id":"test-e1t1s3","type":"blocks","created_at":"2026-01-30T12:51:05.172551-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2","title":"Configure Convex backend and deploy initial schema","description":"Install Convex SDK, initialize Convex project, create basic schema with users table, configure environment variables, and verify real-time connection works from Next.js client.\n\n**Context:** Convex provides the real-time database that powers RealHerd's live pipeline visibility - the core value prop for brokers wanting to see deal status without asking agents. Must be set up early as all data operations depend on it.\n\n**Testing Requirements:**\n- **Unit Tests:** Schema validation passes, Convex functions type-check correctly\n- **Integration Tests:** Convex dashboard shows deployed schema, useQuery hook returns data in browser","design":"Use `npx convex dev` for local development. Create schema.ts with initial users table (clerk_id, email, role, created_at). Set up ConvexProvider in Next.js layout. Store CONVEX_URL in .env.local.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":180,"created_at":"2026-01-30T12:47:22.302878-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:22.302878-06:00","labels":["backend","convex","database","setup"],"dependencies":[{"issue_id":"test-e1t2","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:47:22.777893-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2","depends_on_id":"test-e1t1","type":"blocks","created_at":"2026-01-30T12:51:05.380715-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s1","title":"Install Convex SDK and initialize project","description":"Run `npm install convex` to add Convex SDK to the project. Run `npx convex dev` to initialize Convex project - this will create the convex/ directory structure, generate convex/_generated/ files, and prompt for Convex account login/project creation. Accept defaults for project name (realherd).\n\n**Context:** Convex initialization creates the local development environment and links to Convex cloud. The _generated files provide type-safe client bindings that update automatically as schema evolves.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify convex/ directory exists with _generated/ subdirectory. Check package.json includes 'convex' dependency. Verify convex.json config file was created with project reference.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":15,"created_at":"2026-01-30T12:48:10.220869-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:10.220869-06:00","labels":["auth","backend","frontend","setup"],"dependencies":[{"issue_id":"test-e1t2s1","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:48:10.493654-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s2","title":"Create initial schema with users table","description":"Create convex/schema.ts with users table definition. Fields: clerk_id (string, indexed), email (string), role (string union: 'broker' | 'team_lead' | 'agent'), created_at (number, Unix timestamp). Export the schema using defineSchema() and defineTable() from 'convex/server'. Add index on clerk_id for fast user lookups after Clerk authentication.\n\n**Context:** The users table is the foundation for all RealHerd features - every contact, deal, and action will reference a user. The clerk_id index is critical for the Clerk→Convex user lookup that happens on every authenticated request.\n\n**Testing Requirements:**\n- **Unit Tests:** Run `npx convex dev` and verify schema deploys without errors. Check Convex dashboard shows users table with correct fields and indexes. Verify TypeScript types are generated in convex/_generated/dataModel.d.ts with correct User type.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:10.717722-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:10.717722-06:00","labels":["auth","backend","database"],"dependencies":[{"issue_id":"test-e1t2s2","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:48:10.920014-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s2","depends_on_id":"test-e1t2s1","type":"blocks","created_at":"2026-01-30T12:51:05.680729-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s3","title":"Configure environment variables and ConvexProvider","description":"Copy CONVEX_URL from Convex dashboard (shown after `npx convex dev`) to .env.local as NEXT_PUBLIC_CONVEX_URL. Update .env.example with placeholder. Create or update app/providers.tsx with ConvexProvider wrapping children, using ConvexReactClient initialized with process.env.NEXT_PUBLIC_CONVEX_URL. Wrap the app layout with this provider.\n\n**Context:** The ConvexProvider establishes the WebSocket connection to Convex cloud that enables real-time subscriptions. Using NEXT_PUBLIC_ prefix exposes the URL to client-side code where the Convex client runs.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify .env.local contains NEXT_PUBLIC_CONVEX_URL with valid Convex URL format. Check app compiles without errors after adding provider. Verify ConvexProvider is in the component tree by checking React DevTools or layout.tsx imports.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:11.179084-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:11.179084-06:00","labels":["auth","backend","database","frontend","security","setup"],"dependencies":[{"issue_id":"test-e1t2s3","depends_on_id":"test-e1t2s2","type":"blocks","created_at":"2026-01-30T12:09:16.083304-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s3","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:48:11.403059-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s3","depends_on_id":"test-e1t2s1","type":"blocks","created_at":"2026-01-30T12:51:05.913999-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s4","title":"Verify real-time connection with test query","description":"Create convex/users.ts with a simple query function `list` that returns all users using ctx.db.query('users').collect(). In a test page or existing page component, use the useQuery hook from 'convex/react' to call api.users.list. Add temporary console.log to verify the query returns (empty array initially). Insert a test document via Convex dashboard and verify it appears in the UI without page refresh.\n\n**Context:** This verification proves the entire Convex pipeline works: schema → query function → React hook → real-time updates. Finding issues now prevents debugging headaches when building actual features.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify `npx convex dev` runs without errors and shows 'Convex functions ready'. Test useQuery returns empty array initially (no runtime errors). Insert test user via Convex dashboard Data tab, verify React component re-renders with new data automatically. Delete test data after verification.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:11.619229-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:11.619229-06:00","labels":["auth","backend","database","frontend","integration","voice"],"dependencies":[{"issue_id":"test-e1t2s4","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:48:11.803208-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s4","depends_on_id":"test-e1t2s2","type":"blocks","created_at":"2026-01-30T12:51:06.107194-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s4","depends_on_id":"test-e1t2s3","type":"blocks","created_at":"2026-01-30T12:51:06.520796-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3","title":"Integrate Clerk authentication with Next.js and Convex","description":"Install Clerk SDK, configure Clerk provider, create sign-in/sign-up pages, set up middleware for protected routes, and integrate Clerk user IDs with Convex for user record creation.\n\n**Context:** Authentication is required before any user-facing features can be built. Brokers need secure login to access their team's pipeline data. Clerk integration with Convex ensures user identity flows seamlessly from auth to database.\n\n**Testing Requirements:**\n- **Unit Tests:** Clerk middleware correctly identifies protected routes, user sync function handles edge cases\n- **Integration Tests:** Full sign-up flow creates Clerk user AND Convex user record, sign-in redirects to dashboard, sign-out clears session","design":"Use @clerk/nextjs App Router integration. Configure middleware.ts to protect /dashboard routes. Create Convex webhook or useEffect to sync Clerk user to Convex users table on first login. Store CLERK_SECRET_KEY and NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY in env.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:23.114639-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:23.114639-06:00","labels":["auth","backend","clerk","frontend","security"],"dependencies":[{"issue_id":"test-e1t3","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:47:23.365133-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3","depends_on_id":"test-e1t1","type":"blocks","created_at":"2026-01-30T12:51:06.761593-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3","depends_on_id":"test-e1t2","type":"blocks","created_at":"2026-01-30T12:51:07.143061-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s1","title":"Install and configure Clerk SDK for Next.js App Router","description":"Install @clerk/nextjs package. Add CLERK_SECRET_KEY and NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY to .env.local. Wrap the root layout with ClerkProvider. Verify environment variables are loaded correctly.\n\n**Context:** Clerk provider must wrap the entire app for authentication context to be available everywhere. Environment variables must be set before any Clerk functionality works.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify ClerkProvider renders without errors, test that environment variables are defined (non-empty strings), test app boots without auth errors","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:12.116712-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:12.116712-06:00","labels":["auth","backend","frontend","setup","telephony"],"dependencies":[{"issue_id":"test-e1t3s1","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:48:12.267819-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s2","title":"Create sign-in and sign-up pages with Clerk components","description":"Create app/(auth)/sign-in/[[...sign-in]]/page.tsx using Clerk's SignIn component. Create app/(auth)/sign-up/[[...sign-up]]/page.tsx using SignUp component. Style pages to match RealHerd branding (emerald accent color). Add redirect URLs for post-auth flow to /dashboard.\n\n**Context:** Users need dedicated auth pages before accessing protected routes. Clerk's pre-built components handle OAuth, email/password, and MFA out of the box.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that SignIn and SignUp components render without errors, verify afterSignInUrl and afterSignUpUrl props are set correctly, snapshot test for consistent styling","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:12.523301-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:12.523301-06:00","labels":["auth","backend","convex","frontend","middleware","telephony"],"dependencies":[{"issue_id":"test-e1t3s2","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:48:12.695624-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s2","depends_on_id":"test-e1t3s1","type":"blocks","created_at":"2026-01-30T12:51:08.62846-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s3","title":"Configure Clerk middleware for protected routes","description":"Create middleware.ts at project root. Use clerkMiddleware() to protect /dashboard/* routes. Configure publicRoutes for sign-in, sign-up, and landing page. Test that unauthenticated users are redirected to sign-in when accessing /dashboard.\n\n**Context:** Middleware ensures server-side route protection before page render. This is critical for security - client-side checks alone are insufficient.\n\n**Testing Requirements:**\n- **Unit Tests:** Test middleware matcher patterns are correct, integration test: unauthenticated request to /dashboard returns redirect to sign-in, authenticated request to /dashboard passes through","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:12.965291-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:12.965291-06:00","labels":["auth","backend","convex","frontend","rbac","webhooks"],"dependencies":[{"issue_id":"test-e1t3s3","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:48:13.150872-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s3","depends_on_id":"test-e1t3s1","type":"blocks","created_at":"2026-01-30T12:51:08.835634-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s4","title":"Sync Clerk user to Convex users table on first login","description":"Create Convex mutation createOrGetUser that accepts Clerk user ID and email. In the dashboard layout or a dedicated component, use useUser() from Clerk and useMutation from Convex to call createOrGetUser on mount. Handle the case where user already exists (idempotent upsert). Store clerkId as indexed field in users table for lookups.\n\n**Context:** Convex needs its own user records to associate with deals, teams, and other data. Syncing on first login ensures every authenticated user has a corresponding Convex record.\n\n**Testing Requirements:**\n- **Unit Tests:** Test createOrGetUser mutation creates new user when clerkId not found, test it returns existing user when clerkId exists, test clerkId index lookup works, integration test: sign in creates Convex user record","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:13.449966-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:13.449966-06:00","labels":["auth","backend","convex","database","testing","webhook"],"dependencies":[{"issue_id":"test-e1t3s4","depends_on_id":"test-e1t3s1","type":"blocks","created_at":"2026-01-30T12:09:19.114257-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s4","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:48:13.68259-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s4","depends_on_id":"test-e1t3s2","type":"blocks","created_at":"2026-01-30T12:51:09.092238-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s4","depends_on_id":"test-e1t3s3","type":"blocks","created_at":"2026-01-30T12:51:09.375108-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4","title":"Configure shadcn/ui with RealHerd brand theme","description":"Initialize shadcn/ui, configure CSS variables for RealHerd brand colors (Warm Cream #FDF6E3 background, Terracotta #C75B39 accents, Earth Brown #5D4037 text), install core components (Button, Card, Input, Avatar), and create theme configuration.\n\n**Context:** Consistent branding builds trust with brokerage owners evaluating RealHerd. The Warm Cream + Terracotta palette conveys approachable professionalism that resonates with real estate professionals who are tired of cold, generic SaaS tools.\n\n**Testing Requirements:**\n- **Unit Tests:** CSS variables resolve correctly, component imports work without errors\n- **Integration Tests:** Render test page with all installed components, visual verification of brand colors","design":"Run `npx shadcn@latest init` with Tailwind v4 compatibility. Override CSS variables in globals.css for brand colors. Install: Button, Card, Input, Label, Avatar, DropdownMenu, Sheet (for mobile nav). Consider dark mode support for future.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":180,"created_at":"2026-01-30T12:47:23.660878-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:23.660878-06:00","labels":["design","frontend","navigation","ui"],"dependencies":[{"issue_id":"test-e1t4","depends_on_id":"test-e1t3","type":"blocks","created_at":"2026-01-30T12:09:19.955001-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:47:23.868717-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4","depends_on_id":"test-e1t1","type":"blocks","created_at":"2026-01-30T12:51:09.579167-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s1","title":"Initialize shadcn/ui with Tailwind v4 compatibility","description":"Run `npx shadcn@latest init` to set up shadcn/ui in the Next.js project. Select appropriate options: TypeScript, Tailwind CSS, CSS variables for theming, and the default style. Ensure compatibility with Tailwind v4 configuration. This creates the components.json config file and sets up the lib/utils.ts with cn() helper.\n\n**Context:** shadcn/ui provides accessible, customizable components that reduce development time while maintaining full control over styling. Proper initialization ensures all subsequent component installations work correctly.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify components.json exists with correct paths, lib/utils.ts exports cn function, tailwind.config includes shadcn content paths, globals.css has CSS variable structure","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:13.914132-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:13.914132-06:00","labels":["frontend","layout","setup"],"dependencies":[{"issue_id":"test-e1t4s1","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:48:14.142518-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s2","title":"Configure RealHerd brand colors as CSS variables","description":"Update globals.css to override shadcn default CSS variables with RealHerd brand palette. Set --background to Warm Cream (#FDF6E3), --primary to Terracotta (#C75B39), --foreground and --card-foreground to Earth Brown (#5D4037). Configure both light theme and prepare dark mode variable structure for future use. Ensure proper HSL format conversion for shadcn compatibility.\n\n**Context:** Consistent branding builds trust with brokerage owners evaluating RealHerd. The Warm Cream + Terracotta palette conveys approachable professionalism that resonates with real estate professionals who are tired of cold, generic SaaS tools.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify CSS variables are defined in :root, colors render correctly in browser dev tools, HSL values match brand hex codes when converted, dark mode variables exist (even if same as light for now)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:14.641178-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:14.641178-06:00","labels":["design","frontend","routing","ui"],"dependencies":[{"issue_id":"test-e1t4s2","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:48:14.866379-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s2","depends_on_id":"test-e1t4s1","type":"blocks","created_at":"2026-01-30T12:51:09.797458-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s3","title":"Install core shadcn/ui components","description":"Install required shadcn/ui components using CLI: `npx shadcn@latest add button card input label avatar dropdown-menu sheet`. Verify each component is added to components/ui/ directory. These provide the foundation for all UI work: Button for CTAs, Card for deal/agent displays, Input/Label for forms, Avatar for agent profiles, DropdownMenu for actions, Sheet for mobile navigation.\n\n**Context:** These seven components cover 90% of the initial UI needs - forms, cards, navigation, and user representation. Installing them now prevents context-switching during feature development.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify each component file exists in components/ui/, components export correctly, TypeScript types are available, no import errors when importing from @/components/ui/*","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:15.277943-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:15.277943-06:00","labels":["auth","components","contacts","frontend"],"dependencies":[{"issue_id":"test-e1t4s3","depends_on_id":"test-e1t4s1","type":"blocks","created_at":"2026-01-30T12:09:20.391418-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s3","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:48:15.784111-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s3","depends_on_id":"test-e1t4s2","type":"blocks","created_at":"2026-01-30T12:51:10.037286-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s4","title":"Create theme showcase page and verify brand rendering","description":"Create a temporary page at /theme-test (or add to existing page) that renders all installed components with brand styling: primary and secondary buttons, a sample card with avatar, input with label, dropdown menu, and sheet trigger. Verify Warm Cream background, Terracotta accents, and Earth Brown text render correctly. Take screenshot for design review. Start dev server and visually confirm.\n\n**Context:** Visual verification catches CSS variable issues that automated tests miss. This page also serves as a component reference during development and can be removed before production.\n\n**Testing Requirements:**\n- **Unit Tests:** Page renders without errors, all seven component types visible on page, brand colors visually match spec (Warm Cream bg, Terracotta buttons, Earth Brown text), responsive layout works on mobile viewport","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:16.050614-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:16.050614-06:00","labels":["calling","frontend","mobile","responsive","testing"],"dependencies":[{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4s1","type":"blocks","created_at":"2026-01-30T12:09:20.614282-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4s2","type":"blocks","created_at":"2026-01-30T12:09:20.83289-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:48:16.30305-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4s3","type":"blocks","created_at":"2026-01-30T12:51:10.295263-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5","title":"Build dashboard shell with navigation and layout structure","description":"Create authenticated dashboard layout with sidebar navigation, header with user avatar/sign-out, responsive mobile menu, and placeholder content areas. Include navigation items for future features (Pipeline, Agents, Calls, Settings).\n\n**Context:** The dashboard shell is what users see after login - first impression of the product. Brokers need intuitive navigation to quickly find pipeline status and agent activity. This structure enables parallel development of feature pages.\n\n**Testing Requirements:**\n- **Unit Tests:** Navigation components render correct links, responsive breakpoints work correctly\n- **Integration Tests:** Full flow: login → see dashboard with sidebar, click nav items → URL changes, sign out → redirect to login, mobile view shows hamburger menu","design":"Use Next.js App Router nested layouts. Create (dashboard) route group with layout.tsx containing Sidebar + Header + main content area. Use Sheet component for mobile nav. Add UserButton from Clerk for avatar/sign-out. Include breadcrumb support for nested pages.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:24.102187-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:24.102187-06:00","labels":["config","devops","frontend","integration","navigation","ui"],"dependencies":[{"issue_id":"test-e1t5","depends_on_id":"test-e1t2","type":"blocks","created_at":"2026-01-30T12:09:21.463571-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:47:24.253573-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5","depends_on_id":"test-e1t3","type":"blocks","created_at":"2026-01-30T12:51:10.493289-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5","depends_on_id":"test-e1t4","type":"blocks","created_at":"2026-01-30T12:51:10.822914-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s1","title":"Create dashboard route group and base layout structure","description":"Create (dashboard) route group folder in app directory. Add layout.tsx with the core structure: flex container with Sidebar component placeholder, main area with Header placeholder, and children content slot. Set up basic responsive breakpoints (sidebar hidden on mobile, visible on md+).\n\n**Context:** The route group with parentheses keeps URL clean while sharing layout. This foundation enables all dashboard pages to inherit consistent chrome.\n\n**Testing Requirements:**\n- **Unit Tests:** Test layout renders children correctly, test responsive classes are applied, test layout accepts and renders child routes","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:16.627673-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:16.627673-06:00","labels":["backend","config","documentation","frontend","telnyx","webhooks"],"dependencies":[{"issue_id":"test-e1t5s1","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:48:16.840401-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s2","title":"Build Sidebar component with navigation items","description":"Create Sidebar component with RealHerd logo at top, navigation links for Pipeline, Agents, Calls, Settings using Next.js Link. Style with active state highlighting using usePathname(). Use shadcn/ui Button variants for nav items. Include collapsible behavior prep (icons + labels that can hide).\n\n**Context:** Navigation items are placeholders for features to come. Consistent sidebar across all dashboard pages helps brokers quickly orient and find what they need.\n\n**Testing Requirements:**\n- **Unit Tests:** Test all nav items render with correct hrefs, test active state applies to current route, test logo links to /dashboard, test accessibility (aria-current on active link)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:17.059861-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:17.059861-06:00","labels":["api","audio","backend","file-storage","frontend"],"dependencies":[{"issue_id":"test-e1t5s2","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:48:17.270324-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s2","depends_on_id":"test-e1t5s1","type":"blocks","created_at":"2026-01-30T12:51:11.010677-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s3","title":"Build Header component with Clerk UserButton and mobile menu trigger","description":"Create Header component with: breadcrumb area (placeholder), Clerk UserButton for avatar/sign-out dropdown, Sheet trigger button (hamburger icon) visible only on mobile. Import UserButton from @clerk/nextjs. Style header with border-bottom, proper spacing, and sticky positioning.\n\n**Context:** Header provides user context (who am I logged in as) and quick sign-out. Mobile menu trigger is essential since sidebar is hidden on small screens. Clerk's UserButton handles all account UI automatically.\n\n**Testing Requirements:**\n- **Unit Tests:** Test UserButton renders, test mobile menu trigger only visible below md breakpoint, test header is sticky, test breadcrumb placeholder area exists","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:17.601717-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:17.601717-06:00","labels":["backend","database","dx","frontend","schema","tooling"],"dependencies":[{"issue_id":"test-e1t5s3","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:48:17.80779-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s3","depends_on_id":"test-e1t5s1","type":"blocks","created_at":"2026-01-30T12:51:11.240171-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s4","title":"Implement mobile navigation Sheet with sidebar content","description":"Use shadcn/ui Sheet component triggered by Header hamburger button. Sheet opens from left side and contains same navigation items as Sidebar. Close sheet on navigation (using router events or onClick). Extract nav items to shared constant/component to avoid duplication between Sidebar and mobile Sheet.\n\n**Context:** Mobile users (brokers checking pipeline on phone between showings) need full navigation access. Sheet pattern is standard mobile nav UX that users expect.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Sheet opens when trigger clicked, test Sheet contains all nav items matching Sidebar, test Sheet closes on nav item click, test Sheet closes on outside click","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:18.053109-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:18.053109-06:00","labels":["audio-player","documentation","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e1t5s4","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:48:18.22685-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s4","depends_on_id":"test-e1t5s2","type":"blocks","created_at":"2026-01-30T12:51:11.439954-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s4","depends_on_id":"test-e1t5s3","type":"blocks","created_at":"2026-01-30T12:51:12.134922-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s5","title":"Create dashboard index page and verify complete shell","description":"Create app/(dashboard)/page.tsx with placeholder content (welcome message, empty state cards for Pipeline/Agents sections). Wire everything together and verify: layout renders correctly, navigation works between placeholder pages, mobile menu functions, UserButton shows avatar and sign-out works, responsive behavior at all breakpoints.\n\n**Context:** Integration verification ensures the shell actually works end-to-end before teams build features on top of it. This is the first thing users see after login.\n\n**Testing Requirements:**\n- **Unit Tests:** Test dashboard page renders within layout, test navigation between routes maintains layout, test sign-out flow redirects to home, manual verification of responsive behavior at 375px/768px/1024px/1440px","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:18.591175-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:18.591175-06:00","labels":["frontend"],"dependencies":[{"issue_id":"test-e1t5s5","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:48:18.779713-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s5","depends_on_id":"test-e1t5s4","type":"blocks","created_at":"2026-01-30T12:51:12.352093-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t6","title":"Verify end-to-end foundation works together","description":"Create a simple test feature that exercises the full stack: display logged-in user's name from Convex, show real-time updates when data changes, verify all environment variables are properly configured for development.\n\n**Context:** Integration verification catches issues early before building real features. Confirms that Clerk → Convex user sync works, real-time subscriptions function, and the development environment is properly configured for the team.\n\n**Testing Requirements:**\n- **Unit Tests:** User query returns expected shape, timestamp update function works\n- **Integration Tests:** Open two browser windows → change data in one → see update in other within 1 second, all status indicators show 'connected'","design":"Add a 'Welcome, {name}' component to dashboard that queries Convex for current user. Add a 'last login' field that updates on each visit to verify writes work. Create a simple dev checklist component showing connection status for Clerk and Convex.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:47:24.523103-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:24.523103-06:00","labels":["integration","testing","verification"],"dependencies":[{"issue_id":"test-e1t6","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:47:24.65143-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t6","depends_on_id":"test-e1t5","type":"blocks","created_at":"2026-01-30T12:51:12.571815-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t6s1","title":"Create Convex user query and last login mutation","description":"Create a Convex query function to fetch the current user's profile data (name, email) and a mutation to update the 'lastLogin' timestamp. Add lastLogin field to the users table schema if not present. The query should use ctx.auth to get the authenticated user's identity and look up their profile.\n\n**Context:** These backend functions are the foundation for verifying Clerk → Convex user sync works and that mutations can write to the database. Without these, the frontend components have nothing to query.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getCurrentUser query returns user data when authenticated, returns null when not authenticated. Test updateLastLogin mutation successfully updates timestamp. Test schema validation for lastLogin field type.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:19.041119-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:19.041119-06:00","labels":["auth","backend","convex","setup","testing"],"dependencies":[{"issue_id":"test-e1t6s1","depends_on_id":"test-e1t6","type":"parent-child","created_at":"2026-01-30T12:48:19.250136-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t6s2","title":"Build Welcome component with real-time user subscription","description":"Create a React component that uses useQuery to subscribe to the getCurrentUser Convex query. Display 'Welcome, {firstName}' with the user's name. On component mount, call the updateLastLogin mutation. Display the last login timestamp below the welcome message. Use Convex's real-time subscription to automatically update if user data changes.\n\n**Context:** This component proves real-time subscriptions work - if you update the user's name in Convex dashboard, the UI should update without refresh. The lastLogin write verifies mutations work from the client.\n\n**Testing Requirements:**\n- **Unit Tests:** Test component renders loading state initially. Test component displays user name after query resolves. Test component calls updateLastLogin on mount. Test component re-renders when subscription data changes (mock useQuery updates).","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:19.697606-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:19.697606-06:00","labels":["calling","frontend","integration","react","testing"],"dependencies":[{"issue_id":"test-e1t6s2","depends_on_id":"test-e1t6","type":"parent-child","created_at":"2026-01-30T12:48:19.88889-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t6s2","depends_on_id":"test-e1t6s1","type":"blocks","created_at":"2026-01-30T12:51:12.856076-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t6s3","title":"Create ConnectionStatus dev checklist component","description":"Build a development-only component that displays connection status for: (1) Clerk auth - show if user is signed in using useAuth(), (2) Convex connection - show if ConvexReactClient is connected, (3) Environment variables - check NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY and NEXT_PUBLIC_CONVEX_URL are set. Display green/red indicators for each. Only render in development mode (process.env.NODE_ENV === 'development').\n\n**Context:** This checklist helps the team quickly diagnose configuration issues. When something doesn't work, developers can immediately see which service is misconfigured rather than debugging blindly.\n\n**Testing Requirements:**\n- **Unit Tests:** Test component renders nothing in production mode. Test component shows Clerk status correctly based on useAuth mock. Test component shows correct status for each environment variable. Test visual indicators (green/red) match connection states.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:20.240171-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:20.240171-06:00","labels":["dx","frontend","react","recording","storage","testing"],"dependencies":[{"issue_id":"test-e1t6s3","depends_on_id":"test-e1t6","type":"parent-child","created_at":"2026-01-30T12:48:20.530581-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t6s4","title":"Integrate components into dashboard and verify end-to-end","description":"Add the Welcome component and ConnectionStatus component to the main dashboard page. Run the development server and manually verify: (1) Sign in with Clerk shows Welcome message with correct name, (2) Last login timestamp updates on refresh, (3) ConnectionStatus shows all green, (4) Open Convex dashboard and modify user name - verify UI updates in real-time without refresh. Document any issues found.\n\n**Context:** This is the integration verification step that proves all pieces work together. Manual testing catches integration issues that unit tests miss - like incorrect environment variable names or auth token propagation problems.\n\n**Testing Requirements:**\n- **Unit Tests:** Test dashboard page renders Welcome component when user authenticated. Test dashboard page renders ConnectionStatus in development. Test page handles loading states gracefully. Create simple integration test that mounts dashboard with mocked providers and verifies components render.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:20.747863-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:20.747863-06:00","labels":["frontend","integration","performance","testing","validation","verification"],"dependencies":[{"issue_id":"test-e1t6s4","depends_on_id":"test-e1t6","type":"parent-child","created_at":"2026-01-30T12:48:20.932556-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t6s4","depends_on_id":"test-e1t6s2","type":"blocks","created_at":"2026-01-30T12:51:13.084996-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t6s4","depends_on_id":"test-e1t6s3","type":"blocks","created_at":"2026-01-30T12:51:13.318216-06:00","created_by":"David Habedank"}]}
{"id":"test-e2","title":"Telephony Infrastructure \u0026 Basic Calling","description":"Integrate Telnyx for outbound calling, call recording, and SMS. Establish the voice pipeline foundation that all conversation features will build upon.\n\n**Context:** RealHerd is phone-first. Before any AI conversations can happen, we need reliable telephony infrastructure - the ability to dial out, record calls, and handle SMS. This is the foundation for all voice features.\n\n**Testing Requirements:**\n- **Unit Tests:** Telnyx webhook payload parsing, call state machine transitions, SMS formatting\n- **Integration Tests:** Telnyx API call initiation, webhook event processing, Convex call record creation\n- **Type Tests:** Telnyx webhook event types, Call model validation\n- **E2E Tests:** Initiate call from dashboard, complete call, see recording in call log","acceptance_criteria":"- Can initiate outbound call to a phone number via Telnyx\n- Call recording works and audio is stored in Convex file storage\n- Call logs display in dashboard with duration, status, recording playback\n- SMS can be sent and received via Telnyx webhooks\n- Phone number provisioned and configured\n- Webhook handlers process Telnyx events (call.answered, call.hangup, etc.)","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:47:17.06429-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:17.06429-06:00","labels":["core-infrastructure","infrastructure","telephony","telnyx","voice"],"dependencies":[{"issue_id":"test-e2","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:51:13.619807-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1","title":"Telnyx SDK Setup \u0026 Phone Number Provisioning","description":"Install and configure Telnyx SDK, provision a phone number for the application, and store credentials securely in environment configuration.\n\n**Context:** RealHerd is phone-first - without a provisioned phone number and SDK setup, no calling or SMS features can function. This is the absolute foundation that everything else builds on.\n\n**Testing Requirements:**\n- **Unit Tests:** Telnyx client initialization, credential validation, phone number format helpers\n- **Integration Tests:** Verify SDK connects to Telnyx API with test credentials, confirm provisioned number is active","design":"Use @telnyx/telnyx package. Store API key and phone number in environment variables. Create a telnyx client singleton in lib/telnyx.ts. Verify number can make outbound calls and receive webhooks. Consider using a messaging profile for SMS.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":180,"created_at":"2026-01-30T12:47:25.009369-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:25.009369-06:00","labels":["backend","infrastructure","telnyx"],"dependencies":[{"issue_id":"test-e2t1","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:47:25.168284-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s1","title":"Install Telnyx SDK and create environment configuration","description":"Install @telnyx/telnyx npm package. Add TELNYX_API_KEY and TELNYX_PHONE_NUMBER to .env.example with placeholder values. Update .env.local with actual API key from Telnyx dashboard. Add these variables to environment validation schema if one exists.\n\n**Context:** The SDK and credentials are prerequisites for any Telnyx integration. Environment variables keep secrets out of code and allow different configs per environment.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that environment variables are properly typed and validated. Test that missing TELNYX_API_KEY throws a clear error at startup rather than silently failing.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:21.152633-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:21.152633-06:00","labels":["ai","ai-integration","backend","config","infrastructure","setup"],"dependencies":[{"issue_id":"test-e2t1s1","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:48:22.75826-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s2","title":"Create Telnyx client singleton in lib/telnyx.ts","description":"Create lib/telnyx.ts exporting a singleton Telnyx client instance. Initialize with API key from environment. Export typed helper functions: getTelnyxClient() that returns the initialized client. Include TypeScript types for the client instance.\n\n**Context:** A singleton prevents multiple client instantiations and provides a consistent interface for all Telnyx operations across the app. This is the central point for all telephony features.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getTelnyxClient() returns same instance on multiple calls (singleton behavior). Test client throws descriptive error if API key is missing. Mock Telnyx constructor to verify it's called with correct API key.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:23.304853-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:23.304853-06:00","labels":["backend","frontend","infrastructure","realtime","setup","telephony"],"dependencies":[{"issue_id":"test-e2t1s2","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:48:23.98484-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s2","depends_on_id":"test-e2t1s1","type":"blocks","created_at":"2026-01-30T12:51:13.891412-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s3","title":"Provision phone number and configure messaging profile","description":"Use Telnyx dashboard or API to: 1) Search and purchase a phone number with voice and SMS capabilities, 2) Create a messaging profile for SMS, 3) Configure the number's voice settings for outbound calling, 4) Store the provisioned phone number in TELNYX_PHONE_NUMBER env var. Document the provisioning steps in a comment or README section.\n\n**Context:** A provisioned number with proper messaging profile is required for both outbound calls and SMS. The messaging profile groups SMS settings and is required by Telnyx for sending messages.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that TELNYX_PHONE_NUMBER is in valid E.164 format (+1XXXXXXXXXX). Create a simple validation function and test it accepts valid numbers and rejects invalid formats.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:24.325715-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:24.325715-06:00","labels":["audio","backend","config","infrastructure","streaming"],"dependencies":[{"issue_id":"test-e2t1s3","depends_on_id":"test-e2t1s2","type":"blocks","created_at":"2026-01-30T12:09:23.483674-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s3","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:48:24.529378-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s3","depends_on_id":"test-e2t1s1","type":"blocks","created_at":"2026-01-30T12:51:14.109837-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s4","title":"Verify Telnyx integration with connection test","description":"Create a simple verification script or API route (e.g., app/api/telnyx/verify/route.ts) that: 1) Initializes the Telnyx client, 2) Fetches account balance or phone number details to verify API key works, 3) Logs success/failure. Run the verification to confirm the setup is complete.\n\n**Context:** Verification catches configuration errors early before building features on top. A working API call proves credentials, SDK installation, and network connectivity are all correct.\n\n**Testing Requirements:**\n- **Unit Tests:** Test verification endpoint returns 200 with success message when Telnyx client connects. Test it returns 500 with error details when API key is invalid (mock Telnyx to throw). Test response includes phone number confirmation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:24.811683-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:24.811683-06:00","labels":["backend","infrastructure","integration","monitoring","performance","testing"],"dependencies":[{"issue_id":"test-e2t1s4","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:48:25.21942-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s4","depends_on_id":"test-e2t1s2","type":"blocks","created_at":"2026-01-30T12:51:14.324024-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s4","depends_on_id":"test-e2t1s3","type":"blocks","created_at":"2026-01-30T12:51:14.564558-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2","title":"Telnyx Webhook Handlers for Call Events","description":"Create Next.js API routes to receive and process Telnyx webhooks for call lifecycle events (call.initiated, call.answered, call.hangup, call.recording.saved, etc.).\n\n**Context:** Telnyx communicates call status via webhooks. Without these handlers, we can't know when calls connect, end, or when recordings are ready - making the system blind to call outcomes.\n\n**Testing Requirements:**\n- **Unit Tests:** Webhook signature verification, event type parsing, payload validation for each event type\n- **Integration Tests:** End-to-end webhook delivery from Telnyx test environment, verify Convex records update correctly","design":"Create /api/webhooks/telnyx/voice route. Implement webhook signature verification for security. Parse different event types and dispatch to appropriate handlers. Store raw webhook payloads initially for debugging. Use Convex mutations to update call records.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:25.450244-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:25.450244-06:00","labels":["api","backend","convex","database","telnyx","webhooks"],"dependencies":[{"issue_id":"test-e2t2","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:47:25.631679-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2","depends_on_id":"test-e2t1","type":"blocks","created_at":"2026-01-30T12:51:14.88641-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s1","title":"Create webhook route structure with signature verification","description":"Create /api/webhooks/telnyx/voice/route.ts with POST handler. Implement Telnyx webhook signature verification using their public key to validate incoming requests. Return 401 for invalid signatures, 200 for valid requests. Set up proper error handling and logging.\n\n**Context:** Webhook security is critical - without signature verification, attackers could spoof call events and corrupt our data. This must be the first layer of defense before any processing.\n\n**Testing Requirements:**\n- **Unit Tests:** Test signature verification with valid/invalid signatures, test 401 response for tampered payloads, test 200 response for valid payloads, test handling of missing signature header","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:25.697296-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:25.697296-06:00","labels":["api","backend","database","security","types"],"dependencies":[{"issue_id":"test-e2t2s1","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:48:25.953479-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s2","title":"Define webhook event types and payload parsing","description":"Create TypeScript types for Telnyx webhook payloads: TelnyxWebhookEvent base type, CallInitiatedEvent, CallAnsweredEvent, CallHangupEvent, CallRecordingSavedEvent. Implement parseWebhookEvent() function that validates and narrows the event type. Handle unknown event types gracefully.\n\n**Context:** Strong typing prevents runtime errors and makes the codebase self-documenting. Each event type has different payload structures that we need to handle correctly.\n\n**Testing Requirements:**\n- **Unit Tests:** Test parsing each event type with sample payloads from Telnyx docs, test unknown event type returns generic type, test malformed JSON throws appropriate error, test required fields validation","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:26.209579-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:26.209579-06:00","labels":["api","backend","crm","state-management","types"],"dependencies":[{"issue_id":"test-e2t2s2","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:48:26.763706-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s2","depends_on_id":"test-e2t2s1","type":"blocks","created_at":"2026-01-30T12:51:15.31327-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s3","title":"Implement event dispatcher and Convex mutations","description":"Create event handler dispatcher that routes parsed events to appropriate handlers. Implement Convex mutations: updateCallStatus (for initiated/answered/hangup), saveCallRecording (for recording.saved). Store raw webhook payload in a webhookLogs table for debugging. Each handler updates the calls table with relevant data (status, duration, recording URL, timestamps).\n\n**Context:** The dispatcher pattern keeps code organized as we add more event types. Storing raw payloads is invaluable for debugging production issues - we can replay events if needed.\n\n**Testing Requirements:**\n- **Unit Tests:** Test dispatcher routes to correct handler for each event type, test updateCallStatus mutation updates call record correctly, test saveCallRecording stores URL and marks call complete, test webhookLogs insertion with full payload, test handling of call_control_id not found","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:27.165438-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:27.165438-06:00","labels":["ai-prompts","backend","convex","data-processing","storage"],"dependencies":[{"issue_id":"test-e2t2s3","depends_on_id":"test-e2t2s1","type":"blocks","created_at":"2026-01-30T11:10:43.375921-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s3","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:48:27.390811-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s3","depends_on_id":"test-e2t2s2","type":"blocks","created_at":"2026-01-30T12:51:15.530487-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s4","title":"Add idempotency and end-to-end verification","description":"Add idempotency check using webhook event ID to prevent duplicate processing. Implement retry-safe logic (webhook handlers should be idempotent). Test full flow: simulate Telnyx webhook → verify signature → parse event → update Convex → confirm database state. Document webhook URL for Telnyx dashboard configuration.\n\n**Context:** Telnyx may retry webhooks on failures. Without idempotency, we'd process events multiple times, corrupting call statistics and potentially triggering duplicate actions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test duplicate webhook with same event ID is ignored, test idempotency key stored after processing, test full integration flow with mock Telnyx payloads, test concurrent duplicate webhooks only process once","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:27.641653-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:27.641653-06:00","labels":["api","backend","integration","monitoring","real-estate","reliability"],"dependencies":[{"issue_id":"test-e2t2s4","depends_on_id":"test-e2t2s1","type":"blocks","created_at":"2026-01-30T12:09:24.322765-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s4","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:48:27.825233-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s4","depends_on_id":"test-e2t2s3","type":"blocks","created_at":"2026-01-30T12:51:15.887907-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s5","title":"Verify complete calls schema with manual test and dev server","description":"Run npx convex dev to deploy schema and functions. Use Convex dashboard to manually create a test call, update its status through the lifecycle, attach a mock recording, and query it back via getCallLog and getCallsByContact. Verify all indexes are created correctly.\n\n**Context:** Manual verification ensures the entire call data flow works before integrating with Twilio. Catching schema or mutation issues here is much easier than debugging through the full Twilio integration.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:29.247609-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:33.877847-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e2t2s5","depends_on_id":"test-e2t2s2","type":"blocks","created_at":"2026-01-30T12:09:24.539513-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s5","depends_on_id":"test-e2t2s3","type":"blocks","created_at":"2026-01-30T12:09:24.717867-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s5","depends_on_id":"test-e2t2s4","type":"blocks","created_at":"2026-01-30T12:09:24.947484-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:33.877847-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e2t3","title":"Outbound Call Initiation \u0026 Call Log Schema","description":"Create Convex schema for call logs and implement outbound call initiation via Telnyx API. Track call metadata including duration, status, timestamps, and recording references.\n\n**Context:** Users need to initiate calls to leads and have a complete record of all call activity. This data feeds into the dashboard and eventually AI analysis features.\n\n**Testing Requirements:**\n- **Unit Tests:** Call log schema validation, status transitions, duration calculation, Telnyx API request formatting\n- **Integration Tests:** Initiate real test call via Telnyx, verify call log created and updated through webhook lifecycle","design":"Convex schema: callLogs table with fields for telnyxCallControlId, fromNumber, toNumber, status (enum: initiated/ringing/answered/completed/failed), startTime, endTime, duration, recordingUrl, contactId (reference). Create Convex action that calls Telnyx API to initiate call with call_control. Include answering_machine_detection config.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:25.920569-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:25.920569-06:00","labels":["api","backend","convex","database","telnyx"],"dependencies":[{"issue_id":"test-e2t3","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:47:26.090182-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3","depends_on_id":"test-e2t1","type":"blocks","created_at":"2026-01-30T12:51:16.183958-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3","depends_on_id":"test-e2t2","type":"blocks","created_at":"2026-01-30T12:51:16.565405-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s1","title":"Create Convex callLogs schema with all required fields","description":"Define the callLogs table in Convex schema with fields: telnyxCallControlId (string), fromNumber (string), toNumber (string), status (union: 'initiated'|'ringing'|'answered'|'completed'|'failed'), startTime (number), endTime (optional number), duration (optional number), recordingUrl (optional string), contactId (reference to contacts table). Add appropriate indexes for querying by contactId and status.\n\n**Context:** This schema is the foundation for all call tracking. Every outbound call will create a record here, and this data will be used for dashboard metrics, call history views, and eventually AI analysis of call patterns.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation accepts valid call log data, test status enum only accepts valid values, test optional fields can be null/undefined, test contactId reference validates against contacts table","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:28.069589-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:28.069589-06:00","labels":["audio","backend","database","scheduling","types"],"dependencies":[{"issue_id":"test-e2t3s1","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:48:28.241642-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s2","title":"Create TypeScript types for call log operations","description":"Define TypeScript interfaces for: CallLogInsert (creating new logs), CallLogUpdate (updating status/duration), CallStatus enum, TelnyxCallInitiateRequest (API payload), TelnyxCallInitiateResponse (API response). Export types from a shared location for use in actions and queries.\n\n**Context:** Strong typing prevents runtime errors when working with call data and ensures the Telnyx API integration is correctly typed. These types will be used across actions, queries, and eventually the frontend.\n\n**Testing Requirements:**\n- **Unit Tests:** Test type exports are accessible, test CallStatus enum contains all 5 states, verify types align with Convex schema definition","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:48:28.567271-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:28.567271-06:00","labels":["ai","api","backend","state-machine","telnyx","types"],"dependencies":[{"issue_id":"test-e2t3s2","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:48:28.752298-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s2","depends_on_id":"test-e2t3s1","type":"blocks","created_at":"2026-01-30T12:51:17.009567-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s3","title":"Implement Telnyx outbound call initiation action","description":"Create a Convex action 'initiateOutboundCall' that: 1) Accepts toNumber and contactId, 2) Retrieves Telnyx API key and from_number from environment, 3) Calls Telnyx Call Control API POST /calls with connection_id, to, from, webhook_event_url, and answering_machine_detection config (detect_beep: true), 4) Creates callLogs record with status 'initiated' and telnyxCallControlId from response, 5) Returns the call_control_id for tracking. Handle API errors gracefully with appropriate error messages.\n\n**Context:** This is the core action that enables agents to dial leads. The answering_machine_detection config is critical for future AI features that need to know if they're talking to a person or voicemail. The webhook URL will be handled by the webhook infrastructure in task 2.2.\n\n**Testing Requirements:**\n- **Unit Tests:** Test action validates required parameters (toNumber, contactId), test Telnyx API called with correct payload structure including AMD config, test callLog record created on success with correct initial status, test error handling returns meaningful error for API failures (401/429/500), mock Telnyx API responses for success and failure cases","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:29.704147-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:29.704147-06:00","labels":["api-integration","backend","database","integration","sms","telnyx","webhooks"],"dependencies":[{"issue_id":"test-e2t3s3","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:48:29.985351-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s3","depends_on_id":"test-e2t3s1","type":"blocks","created_at":"2026-01-30T12:51:17.23738-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s3","depends_on_id":"test-e2t3s2","type":"blocks","created_at":"2026-01-30T12:51:17.463-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s4","title":"Create call log query functions and verify end-to-end","description":"Implement Convex queries: 'getCallLogsByContact' (returns call history for a contact), 'getCallLogByTelnyxId' (lookup by call_control_id for webhook updates), 'getRecentCalls' (paginated list of recent calls). Then verify the complete flow: create a test contact, call initiateOutboundCall action, verify callLog record exists with correct data, verify queries return expected results.\n\n**Context:** These queries support the dashboard and contact detail views. The getCallLogByTelnyxId query is essential for webhook handlers to update call status as events arrive from Telnyx.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getCallLogsByContact returns calls in reverse chronological order, test getCallLogByTelnyxId returns null for non-existent ID, test getRecentCalls pagination works correctly, integration test: create contact → initiate call → verify log created → query by contact returns log","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:30.360948-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:30.360948-06:00","labels":["backend","configuration","database","e2e","frontend","testing","verification"],"dependencies":[{"issue_id":"test-e2t3s4","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:48:30.646599-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s4","depends_on_id":"test-e2t3s3","type":"blocks","created_at":"2026-01-30T12:51:17.669702-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4","title":"Call Recording Storage \u0026 Playback","description":"Implement call recording capture via Telnyx, download and store recordings in Convex file storage, and create API for secure playback access.\n\n**Context:** Call recordings are essential for AI transcription, compliance, and agent coaching. Recordings must be stored reliably and accessible for playback in the dashboard.\n\n**Testing Requirements:**\n- **Unit Tests:** Recording download logic, file upload to Convex storage, signed URL generation, audio format handling\n- **Integration Tests:** Full recording flow - initiate recorded call, verify webhook received, confirm file in Convex storage, playback URL works","design":"Enable recording in Telnyx call initiation with record='record-from-answer'. On recording.saved webhook, download audio from Telnyx URL and upload to Convex file storage. Store Convex storage ID in call log. Create authenticated endpoint for playback that returns signed URL. Consider retention policy for storage costs.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:26.353657-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:26.353657-06:00","labels":["backend","convex","storage","telnyx"],"dependencies":[{"issue_id":"test-e2t4","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:47:26.572916-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4","depends_on_id":"test-e2t3","type":"blocks","created_at":"2026-01-30T12:51:17.886555-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s1","title":"Enable call recording in Telnyx dial action","description":"Update the outbound call initiation code to include record='record-from-answer' parameter when creating calls via Telnyx API. This enables automatic recording that starts when the call is answered.\n\n**Context:** Recording must be enabled at call creation time - this is a prerequisite for receiving recording.saved webhooks. Without this flag, no recordings will be generated.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that dial command includes record parameter, test record value is 'record-from-answer', mock Telnyx API call and verify payload structure","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:30.907455-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:30.907455-06:00","labels":["backend","configuration","conversation-design","frontend","product","telephony","telnyx","ui"],"dependencies":[{"issue_id":"test-e2t4s1","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:48:31.274391-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s2","title":"Handle recording.saved webhook and download audio","description":"Add handler for Telnyx 'recording.saved' webhook event. Extract recording URL from webhook payload, download the audio file using authenticated request to Telnyx, and store temporarily. Include call_control_id to link recording to call log.\n\n**Context:** Telnyx hosts recordings temporarily - we must download and store them ourselves for long-term access. The webhook provides the download URL and metadata needed to associate with the correct call.\n\n**Testing Requirements:**\n- **Unit Tests:** Test webhook payload parsing for recording URL and call_control_id, test download function with mocked Telnyx response, test error handling for 404/401 from Telnyx, test retry logic for failed downloads","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:31.673504-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:31.673504-06:00","labels":["backend","conversation-engine","convex","frontend","telephony","webhook","webrtc"],"dependencies":[{"issue_id":"test-e2t4s2","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:48:31.87322-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s2","depends_on_id":"test-e2t4s1","type":"blocks","created_at":"2026-01-30T12:51:18.085355-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s3","title":"Upload recordings to Convex file storage and update call logs","description":"After downloading recording, upload audio file to Convex storage using storage.store(). Update the call log record with the Convex storage ID. Create schema field for recording_storage_id on call logs table if not present.\n\n**Context:** Convex file storage provides durable, managed storage with built-in URL generation. Linking storage ID to call log enables retrieval for playback and transcription.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Convex storage.store() call with audio blob, test call log update mutation with storage ID, test error handling when storage fails, test idempotency if webhook received twice","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:32.139542-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:32.139542-06:00","labels":["backend","convex","crm-integration","database","frontend","real-time","storage"],"dependencies":[{"issue_id":"test-e2t4s3","depends_on_id":"test-e2t4s1","type":"blocks","created_at":"2026-01-30T11:10:45.838586-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s3","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:48:32.380691-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s3","depends_on_id":"test-e2t4s2","type":"blocks","created_at":"2026-01-30T12:51:18.356601-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s4","title":"Create authenticated playback endpoint with signed URLs","description":"Implement Convex query/action that takes call log ID, verifies user has access to that call (same brokerage), retrieves storage ID, and returns a time-limited signed URL for audio playback. Include proper authorization checks.\n\n**Context:** Recordings contain sensitive conversations - playback must be authenticated and authorized. Signed URLs with expiration prevent unauthorized sharing while enabling browser audio playback.\n\n**Testing Requirements:**\n- **Unit Tests:** Test authorization check rejects users from different brokerage, test returns valid URL for authorized user, test 404 when call has no recording, test URL generation from storage ID, test expiration is set correctly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:32.588036-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:32.588036-06:00","labels":["api","backend","convex","frontend","integration","security","testing"],"dependencies":[{"issue_id":"test-e2t4s4","depends_on_id":"test-e2t4s2","type":"blocks","created_at":"2026-01-30T11:10:46.167821-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s4","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:48:32.840768-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s4","depends_on_id":"test-e2t4s3","type":"blocks","created_at":"2026-01-30T12:51:18.67051-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5","title":"SMS Send/Receive via Telnyx","description":"Implement SMS sending capability and webhook handlers for incoming SMS. Create Convex schema for message logs with conversation threading.\n\n**Context:** SMS is critical for lead nurturing and follow-ups. Many leads prefer text over calls. This enables both manual and future AI-driven SMS conversations.\n\n**Testing Requirements:**\n- **Unit Tests:** SMS payload formatting, phone number normalization, conversation threading logic, delivery status parsing\n- **Integration Tests:** Send SMS via Telnyx, receive webhook for incoming SMS, verify message stored correctly in Convex","design":"Create /api/webhooks/telnyx/messaging route for incoming SMS. Convex schema: smsMessages table with from, to, body, direction (inbound/outbound), timestamp, contactId, conversationId. Use Telnyx messaging API for outbound. Group messages by phone number for conversation view. Handle delivery receipts.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:26.810079-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:26.810079-06:00","labels":["api","backend","sms","telnyx","webhooks"],"dependencies":[{"issue_id":"test-e2t5","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:47:26.982009-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5","depends_on_id":"test-e2t1","type":"blocks","created_at":"2026-01-30T12:51:18.936729-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s1","title":"Create Convex schema for SMS messages and conversations","description":"Define smsMessages table in Convex with fields: from (string), to (string), body (string), direction (literal 'inbound' | 'outbound'), timestamp (number), contactId (optional Id\u003ccontacts\u003e), conversationId (string - generated from sorted phone numbers), telnyxMessageId (string), deliveryStatus (literal 'pending' | 'sent' | 'delivered' | 'failed'). Add index on conversationId for threading and on contactId for contact lookup. Add index on timestamp for chronological ordering.\n\n**Context:** Schema must support conversation threading by phone number pairs and link to contacts when available. The conversationId pattern (sorted phone numbers) enables grouping all messages between two numbers regardless of direction.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation with valid/invalid message objects, test conversationId generation helper function returns consistent ID regardless of which number is 'from' vs 'to', verify indexes are properly defined","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:33.408566-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:33.408566-06:00","labels":["audio","backend","database","integration"],"dependencies":[{"issue_id":"test-e2t5s1","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:48:33.781715-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s2","title":"Implement Telnyx outbound SMS sending function","description":"Create Convex action sendSms that accepts to, from, body parameters. Use Telnyx Node SDK to send SMS via messaging API. Store message in smsMessages table with direction='outbound', status='pending'. Return telnyxMessageId. Create helper function generateConversationId(phone1, phone2) that sorts phones alphabetically and joins them. Handle Telnyx API errors (invalid number, rate limits) with appropriate error responses.\n\n**Context:** Outbound SMS is needed for lead follow-ups and agent-to-lead communication. Storing with pending status allows tracking delivery via webhooks. The consistent conversationId ensures messages thread correctly.\n\n**Testing Requirements:**\n- **Unit Tests:** Test generateConversationId returns same ID regardless of argument order, test sendSms with mocked Telnyx client verifies correct API call params, test error handling for Telnyx 400/429 errors, test message is stored in database with correct fields","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:36.078854-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:36.078854-06:00","labels":["api-integration","audio","backend","database","integration"],"dependencies":[{"issue_id":"test-e2t5s2","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:48:36.9748-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s2","depends_on_id":"test-e2t5s1","type":"blocks","created_at":"2026-01-30T12:51:19.187644-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s3","title":"Create Telnyx messaging webhook handler","description":"Create Next.js API route at /api/webhooks/telnyx/messaging. Handle two event types: (1) message.received - store inbound SMS with direction='inbound', look up contactId by phone number if exists; (2) message.finalized - update existing message's deliveryStatus based on Telnyx status (delivered/failed). Validate webhook signature using Telnyx webhook secret from env. Return 200 OK for valid webhooks, 401 for invalid signature.\n\n**Context:** Webhook handler is essential for receiving customer replies and knowing if outbound messages were delivered. Contact lookup enables linking messages to CRM records for conversation history.\n\n**Testing Requirements:**\n- **Unit Tests:** Test webhook signature validation accepts valid signatures and rejects invalid, test message.received creates inbound message with correct conversationId, test message.finalized updates existing message status, test contact lookup by phone number, test 200 response for valid webhooks","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:37.351777-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:37.351777-06:00","labels":["ai","api","audio","backend","integration","webhooks"],"dependencies":[{"issue_id":"test-e2t5s3","depends_on_id":"test-e2t5s2","type":"blocks","created_at":"2026-01-30T11:10:47.077648-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s3","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:48:37.643-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s3","depends_on_id":"test-e2t5s1","type":"blocks","created_at":"2026-01-30T12:51:19.400598-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s4","title":"Create SMS queries and verify end-to-end flow","description":"Create Convex queries: getConversation(conversationId) returns messages sorted by timestamp, getConversationsForContact(contactId) returns unique conversations with latest message preview, getRecentConversations(limit) returns conversations sorted by most recent activity. Test end-to-end: send test SMS via sendSms action, verify message stored, simulate inbound webhook, verify threading works. Document Telnyx webhook URL configuration needed in Telnyx portal.\n\n**Context:** Queries enable the conversation view UI. Testing end-to-end ensures the entire SMS flow works before building UI. Documentation ensures webhook can be configured in production.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getConversation returns messages in chronological order, test getConversationsForContact filters correctly, test getRecentConversations sorts by latest message timestamp, integration test: send outbound → verify stored → simulate inbound reply → verify same conversationId → verify chronological ordering","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:37.998577-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:37.998577-06:00","labels":["backend","conversation-flow","integration","testing","webhooks"],"dependencies":[{"issue_id":"test-e2t5s4","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:48:38.760319-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s4","depends_on_id":"test-e2t5s2","type":"blocks","created_at":"2026-01-30T12:51:19.600391-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s4","depends_on_id":"test-e2t5s3","type":"blocks","created_at":"2026-01-30T12:51:19.800297-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6","title":"Call Logs Dashboard UI with Recording Playback","description":"Build dashboard page displaying call history with status, duration, timestamps, and inline audio player for recordings. Include click-to-call functionality.\n\n**Context:** Users need visibility into all call activity. Brokerage owners and team leads specifically need to see call volume and outcomes to ensure agents are actually making calls.\n\n**Testing Requirements:**\n- **Unit Tests:** Duration formatting, status badge rendering, date filtering logic, audio player controls\n- **Integration Tests:** Real-time updates when new call created, recording playback works, click-to-call initiates actual call","design":"Create /dashboard/calls page. Use Convex real-time queries for live updates. Table columns: contact name, phone, direction, status, duration, timestamp, recording. Audio player component using HTML5 audio with Convex signed URLs. Click-to-call button triggers outbound call action. Filter by date range, status, agent.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:27.152031-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:27.152031-06:00","labels":["dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e2t6","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:47:27.312897-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6","depends_on_id":"test-e2t3","type":"blocks","created_at":"2026-01-30T12:51:20.010566-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6","depends_on_id":"test-e2t4","type":"blocks","created_at":"2026-01-30T12:51:20.214988-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s1","title":"Create Call Logs Data Schema and Real-time Query","description":"Define Convex query for fetching call logs with pagination and filtering. Query should return: contact name, phone number, direction (inbound/outbound), status (completed/missed/voicemail), duration, timestamp, recording URL. Include filters for date range, status, and agent. Use Convex's real-time subscription capabilities for live updates.\n\n**Context:** Foundation for the dashboard - need efficient queries that can handle filtering/sorting while maintaining real-time updates. Brokerage owners viewing 100+ agents' calls need performant pagination.\n\n**Testing Requirements:**\n- **Unit Tests:** Test query returns correct fields, test date range filter excludes out-of-range calls, test status filter works (completed/missed/voicemail), test agent filter returns only that agent's calls, test pagination returns correct page size and total count","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:39.115916-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:39.115916-06:00","labels":["backend","convex","data","frontend","infrastructure","integration","testing"],"dependencies":[{"issue_id":"test-e2t6s1","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:48:39.397338-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s2","title":"Build Call Logs Table Component with Filters","description":"Create /dashboard/calls page with data table showing call history. Columns: contact name (linked to contact), phone, direction icon, status badge, duration (formatted mm:ss), timestamp (relative + absolute on hover). Add filter bar with date range picker, status dropdown, agent selector. Use shadcn/ui Table, Select, and DateRangePicker components. Wire to Convex real-time query from 2.6.1.\n\n**Context:** Team leads need quick scanning of call activity. Visual status badges and duration help identify problematic patterns (lots of short calls = bad conversations, many missed = followup needed).\n\n**Testing Requirements:**\n- **Unit Tests:** Test table renders all columns correctly, test duration formats as mm:ss, test relative timestamp displays correctly, test filters update query params, test empty state shows appropriate message, test loading state displays skeleton","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:39.80894-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:39.80894-06:00","labels":["admin","frontend","monitoring","performance","react","testing","ui"],"dependencies":[{"issue_id":"test-e2t6s2","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:48:40.01247-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6s2","depends_on_id":"test-e2t6s1","type":"blocks","created_at":"2026-01-30T12:51:20.418618-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s3","title":"Implement Audio Player Component for Recording Playback","description":"Create inline audio player component using HTML5 audio element. Generate Convex signed URLs for secure recording access. Player features: play/pause, progress bar, duration display, playback speed control (0.5x, 1x, 1.5x, 2x). Player should be collapsible/expandable within table row. Handle missing recordings gracefully with 'No recording' indicator.\n\n**Context:** Call recordings are essential for coaching and compliance. Playback speed control helps team leads review calls faster during coaching sessions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test audio player renders with correct controls, test play/pause toggles state, test progress bar updates during playback, test playback speed changes audio rate, test signed URL generation returns valid URL, test graceful handling when recording URL is null","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:40.373972-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:40.373972-06:00","labels":["ai","conversation","demo","frontend","optimization","performance","react","ui"],"dependencies":[{"issue_id":"test-e2t6s3","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:48:40.821661-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6s3","depends_on_id":"test-e2t6s2","type":"blocks","created_at":"2026-01-30T12:51:20.630083-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s4","title":"Add Click-to-Call Button and Integration Test Dashboard","description":"Add click-to-call button to each row that triggers outbound call action (connect to existing Twilio outbound call mutation from task 2.3). Button shows calling state during connection. Run full integration test: verify page loads, filters work, recordings play, click-to-call initiates call. Test with real data in dev environment.\n\n**Context:** Click-to-call from dashboard enables rapid followup workflows - team lead sees missed call, clicks to call back immediately without context switching.\n\n**Testing Requirements:**\n- **Unit Tests:** Test click-to-call button triggers mutation with correct phone number, test button shows loading state during call initiation, test error handling shows toast on failure, test button disabled when call already in progress","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:41.309962-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:41.309962-06:00","labels":["admin","frontend","integration","monitoring","testing","validation","verification"],"dependencies":[{"issue_id":"test-e2t6s4","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:48:41.621384-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6s4","depends_on_id":"test-e2t6s3","type":"blocks","created_at":"2026-01-30T12:51:21.021594-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7","title":"Telephony Integration Verification \u0026 Error Handling","description":"Add comprehensive error handling for all Telnyx operations, implement retry logic for transient failures, and create end-to-end test suite verifying complete call and SMS flows.\n\n**Context:** Telephony is mission-critical infrastructure. Failures must be handled gracefully with clear error messages. This task ensures the system is production-ready and debuggable.\n\n**Testing Requirements:**\n- **Unit Tests:** Error classification, retry logic with backoff calculation, error message formatting\n- **Integration Tests:** Simulate failure scenarios, verify graceful degradation, confirm error logs contain actionable information","design":"Add try/catch with specific Telnyx error types. Implement exponential backoff for API calls. Create error logging with enough context for debugging. Add health check endpoint that verifies Telnyx connectivity. Test scenarios: network timeout, invalid number, Telnyx rate limit, webhook replay, recording download failure.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:27.51505-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:27.51505-06:00","labels":["backend","integration","reliability","testing","verification"],"dependencies":[{"issue_id":"test-e2t7","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:47:27.6841-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7","depends_on_id":"test-e2t3","type":"blocks","created_at":"2026-01-30T12:51:21.374828-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7","depends_on_id":"test-e2t4","type":"blocks","created_at":"2026-01-30T12:51:21.695514-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7","depends_on_id":"test-e2t5","type":"blocks","created_at":"2026-01-30T12:51:22.021513-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7","depends_on_id":"test-e2t6","type":"blocks","created_at":"2026-01-30T12:51:22.226843-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s1","title":"Create Telnyx-specific error types and error handling utilities","description":"Define custom error classes for different Telnyx failure modes (TelnyxAuthError, TelnyxRateLimitError, TelnyxInvalidNumberError, TelnyxNetworkError, TelnyxRecordingError). Create error handling utility that maps Telnyx API error responses to these typed errors. Include error context (call_control_id, phone number, operation type) for debugging.\n\n**Context:** Typed errors enable proper error handling throughout the codebase and provide clear debugging context when issues occur in production. This is the foundation for all error handling in the telephony system.\n\n**Testing Requirements:**\n- **Unit Tests:** Test error class instantiation with context data, test mapping from raw Telnyx error responses (401, 429, 400, 500) to typed errors, test error serialization for logging","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:42.030789-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:42.030789-06:00","labels":["backend","documentation","error-handling","telephony","testing"],"dependencies":[{"issue_id":"test-e2t7s1","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:48:42.307375-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s2","title":"Implement exponential backoff retry logic for Telnyx API calls","description":"Create a retry wrapper utility with configurable max retries (default 3), initial delay (100ms), max delay (5s), and exponential backoff factor (2x). Apply retry logic to: outbound call initiation, recording download, SMS send. Do NOT retry: authentication failures (401), invalid number errors (400), or webhook processing. Add jitter to prevent thundering herd.\n\n**Context:** Transient failures (network timeouts, rate limits) are common in telephony APIs. Retry logic makes the system resilient without requiring manual intervention for temporary issues.\n\n**Testing Requirements:**\n- **Unit Tests:** Test retry triggers on 429/500/network errors, test no retry on 401/400, test exponential delays (100ms-\u003e200ms-\u003e400ms), test max retry limit respected, test jitter randomness within bounds","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:42.629637-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:42.629637-06:00","labels":["backend","resilience","telephony","testing"],"dependencies":[{"issue_id":"test-e2t7s2","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:48:42.927719-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7s2","depends_on_id":"test-e2t7s1","type":"blocks","created_at":"2026-01-30T12:51:22.440425-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s3","title":"Add error handling to all Telnyx service methods and create health check endpoint","description":"Wrap all TelnyxService methods (initiateCall, sendSms, downloadRecording, webhook handlers) with try/catch using typed errors. Log errors with full context (operation, phone numbers, call_control_id, timestamp, retry attempt). Create GET /api/health/telnyx endpoint that verifies: API key valid, can list phone numbers, webhook URL reachable. Return status object with each check result.\n\n**Context:** Production systems need observability. Proper error logging enables debugging, and health checks enable monitoring dashboards and deployment verification.\n\n**Testing Requirements:**\n- **Unit Tests:** Test each service method catches and rethrows typed errors, test error logs contain required context fields, test health endpoint returns 200 with all checks passing, test health endpoint returns 503 with degraded status when Telnyx unreachable","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:43.276237-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:43.276237-06:00","labels":["backend","observability","security","telephony","testing"],"dependencies":[{"issue_id":"test-e2t7s3","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:48:43.800458-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7s3","depends_on_id":"test-e2t7s1","type":"blocks","created_at":"2026-01-30T12:51:22.626453-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7s3","depends_on_id":"test-e2t7s2","type":"blocks","created_at":"2026-01-30T12:51:22.889272-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s4","title":"Create end-to-end test suite for complete call and SMS flows","description":"Write integration tests covering: (1) Complete outbound call flow - initiate, answer webhook, hangup webhook, recording available webhook, recording download; (2) Inbound call flow - incoming webhook, answer, hangup; (3) SMS send and receive; (4) Error scenarios - invalid number rejection, simulated rate limit with retry success, webhook signature validation failure, duplicate webhook rejection (idempotency), recording download timeout with retry. Use Telnyx test credentials or mocked responses.\n\n**Context:** End-to-end tests verify the complete system works together, not just individual units. These tests catch integration issues and serve as documentation for expected behavior.\n\n**Testing Requirements:**\n- **Unit Tests:** Test complete call lifecycle with mocked webhooks fires correct events, test SMS round-trip, test invalid number returns appropriate error type, test rate limit triggers retry and succeeds, test duplicate webhook_id is ignored, test recording download retries on timeout then succeeds","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:44.117309-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:44.117309-06:00","labels":["backend","documentation","integration","telephony","testing"],"dependencies":[{"issue_id":"test-e2t7s4","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:48:44.378342-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7s4","depends_on_id":"test-e2t7s3","type":"blocks","created_at":"2026-01-30T12:51:23.108727-06:00","created_by":"David Habedank"}]}
{"id":"test-e3","title":"Voice AI Conversation Engine","description":"Integrate LFM 2.5-Audio for real-time bidirectional voice conversations. Build the conversation orchestration layer that handles natural debrief dialogues with agents.\n\n**Context:** The core value of RealHerd is natural voice conversations that feel like talking to a colleague. LFM 2.5-Audio enables combined STT+TTS with reasoning in a single model, creating fluid conversations with low latency.\n\n**Testing Requirements:**\n- **Unit Tests:** Transcript segment parsing, conversation state machine, prompt template rendering\n- **Integration Tests:** LFM audio streaming pipeline, transcript storage in Convex, audio chunk handling\n- **Type Tests:** TranscriptSegment types, conversation flow state types\n- **E2E Tests:** Complete 2-minute debrief conversation, verify transcript accuracy and storage","acceptance_criteria":"- LFM 2.5-Audio integrated with bidirectional audio streaming\n- Debrief conversation flow works naturally (greeting, open questions, follow-ups, wrap-up)\n- Real-time transcript generation during call\n- Transcripts stored and displayed in dashboard\n- Conversation handles interruptions gracefully\n- Voice feels warm and professional per brand guidelines\n- Latency under 500ms for natural conversation flow","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:47:17.359004-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:17.359004-06:00","labels":["conversation","core-feature","lfm","voice-ai"],"dependencies":[{"issue_id":"test-e3","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:30.806278-06:00","created_by":"David Habedank"},{"issue_id":"test-e3","depends_on_id":"test-e2","type":"blocks","created_at":"2026-01-30T12:51:23.331281-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1","title":"Set up LFM 2.5-Audio SDK and bidirectional audio streaming infrastructure","description":"Install and configure the Liquid Foundation Model 2.5-Audio-1.5B SDK. Set up WebSocket connections for real-time bidirectional audio streaming between the client (agent's phone/browser) and the LFM model. Implement audio encoding/decoding pipeline for optimal latency.\n\n**Context:** RealHerd's core value is natural voice conversations that feel like talking to a colleague. This foundational infrastructure enables the \u003c500ms latency required for conversations that don't feel robotic. LFM 2.5-Audio's combined STT+TTS+reasoning means we can achieve fluid dialogue without the latency of chaining separate models.\n\n**Testing Requirements:**\n- **Unit Tests:** Audio encoder/decoder functions, WebSocket message handlers, chunk processing logic, connection state management\n- **Integration Tests:** End-to-end audio round-trip latency measurement, connection stability under network jitter, audio quality verification with sample recordings","design":"Use WebSocket for persistent bidirectional connection. Implement audio chunking strategy (likely 20-40ms chunks) for streaming. Handle audio format conversion if needed (browser WebAudio API to model input format). Consider opus/PCM codec selection for latency vs quality tradeoff. Set up connection pooling for concurrent calls.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:47:27.923803-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:27.923803-06:00","labels":["ai","audio","backend","infrastructure"],"dependencies":[{"issue_id":"test-e3t1","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:47:28.180546-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s1","title":"Install LFM 2.5-Audio SDK and verify model initialization","description":"Install the Liquid Foundation Model 2.5-Audio-1.5B SDK via pip/npm (depending on available SDK). Configure model initialization with appropriate settings for real-time inference. Verify the model loads correctly and can process a simple audio sample. Document any GPU/memory requirements discovered during setup.\n\n**Context:** The LFM model is the core of RealHerd's voice capability. Getting it running correctly is the foundation for all audio processing. Early verification catches compatibility issues before building infrastructure on top.\n\n**Testing Requirements:**\n- **Unit Tests:** Test model initialization succeeds without errors, test model responds to health check, test model can process a 1-second audio sample and return output, test graceful failure when model unavailable","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:45.021498-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:45.021498-06:00","labels":["ai","backend","infrastructure","integration","ml-integration"],"dependencies":[{"issue_id":"test-e3t1s1","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:48:45.879732-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s2","title":"Implement WebSocket server with bidirectional audio streaming protocol","description":"Create WebSocket server endpoint (using FastAPI WebSockets or similar) that handles persistent connections for audio streaming. Define message protocol: binary frames for audio chunks, JSON frames for control messages (start/stop/status). Implement connection lifecycle (connect, authenticate, stream, disconnect). Handle multiple concurrent connections with connection pooling.\n\n**Context:** WebSocket provides the persistent bidirectional channel needed for real-time audio. The protocol design here determines the latency floor - poorly designed chunking or excessive JSON overhead will add latency that compounds throughout the conversation.\n\n**Testing Requirements:**\n- **Unit Tests:** Test WebSocket connection establishment and handshake, test binary frame reception and parsing, test JSON control message handling (start/stop/ping), test connection cleanup on client disconnect, test concurrent connection handling (simulate 5 simultaneous connections), test connection timeout and reconnection logic","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:46.386049-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:46.386049-06:00","labels":["backend","data-modeling","infrastructure","integration","websocket"],"dependencies":[{"issue_id":"test-e3t1s2","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:48:46.617295-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s2","depends_on_id":"test-e3t1s1","type":"blocks","created_at":"2026-01-30T12:51:23.788607-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s3","title":"Build audio encoding/decoding pipeline with chunking strategy","description":"Implement audio processing pipeline: receive browser WebAudio API format (typically 32-bit float PCM), convert to LFM model input format, process through model, convert output back to browser-compatible format. Implement 20-40ms audio chunking for streaming (test both to determine optimal latency). Add Opus codec support for bandwidth-constrained scenarios with PCM fallback for lowest latency.\n\n**Context:** Audio format conversion and chunking strategy directly impact perceived latency. 20ms chunks mean 20ms minimum latency per chunk; 40ms chunks are more CPU efficient but add latency. The codec choice affects bandwidth (Opus ~32kbps vs PCM ~256kbps) but also adds encoding latency.\n\n**Testing Requirements:**\n- **Unit Tests:** Test PCM format conversion (32-bit float to model input format and back), test Opus encoding/decoding roundtrip preserves audio quality, test 20ms chunking produces correct chunk sizes, test 40ms chunking produces correct chunk sizes, test chunk reassembly produces continuous audio without gaps/pops, test pipeline latency measurement (should be \u003c50ms processing time)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:46.94396-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:46.94396-06:00","labels":["audio","backend","codec","integration","ml-prompting","performance"],"dependencies":[{"issue_id":"test-e3t1s3","depends_on_id":"test-e3t1s2","type":"blocks","created_at":"2026-01-30T12:09:32.274686-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s3","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:48:47.150931-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s3","depends_on_id":"test-e3t1s1","type":"blocks","created_at":"2026-01-30T12:51:24.063517-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s4","title":"Integrate pipeline components and verify end-to-end latency","description":"Wire together WebSocket server, audio pipeline, and LFM model into complete bidirectional flow. Add latency instrumentation at each stage (receive -\u003e decode -\u003e model inference -\u003e encode -\u003e send). Create test client that simulates browser audio capture. Measure and log end-to-end latency. Verify total latency is \u003c500ms. Document bottlenecks and optimization opportunities.\n\n**Context:** RealHerd's \u003c500ms latency target is critical for natural conversation. This integration step validates the architecture meets that target and identifies where time is being spent. If latency exceeds target, this instrumentation guides optimization efforts.\n\n**Testing Requirements:**\n- **Unit Tests:** Test complete audio roundtrip (send audio chunk, receive processed response), test latency measurement logging captures all stages, test concurrent streams don't interfere with each other, test error propagation (model failure returns error to client), integration test: measure 100 audio chunks and verify 95th percentile latency \u003c500ms","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:47.76971-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:47.76971-06:00","labels":["api","backend","integration","performance","testing"],"dependencies":[{"issue_id":"test-e3t1s4","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:48:49.334941-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s4","depends_on_id":"test-e3t1s2","type":"blocks","created_at":"2026-01-30T12:51:24.270555-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s4","depends_on_id":"test-e3t1s3","type":"blocks","created_at":"2026-01-30T12:51:24.48161-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2","title":"Build conversation orchestration layer with debrief flow logic","description":"Create the conversation state machine that orchestrates natural debrief dialogues. Implement the conversation flow phases: greeting, open-ended questions about recent activity, intelligent follow-ups based on responses, and professional wrap-up. Include system prompts that achieve warm, professional voice per brand guidelines.\n\n**Context:** Agents are busy professionals who hate filling out CRMs. The debrief conversation needs to feel like a quick catch-up with a knowledgeable colleague, not a robotic survey. The orchestration layer transforms raw voice AI capability into structured business intelligence extraction without agents noticing the structure.\n\n**Testing Requirements:**\n- **Unit Tests:** State transition logic, prompt template generation, context injection, topic detection functions, follow-up question selection\n- **Integration Tests:** Full conversation flow simulation with mocked LFM responses, verify state transitions match expected dialogue patterns","design":"Design as finite state machine with states: GREETING → OPEN_QUESTIONS → FOLLOW_UPS → CLARIFICATION → WRAP_UP. Build prompt templates for each state that maintain warm, professional tone. Include context injection points for agent-specific data (their current deals, recent activity). Implement branching logic for follow-ups based on detected topics (new lead, deal update, client concern).","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:28.463174-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:28.463174-06:00","labels":["ai","backend","conversation","conversation-design"],"dependencies":[{"issue_id":"test-e3t2","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:47:28.625349-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2","depends_on_id":"test-e3t1","type":"blocks","created_at":"2026-01-30T12:51:24.725166-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s1","title":"Define TypeScript types and state machine interface for conversation flow","description":"Create type definitions for conversation states (GREETING, OPEN_QUESTIONS, FOLLOW_UPS, CLARIFICATION, WRAP_UP), transitions, and context. Define interfaces for ConversationState, ConversationContext (agent data, current deals, recent activity), StateTransition, and ConversationEvent. Include types for branching conditions (new lead detected, deal update, client concern).\n\n**Context:** Type-safe state machine foundation ensures reliable conversation flow and makes debugging easier when conversations don't follow expected paths.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that all state types are properly exported, test ConversationContext interface accepts agent-specific data, test StateTransition type enforces valid from/to state combinations","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:48:53.116155-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:53.116155-06:00","labels":["ai","auth","backend","convex","types"],"dependencies":[{"issue_id":"test-e3t2s1","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:48:53.563879-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s2","title":"Implement conversation state machine with transition logic","description":"Build the ConversationStateMachine class that manages state transitions. Implement methods: getCurrentState(), transition(event), canTransition(toState), getAvailableTransitions(). Include branching logic that analyzes conversation content to determine next state - detecting topics like 'new lead' routes to relevant follow-ups, 'deal update' triggers clarification questions, 'client concern' extends the conversation for more detail.\n\n**Context:** The state machine is the brain that makes conversations feel natural by choosing contextually appropriate next steps rather than following a rigid script.\n\n**Testing Requirements:**\n- **Unit Tests:** Test initial state is GREETING, test valid transitions (GREETING→OPEN_QUESTIONS), test invalid transitions throw errors, test branching logic routes 'new lead' mentions to appropriate follow-up state, test context preservation across transitions","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:53.889099-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:53.889099-06:00","labels":["ai","api","backend","core-logic","prompts","ux"],"dependencies":[{"issue_id":"test-e3t2s2","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:48:54.147406-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s2","depends_on_id":"test-e3t2s1","type":"blocks","created_at":"2026-01-30T12:51:24.95737-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s3","title":"Create prompt templates for each conversation state with context injection","description":"Build prompt template system with templates for each state. GREETING: warm opener referencing agent's name and recent activity. OPEN_QUESTIONS: 'How did things go today?' style prompts. FOLLOW_UPS: dynamic prompts based on detected topics. CLARIFICATION: gentle probing questions. WRAP_UP: professional close with summary. Implement context injection that inserts agent-specific data (their active deals, last contact dates, pending tasks) into prompts.\n\n**Context:** The prompts are what make RealHerd feel like a knowledgeable colleague rather than a robotic survey. Warm, professional tone per brand guidelines is critical for agent adoption.\n\n**Testing Requirements:**\n- **Unit Tests:** Test each template renders without errors, test context injection correctly inserts agent name and deal data, test templates maintain consistent tone markers (warm greetings, professional closings), test template selection based on current state","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:54.443956-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:54.443956-06:00","labels":["ai","backend","core","monitoring","prompts","validation"],"dependencies":[{"issue_id":"test-e3t2s3","depends_on_id":"test-e3t2s2","type":"blocks","created_at":"2026-01-30T12:09:33.370575-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s3","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:48:54.683943-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s3","depends_on_id":"test-e3t2s1","type":"blocks","created_at":"2026-01-30T12:51:25.197193-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s4","title":"Build orchestration layer that coordinates state machine with voice AI","description":"Create ConversationOrchestrator class that ties everything together. Implement startConversation(agentId) that initializes state and loads agent context, processUtterance(text) that analyzes input and triggers transitions, generateResponse() that selects appropriate prompt template with injected context. Include conversation timeout handling and graceful recovery from unexpected inputs.\n\n**Context:** The orchestrator transforms raw voice AI capability into structured business intelligence extraction. Agents should experience a natural conversation while the system methodically captures deal updates, concerns, and action items.\n\n**Testing Requirements:**\n- **Unit Tests:** Test startConversation initializes correct state and loads agent context, test processUtterance triggers appropriate state transitions, test generateResponse returns templated response for current state, test timeout handling moves to WRAP_UP state, test full conversation flow from GREETING through WRAP_UP","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:54.973464-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:54.973464-06:00","labels":["api","backend","integration","monitoring","testing","validation"],"dependencies":[{"issue_id":"test-e3t2s4","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:48:55.179794-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s4","depends_on_id":"test-e3t2s2","type":"blocks","created_at":"2026-01-30T12:51:25.413234-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s4","depends_on_id":"test-e3t2s3","type":"blocks","created_at":"2026-01-30T12:51:25.791651-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3","title":"Implement interruption handling and turn-taking","description":"Build robust handling for conversation interruptions - when users speak while AI is responding, when there are long pauses, and natural turn-taking cues. Implement voice activity detection (VAD) and barge-in support so conversations feel natural rather than walkie-talkie style.\n\n**Context:** Natural conversations involve interruptions and overlapping speech. If RealHerd forces agents to wait for AI to finish before responding, it will feel frustrating and robotic. Graceful interruption handling is what separates 'impressive demo' from 'tool agents actually use daily.'\n\n**Testing Requirements:**\n- **Unit Tests:** VAD threshold logic, barge-in state transitions, pause duration calculations, audio buffer management\n- **Integration Tests:** Simulated interruption scenarios, conversation coherence after barge-in, false positive rate testing with background noise samples","design":"Implement VAD to detect when user starts speaking during AI output. On barge-in, gracefully truncate AI response and process new user input. Handle pause detection (distinguish thinking pause from end-of-turn). Consider confidence thresholds to avoid false positive interruptions from background noise. May need to buffer recent AI context for coherent continuation after interruption.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:28.87382-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:28.87382-06:00","labels":["ai","audio","backend","ux"],"dependencies":[{"issue_id":"test-e3t3","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:47:29.04663-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3","depends_on_id":"test-e3t1","type":"blocks","created_at":"2026-01-30T12:51:26.011716-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3","depends_on_id":"test-e3t2","type":"blocks","created_at":"2026-01-30T12:51:26.256072-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s1","title":"Implement Voice Activity Detection (VAD) module","description":"Create a VAD module that continuously monitors audio input stream to detect when the user starts speaking. Use energy-based detection with adaptive thresholds to distinguish speech from background noise. Implement configurable sensitivity levels and debounce logic to prevent false triggers from brief noises. The module should emit events for speech_start, speech_end, and speech_continuing states.\n\n**Context:** VAD is the foundation for all interruption handling - without reliable detection of when humans are speaking, we can't implement natural turn-taking. This must work in real-time with minimal latency to feel responsive.\n\n**Testing Requirements:**\n- **Unit Tests:** Test VAD correctly identifies speech onset in clean audio, test energy threshold adaptation over time, test debounce prevents rapid on/off toggling, test background noise rejection at various levels, test speech_start event fires within 100ms of actual speech, test configurable sensitivity affects detection threshold","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:55.574797-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:55.574797-06:00","labels":["audio","backend","core-experience","frontend","types","utilities"],"dependencies":[{"issue_id":"test-e3t3s1","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:48:55.793203-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s2","title":"Build barge-in detection and AI response truncation","description":"Implement barge-in handling that detects when user speaks during AI audio output. When barge-in is detected: (1) immediately stop AI audio playback, (2) signal LFM to halt generation, (3) capture the partial response context for potential continuation. Use confidence thresholds to avoid interrupting on coughs/background noise - require sustained speech (\u003e200ms) or high-energy speech to trigger barge-in.\n\n**Context:** Barge-in is what makes conversations feel natural rather than walkie-talkie. Users should be able to interrupt the AI mid-sentence just like they would a human colleague, without waiting for the AI to finish a long response.\n\n**Testing Requirements:**\n- **Unit Tests:** Test barge-in triggers when user speaks during AI playback, test audio playback stops within 50ms of barge-in detection, test brief noise (\u003c200ms) does not trigger false barge-in, test partial response context is captured correctly, test high-confidence speech triggers immediate barge-in, test low-confidence sounds require sustained duration","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:56.099926-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:56.099926-06:00","labels":["algorithms","audio","backend","conversation-flow","frontend","matching"],"dependencies":[{"issue_id":"test-e3t3s2","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:48:56.257881-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s2","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T12:51:26.462637-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s3","title":"Implement end-of-turn detection with pause analysis","description":"Create intelligent end-of-turn detection that distinguishes between thinking pauses and conversation handoffs. Implement multi-signal detection: (1) silence duration thresholds (adjustable, default ~700ms for end-of-turn vs ~300ms for thinking pause), (2) prosodic cues if available (falling intonation suggests turn end), (3) semantic completion signals from partial transcription. Buffer recent audio to allow reprocessing if turn-end was detected prematurely.\n\n**Context:** Getting turn-taking wrong is incredibly frustrating - cutting someone off mid-thought or waiting too long after they finish both feel robotic. Smart pause detection makes the difference between a tool agents tolerate and one they enjoy using.\n\n**Testing Requirements:**\n- **Unit Tests:** Test short pauses (\u003c500ms) do not trigger turn end, test sustained silence (\u003e700ms) triggers turn end, test configurable threshold values are respected, test audio buffer retains last N seconds for reprocessing, test turn-end event includes confidence score, test rapid speech resumption cancels pending turn-end","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:48:56.641095-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:56.641095-06:00","labels":["ai-prompting","api","audio","backend","business-logic","conversation-flow","fub"],"dependencies":[{"issue_id":"test-e3t3s3","depends_on_id":"test-e3t3s2","type":"blocks","created_at":"2026-01-30T12:09:35.767844-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s3","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:48:56.860747-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s3","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T12:51:26.652844-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s4","title":"Integrate interruption handling into conversation flow and verify natural interactions","description":"Wire VAD, barge-in, and turn-detection modules into the main conversation controller. Implement state machine for conversation states: AI_SPEAKING, USER_SPEAKING, LISTENING, PROCESSING. Handle edge cases: rapid back-and-forth, user continuing after interruption, AI gracefully resuming or pivoting after barge-in. Add context buffering so AI can reference what it was saying before interruption. Verify with manual testing that conversations feel natural.\n\n**Context:** Individual components are useless without proper orchestration. The conversation controller must seamlessly coordinate these signals to create the fluid experience that makes RealHerd feel like talking to a colleague rather than commanding a robot.\n\n**Testing Requirements:**\n- **Unit Tests:** Test state machine transitions correctly between all states, test barge-in during AI_SPEAKING transitions to USER_SPEAKING, test context buffer is passed to LFM after interruption, test rapid state changes don't cause race conditions, test graceful handling when user speaks immediately after AI finishes, test conversation can continue coherently after interruption","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:48:57.258648-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:57.258648-06:00","labels":["ai-prompting","api","backend","edge-cases","frontend","integration","logging","workflow"],"dependencies":[{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T12:09:36.387417-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:48:57.741391-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3s2","type":"blocks","created_at":"2026-01-30T12:51:26.90938-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3s3","type":"blocks","created_at":"2026-01-30T12:51:27.135438-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s5","title":"Integrate and test full interruption handling flow","description":"Wire together VAD, silence detection, wrap-up triggers, and edge case handlers into cohesive conversation controller. Ensure state transitions are clean and predictable. Add logging/telemetry for interruption events (frequency, timing, which phrases trigger wrap-up). Test complete conversation flows with various interruption patterns. Verify no audio overlap or echo issues when interrupting. Document the conversation state machine and configuration options.\n\n**Context:** Individual features must work together seamlessly - a choppy experience from poorly integrated systems would undermine the 'magic' of natural conversation.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:51.240794-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:27.913346-06:00","labels":["documentation","integration","testing"],"dependencies":[{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:07:51.531133-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T12:09:36.80868-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s2","type":"blocks","created_at":"2026-01-30T12:09:37.056229-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s3","type":"blocks","created_at":"2026-01-30T12:09:37.308001-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s4","type":"blocks","created_at":"2026-01-30T12:09:37.531826-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:27.913346-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e3t4","title":"Implement real-time transcript generation and storage","description":"Build real-time transcript generation during calls using LFM's speech recognition. Stream transcript segments to Convex for storage as conversation progresses. Design transcript schema that captures speaker attribution, timestamps, and confidence scores. Ensure transcripts are queryable for the dashboard display.\n\n**Context:** Brokerage owners and team leads need visibility into what was discussed without listening to full recordings. Real-time transcripts also enable the Insight Extraction Engine (Epic 4) to process information immediately. This creates the audit trail that makes RealHerd valuable for compliance and coaching.\n\n**Testing Requirements:**\n- **Unit Tests:** Transcript segment parsing, speaker attribution logic, Convex mutation functions, timestamp synchronization\n- **Integration Tests:** Real-time transcript streaming during mock conversation, transcript retrieval and formatting, Convex subscription for live updates","design":"Design Convex schema for transcripts: conversation_id, segments (array of {speaker, text, timestamp, confidence}), metadata. Stream transcript segments incrementally during call rather than batch at end. Implement speaker diarization to distinguish AI from agent. Consider storing both raw segments and a cleaned/formatted version for display.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:29.267314-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:29.267314-06:00","labels":["ai","backend","convex","data","database"],"dependencies":[{"issue_id":"test-e3t4","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:47:29.401484-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4","depends_on_id":"test-e3t1","type":"blocks","created_at":"2026-01-30T12:51:27.341945-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4","depends_on_id":"test-e3t2","type":"blocks","created_at":"2026-01-30T12:51:27.565073-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s1","title":"Design and implement Convex transcript schema","description":"Create Convex schema for real-time transcripts with: conversation_id (reference to calls table), segments array containing {speaker: string, text: string, timestamp: number, confidence: number}, metadata object for call context, created_at/updated_at timestamps. Include indexes on conversation_id for efficient querying. Add a 'formatted_transcript' field for cleaned display version alongside raw segments.\n\n**Context:** The transcript schema is foundational for storing streaming speech data and must support both real-time appending of segments during calls and efficient querying for dashboard display. Speaker attribution enables distinguishing AI from human agent for coaching insights.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation for required fields, test segment array operations (append, query), test conversation_id reference integrity, verify indexes work for conversation lookup queries, test edge cases like empty segments array","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:48:58.873099-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:48:58.873099-06:00","labels":["backend","database","infrastructure","integration","schema"],"dependencies":[{"issue_id":"test-e3t4s1","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:49:01.242054-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s2","title":"Build transcript segment streaming service","description":"Implement a TranscriptStreamService class that receives real-time speech recognition output from LFM and streams segments to Convex incrementally. Create mutation functions: appendTranscriptSegment(conversationId, segment) for real-time updates, finalizeTranscript(conversationId) for end-of-call processing. Handle network interruptions with retry logic and segment buffering.\n\n**Context:** Streaming segments incrementally during calls (rather than batch at end) enables real-time transcript display on dashboards and allows the Insight Extraction Engine to begin processing immediately. This is critical for the live visibility brokerage owners need.\n\n**Testing Requirements:**\n- **Unit Tests:** Test appendTranscriptSegment with valid/invalid segments, test segment ordering by timestamp, test retry logic with simulated network failures, test buffer behavior when Convex is temporarily unavailable, verify finalizeTranscript aggregates segments correctly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:01.698345-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:01.698345-06:00","labels":["api-integration","audio","backend","data","processing","real-time"],"dependencies":[{"issue_id":"test-e3t4s2","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:49:01.872511-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s2","depends_on_id":"test-e3t4s1","type":"blocks","created_at":"2026-01-30T12:51:27.791542-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s3","title":"Implement speaker diarization for AI vs agent attribution","description":"Create speaker identification logic that distinguishes between AI assistant speech and human agent speech in the transcript. Use LFM's speech recognition metadata if available, otherwise implement audio channel separation or voice fingerprinting. Tag each segment with speaker: 'ai' | 'agent' | 'unknown'. Store speaker profiles for consistent attribution across calls.\n\n**Context:** Speaker attribution is essential for compliance auditing and coaching - managers need to see exactly what the AI said versus what the agent said. This also feeds into insight extraction where AI recommendations vs agent responses have different analytical value.\n\n**Testing Requirements:**\n- **Unit Tests:** Test speaker identification with mock LFM output containing speaker metadata, test fallback logic when metadata unavailable, verify speaker tags are correctly assigned to segments, test edge cases like overlapping speech or silence gaps","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:02.147461-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:02.147461-06:00","labels":["ai","api","backend","convex","crm","frontend","monitoring"],"dependencies":[{"issue_id":"test-e3t4s3","depends_on_id":"test-e3t4s1","type":"blocks","created_at":"2026-01-30T12:09:38.149787-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s3","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:49:02.379267-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s3","depends_on_id":"test-e3t4s2","type":"blocks","created_at":"2026-01-30T12:51:28.004399-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s4","title":"Create transcript query API and formatted output generator","description":"Build Convex query functions for transcript retrieval: getTranscriptByConversation(conversationId), getTranscriptsForDateRange(agentId, startDate, endDate), searchTranscripts(query). Implement a formatter that converts raw segments into readable transcript with speaker labels, timestamps, and paragraph breaks. Generate both full transcript and summary views for dashboard consumption.\n\n**Context:** Dashboards need efficient access to transcripts for display, and the formatted output ensures readability without frontend processing overhead. Search capability enables finding specific conversations by content, which is valuable for compliance reviews and coaching sessions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getTranscriptByConversation returns correct segments ordered by timestamp, test date range queries with edge cases (no results, large ranges), test search with partial matches and special characters, verify formatter produces correct speaker labels and paragraph breaks, test summary generation truncates appropriately","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:02.696435-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:02.696435-06:00","labels":["api","backend","e2e","integration","reliability","testing"],"dependencies":[{"issue_id":"test-e3t4s4","depends_on_id":"test-e3t4s2","type":"blocks","created_at":"2026-01-30T12:09:38.340205-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s4","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:49:03.303754-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s4","depends_on_id":"test-e3t4s1","type":"blocks","created_at":"2026-01-30T12:51:28.222838-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s4","depends_on_id":"test-e3t4s3","type":"blocks","created_at":"2026-01-30T12:51:28.448449-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5","title":"Build transcript display component in dashboard","description":"Create the UI component for viewing conversation transcripts in the dashboard. Display speaker-attributed transcript with timestamps. Support real-time updates for live conversations. Include playback correlation if audio recording is available.\n\n**Context:** Team leads managing 4-12 agents need quick visibility into debrief content without calling each agent. A clean transcript view transforms voice conversations into scannable intelligence. This completes the feedback loop: agents talk naturally → leads see insights instantly.\n\n**Testing Requirements:**\n- **Unit Tests:** Transcript rendering with various segment types, timestamp formatting, speaker attribution styling\n- **Integration Tests:** Real-time subscription updates, component performance with long transcripts, accessibility verification","design":"Build React component with Convex real-time subscription for live updates. Style with shadcn/ui components - chat bubble style with AI vs Agent distinction. Show timestamps on hover to keep UI clean. Consider collapsible sections for long conversations. Link to full audio playback if available.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:30.290324-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:30.290324-06:00","labels":["dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e3t5","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:47:30.517465-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5","depends_on_id":"test-e3t4","type":"blocks","created_at":"2026-01-30T12:51:28.767694-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s1","title":"Create TypeScript types and Convex schema for transcript data","description":"Define TypeScript interfaces for transcript entries including speaker attribution (AI vs Agent), timestamps, message content, and conversation metadata. Create or extend Convex schema if needed for transcript storage. Types should support both historical and real-time streaming scenarios.\n\n**Context:** Strong typing ensures the component handles all transcript states correctly - empty, loading, streaming live, and completed. Speaker attribution types (AI vs Agent) are critical for the visual distinction team leads need to quickly scan conversations.\n\n**Testing Requirements:**\n- **Unit Tests:** Test type guards for TranscriptEntry validation, test speaker type discrimination (isAIMessage, isAgentMessage), test timestamp parsing/formatting utilities","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:03.675509-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:03.675509-06:00","labels":["api","backend","database","frontend","schema","types"],"dependencies":[{"issue_id":"test-e3t5s1","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:49:03.854209-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s2","title":"Build base TranscriptDisplay React component with shadcn/ui styling","description":"Create TranscriptDisplay component using shadcn/ui Card, ScrollArea, and Avatar components. Implement chat bubble style layout with clear AI vs Agent visual distinction (different colors/alignment). Show timestamps on hover using Tooltip. Support collapsible sections via Collapsible component for long conversations (\u003e10 messages). Include empty state and loading skeleton.\n\n**Context:** Team leads scanning multiple agent conversations need instant visual parsing - AI messages should be visually distinct from agent responses. Hover timestamps keep the UI clean while preserving detail access. Collapsible sections prevent scroll fatigue for lengthy debriefs.\n\n**Testing Requirements:**\n- **Unit Tests:** Test component renders with empty transcript array, test speaker attribution styling (AI left-aligned blue, Agent right-aligned green), test timestamp tooltip appears on hover, test collapsible expands/collapses, test loading skeleton displays during fetch","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:04.070067-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:04.070067-06:00","labels":["backend","component","frontend","reliability","ui"],"dependencies":[{"issue_id":"test-e3t5s2","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:49:04.271627-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s2","depends_on_id":"test-e3t5s1","type":"blocks","created_at":"2026-01-30T12:51:28.960751-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s3","title":"Add Convex real-time subscription for live transcript updates","description":"Implement useQuery hook with Convex real-time subscription to transcript data. Handle streaming updates that append new messages during live conversations. Add visual indicator for 'live' vs 'completed' conversation state. Implement auto-scroll to bottom for new messages with scroll-lock detection (don't auto-scroll if user scrolled up to read history).\n\n**Context:** Real-time updates are the killer feature - team leads can watch a debrief happen live instead of waiting for completion. Smart auto-scroll respects users reviewing earlier messages while still showing live indicator.\n\n**Testing Requirements:**\n- **Unit Tests:** Test subscription updates append messages correctly, test live indicator shows for active conversations, test auto-scroll triggers on new message when at bottom, test auto-scroll disabled when user scrolled up, test subscription cleanup on unmount","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:04.544401-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:04.544401-06:00","labels":["backend","component","convex","frontend","realtime","ui"],"dependencies":[{"issue_id":"test-e3t5s3","depends_on_id":"test-e3t5s1","type":"blocks","created_at":"2026-01-30T12:09:39.211182-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s3","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:49:04.780913-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s3","depends_on_id":"test-e3t5s2","type":"blocks","created_at":"2026-01-30T12:51:29.177105-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s4","title":"Add audio playback link and verify component integration","description":"Add conditional 'Play Audio' button that links to full audio recording when available. Button should show recording duration if known. Wire component into dashboard page with real Convex data. Test full flow: view transcript, see live updates, click to play audio. Verify responsive behavior on mobile viewport.\n\n**Context:** Audio playback completes the feedback loop - leads can read the transcript for quick scan, then listen to tone/nuance when needed. This integration test ensures the transcript display works in its real dashboard context.\n\n**Testing Requirements:**\n- **Unit Tests:** Test audio button renders only when audioUrl present, test button hidden when no recording, test duration display formatting, test click opens audio player/modal. Integration: verify component loads real data in dashboard, test mobile responsive layout","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:05.196321-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:05.196321-06:00","labels":["backend","frontend","integration","security","testing"],"dependencies":[{"issue_id":"test-e3t5s4","depends_on_id":"test-e3t5s1","type":"blocks","created_at":"2026-01-30T12:09:39.588001-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s4","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:49:05.56796-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s4","depends_on_id":"test-e3t5s3","type":"blocks","created_at":"2026-01-30T12:51:29.395886-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s5","title":"Integrate transcript view into dashboard and verify end-to-end flow","description":"Wire the transcript display into the main dashboard with navigation from call history to transcript detail view. Add loading states, error boundaries, and empty states (no transcript available). Test the complete flow: select a call from history → view transcript with audio → search, seek, and playback at different speeds → verify privacy controls work correctly.\n\n**Context:** The transcript review must be easily accessible from where agents naturally work. A smooth flow from call list to detailed review encourages agents to verify their debriefs, improving data quality.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:55.837801-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:26.536553-06:00","labels":["frontend","integration"],"dependencies":[{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:07:56.318915-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5s2","type":"blocks","created_at":"2026-01-30T12:09:39.768096-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5s3","type":"blocks","created_at":"2026-01-30T12:09:39.96694-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5s4","type":"blocks","created_at":"2026-01-30T12:09:40.179334-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:26.536553-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e3t6","title":"End-to-end voice conversation integration test and latency verification","description":"Verify the complete voice conversation flow works end-to-end: audio streaming, conversation orchestration, interruption handling, and transcript generation. Measure and verify \u003c500ms latency requirement. Test with realistic debrief scenarios and edge cases.\n\n**Context:** Before building additional features on top of the voice engine, we need confidence that the core conversation experience meets the 'talking to a colleague' bar. This verification catches integration issues that unit tests miss and confirms we hit the latency target that makes conversations feel natural.\n\n**Testing Requirements:**\n- **Unit Tests:** Latency measurement instrumentation, test scenario setup functions\n- **Integration Tests:** Full conversation round-trip with latency assertions, multi-turn debrief scenarios, stress test with concurrent conversations, network degradation simulation","design":"Create test harness that measures round-trip latency at each stage (audio capture → model → audio playback). Test full debrief flow scenarios: quick update, complex deal discussion, agent with connection issues. Document baseline metrics for ongoing monitoring. Flag any components exceeding latency budget.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:30.717402-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:30.717402-06:00","labels":["integration","performance","qa","testing"],"dependencies":[{"issue_id":"test-e3t6","depends_on_id":"test-e3t5","type":"blocks","created_at":"2026-01-30T12:09:40.60949-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:47:30.898892-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6","depends_on_id":"test-e3t1","type":"blocks","created_at":"2026-01-30T12:51:29.600955-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6","depends_on_id":"test-e3t2","type":"blocks","created_at":"2026-01-30T12:51:29.820912-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6","depends_on_id":"test-e3t3","type":"blocks","created_at":"2026-01-30T12:51:30.032378-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6","depends_on_id":"test-e3t4","type":"blocks","created_at":"2026-01-30T12:51:30.243637-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s1","title":"Create latency measurement harness with timing instrumentation","description":"Build a test harness that measures latency at each stage of the voice pipeline: audio capture timestamp, model request send, model response start (time-to-first-byte), audio playback start. Use high-resolution timestamps (performance.now() or equivalent). Create LatencyMetrics type to store measurements. Output should include individual stage times and total round-trip.\n\n**Context:** We need precise measurements to verify the \u003c500ms target and identify which components contribute most to latency. Without instrumentation, we can't optimize or set alerts.\n\n**Testing Requirements:**\n- **Unit Tests:** Test LatencyMetrics calculation accuracy, test timestamp capture at mock pipeline stages, verify total latency = sum of stages, test metric output formatting","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:05.944884-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:05.944884-06:00","labels":["backend","demo","infrastructure","testing","voice"],"dependencies":[{"issue_id":"test-e3t6s1","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:49:06.183451-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s2","title":"Implement realistic debrief scenario test cases","description":"Create test fixtures for 3 debrief scenarios: (1) Quick update - 'Just showed 123 Main St, buyers loved it, making offer tomorrow' (2) Complex deal discussion - multi-turn conversation about pricing strategy, competing offers, timeline (3) Connection issues - simulate network jitter, dropped packets, reconnection. Each scenario should have expected conversation flow and validation criteria.\n\n**Context:** Real debrief conversations vary widely in complexity. Testing only simple cases misses issues that appear in longer, more complex interactions that agents actually have.\n\n**Testing Requirements:**\n- **Unit Tests:** Test scenario fixtures load correctly, validate expected turn counts per scenario, test that connection issue simulation actually introduces delays/drops","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:06.951245-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:06.951245-06:00","labels":["backend","performance","testing","voice","voice-ai"],"dependencies":[{"issue_id":"test-e3t6s2","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:49:07.128045-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6s2","depends_on_id":"test-e3t6s1","type":"blocks","created_at":"2026-01-30T12:51:30.431868-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s3","title":"Execute end-to-end integration tests with interruption handling","description":"Run full voice conversation tests through the actual pipeline (not mocks). Test: (1) Complete conversation flow - user speaks, model responds, user responds (2) Mid-response interruption - user cuts off AI mid-sentence (3) Rapid back-and-forth - quick exchanges without pauses. Capture latency metrics for each test. Verify audio streaming doesn't drop frames, transcript captures all speech accurately.\n\n**Context:** Integration tests catch issues that unit tests miss - WebSocket timing, actual model latency, audio codec behavior. Interruption handling is critical for natural conversation feel.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify all 3 test types complete without errors, assert latency measurements are captured for each stage, validate transcripts match expected speech content, confirm interruption stops audio playback within 100ms","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:07.402908-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:07.402908-06:00","labels":["backend","edge-cases","integration","reporting","testing","voice","voice-ai"],"dependencies":[{"issue_id":"test-e3t6s3","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:49:07.603299-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6s3","depends_on_id":"test-e3t6s1","type":"blocks","created_at":"2026-01-30T12:51:30.740025-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6s3","depends_on_id":"test-e3t6s2","type":"blocks","created_at":"2026-01-30T12:51:30.954687-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s4","title":"Document baseline metrics and create latency budget report","description":"Analyze collected latency data from all test runs. Calculate: P50, P90, P99 latencies for each pipeline stage and total round-trip. Compare against \u003c500ms target. Create markdown report documenting: baseline metrics, latency budget breakdown by component, components exceeding budget (flagged), recommendations for optimization if needed. Store metrics in a format suitable for CI monitoring.\n\n**Context:** Baseline metrics enable ongoing monitoring and regression detection. Clear documentation of where time is spent guides future optimization efforts.\n\n**Testing Requirements:**\n- **Unit Tests:** Test percentile calculation functions, verify report generation produces valid markdown, test that components over budget are correctly flagged, validate metrics JSON schema for CI compatibility","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:07.879035-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:07.879035-06:00","labels":["database","demo","documentation","frontend","testing","voice"],"dependencies":[{"issue_id":"test-e3t6s4","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:49:08.448134-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6s4","depends_on_id":"test-e3t6s3","type":"blocks","created_at":"2026-01-30T12:51:31.16334-06:00","created_by":"David Habedank"}]}
{"id":"test-e4","title":"Data Extraction \u0026 Structured Output","description":"Build the extraction pipeline that converts natural conversation into structured CRM data - lead temperature, timeline, follow-ups, property feedback, and summary notes.\n\n**Context:** The magic of RealHerd is turning rambling voice into clean CRM fields automatically. This epic creates the intelligence layer that extracts actionable data from conversations with confidence scoring.\n\n**Testing Requirements:**\n- **Unit Tests:** Extraction prompt rendering, confidence calculation, ExtractedData validation\n- **Integration Tests:** Full extraction pipeline from transcript to structured data, OpenRouter fallback trigger\n- **Type Tests:** ExtractedData schema validation, extraction confidence thresholds\n- **E2E Tests:** Complete debrief produces accurate structured data with \u003e80% accuracy on test conversations","acceptance_criteria":"- ExtractedData populated from debrief conversations (temperature, timeline, tasks, summary)\n- Confidence scoring on all extractions\n- Low-confidence extractions flagged for review\n- Extracted data displays cleanly in dashboard\n- Manual edit/correction interface for extracted data\n- OpenRouter fallback for complex extractions when LFM confidence is low","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:47:17.59893-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:17.59893-06:00","labels":["ai","core-feature","crm","data-processing","extraction","follow-up-boss"],"dependencies":[{"issue_id":"test-e4","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:41.660753-06:00","created_by":"David Habedank"},{"issue_id":"test-e4","depends_on_id":"test-e3","type":"blocks","created_at":"2026-01-30T12:51:31.39517-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1","title":"Define extraction schema and data models","description":"Create Convex schema for ExtractedData table with all required fields: lead temperature (hot/warm/cold/dead), timeline estimates, follow-up tasks, property feedback, summary notes, and confidence scores for each field. Design the data structure to support partial extractions and manual corrections.\n\n**Context:** The extraction schema is the foundation of RealHerd's value proposition - turning voice conversations into actionable CRM data. This schema must be flexible enough to handle varying conversation types while maintaining structured output that FUB can consume. Field-level confidence scores enable the review workflow.\n\n**Testing Requirements:**\n- **Unit Tests:** Schema validation, confidence score bounds (0-1), status enum transitions, editHistory append logic\n- **Integration Tests:** Create extraction records linked to debriefs, query extractions by status, update with corrections preserving history","design":"Use Convex schema with: extractedData table linked to debriefs via debriefId. Each extracted field should have both value and confidence (0-1 float). Include status enum (pending/extracted/reviewed/pushed_to_fub). Consider JSON field for property feedback array since agents may discuss multiple properties. Add editHistory array for audit trail of manual corrections.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:31.456793-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:31.456793-06:00","labels":["ai","backend","database","extraction","schema"],"dependencies":[{"issue_id":"test-e4t1","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:47:31.60435-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s1","title":"Create TypeScript types for extracted data fields","description":"Define TypeScript interfaces for all extracted data types: LeadTemperature enum (hot/warm/cold/dead), TimelineEstimate type with range and confidence, FollowUpTask type with action/due date/priority, PropertyFeedback type for multi-property discussions, and SummaryNotes type. Each extractable field type should include a confidence score (0-1 float). Also define ExtractedDataStatus enum (pending/extracted/reviewed/pushed_to_fub) and EditHistoryEntry type for audit trail.\n\n**Context:** These types form the contract between extraction AI, review UI, and FUB sync. Well-typed fields with confidence scores enable the review workflow that makes RealHerd trustworthy.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that all enum values are valid, test confidence score type accepts 0-1 range, test EditHistoryEntry captures required audit fields (timestamp, field, oldValue, newValue, editedBy)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:09.145325-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:09.145325-06:00","labels":["backend","integration","schema","types"],"dependencies":[{"issue_id":"test-e4t1s1","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:49:09.564223-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s2","title":"Create Convex schema for extractedData table","description":"Define the extractedData table in Convex schema with: debriefId (reference to debriefs table), status field using ExtractedDataStatus, leadTemperature with value and confidence, timelineEstimate with value and confidence, followUpTasks array with confidence per task, propertyFeedback as JSON array for multiple properties, summaryNotes with value and confidence, overall extraction confidence score, editHistory array for audit trail, timestamps (extractedAt, reviewedAt, pushedToFubAt). Add appropriate indexes for querying by debriefId and status.\n\n**Context:** The schema must support partial extractions (some fields may fail to extract) and manual corrections while maintaining audit trail for compliance and debugging.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validates required fields, test optional fields can be null for partial extractions, test editHistory array accepts valid EditHistoryEntry objects, test indexes are defined for debriefId and status queries","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:09.930941-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:09.930941-06:00","labels":["ai","backend","convex","mutations","prompts","schema"],"dependencies":[{"issue_id":"test-e4t1s2","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:49:10.213693-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s2","depends_on_id":"test-e4t1s1","type":"blocks","created_at":"2026-01-30T12:51:31.612407-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s3","title":"Implement CRUD functions for extractedData","description":"Create Convex mutations and queries: createExtractedData (initialize with pending status and debriefId), updateExtractedField (update single field with confidence, append to editHistory if overwriting), updateStatus (transition status with timestamp), getByDebriefId (fetch extraction for a debrief), getByStatus (list extractions by status for review queue). Include validation that confidence scores are 0-1 and status transitions are valid.\n\n**Context:** These functions power the extraction pipeline (AI writes), review UI (human reads/edits), and FUB sync (reads for push). Status transitions enable workflow tracking.\n\n**Testing Requirements:**\n- **Unit Tests:** Test createExtractedData returns valid id and sets pending status, test updateExtractedField appends to editHistory on change, test confidence score validation rejects values outside 0-1, test status transitions (pending→extracted→reviewed→pushed_to_fub), test getByStatus returns correct filtered results","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:10.662901-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:10.662901-06:00","labels":["ai","api","backend","convex","security","settings"],"dependencies":[{"issue_id":"test-e4t1s3","depends_on_id":"test-e4t1s1","type":"blocks","created_at":"2026-01-30T12:09:42.405153-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s3","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:49:10.897966-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s3","depends_on_id":"test-e4t1s2","type":"blocks","created_at":"2026-01-30T12:51:31.834445-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s4","title":"Verify schema with test data and edge cases","description":"Write integration tests that exercise the full extraction data lifecycle: create extraction for a debrief, simulate AI populating fields with varying confidence scores, simulate human review editing a field, verify editHistory captures the change, transition through all statuses. Test edge cases: partial extraction (only some fields populated), zero confidence scores, multiple property feedback entries, concurrent edits.\n\n**Context:** Validates the schema handles real-world scenarios before building the AI extraction logic on top of it. Catches issues with the data model early.\n\n**Testing Requirements:**\n- **Unit Tests:** Integration test: full lifecycle from pending→pushed_to_fub with field edits, test partial extraction with null fields, test multiple propertyFeedback entries serialize/deserialize correctly, test editHistory grows correctly with multiple edits to same field","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:11.340989-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:11.340989-06:00","labels":["backend","convex","integration","testing","verification"],"dependencies":[{"issue_id":"test-e4t1s4","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:49:11.557484-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s4","depends_on_id":"test-e4t1s3","type":"blocks","created_at":"2026-01-30T12:51:32.098646-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2","title":"Build LFM extraction pipeline with structured prompting","description":"Create serverless function that takes debrief transcript and extracts structured data using LFM 2.5. Implement prompt engineering for consistent JSON output covering: lead temperature assessment, timeline extraction, follow-up task identification, property feedback parsing, and conversation summary generation. Each extraction includes confidence score.\n\n**Context:** LFM is the primary extraction engine chosen for cost efficiency at scale. The extraction must handle messy, conversational real estate language ('gonna circle back next week', 'they're super motivated') and convert to structured fields. Confidence scoring enables the human-in-the-loop review process for edge cases.\n\n**Testing Requirements:**\n- **Unit Tests:** Prompt template generation, JSON response parsing, confidence calculation logic, temperature classification rubric, date normalization\n- **Integration Tests:** End-to-end extraction from sample transcripts, handling malformed LLM responses, timeout handling","design":"Use Convex action (not mutation) for LLM call. Structure prompt with clear JSON schema definition and examples. Parse temperature from qualitative statements using rubric (timeline mentions, engagement level, objections). Extract dates/timeframes and normalize to ISO dates where possible. For follow-ups, extract both task description and suggested due date. Return confidence based on signal clarity in transcript.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:47:31.805954-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:31.805954-06:00","labels":["ai","api","backend","integration","llm"],"dependencies":[{"issue_id":"test-e4t2","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:47:31.938736-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2","depends_on_id":"test-e4t1","type":"blocks","created_at":"2026-01-30T12:51:32.346648-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s1","title":"Create TypeScript types and JSON schema for extraction output","description":"Define the complete TypeScript interface for LFM extraction results: LeadTemperature (hot/warm/cool/cold with numeric score), Timeline (extracted dates, normalized ISO dates, original text), FollowUpTask (description, suggested due date, priority), PropertyFeedback (sentiment, specific concerns, interests), ConversationSummary (key points, action items), and confidence scores (0-1) for each section. Create corresponding JSON schema for LFM prompt.\n\n**Context:** The structured output types are the contract between LFM and the rest of the system. Clear types enable type-safe handling and consistent prompt engineering. The schema will be embedded in the LFM prompt to enforce output format.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that types compile correctly, test example extraction results validate against schema, test edge cases like missing fields and null values","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:11.868899-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:11.868899-06:00","labels":["backend","convex","database","frontend","security","types","ui"],"dependencies":[{"issue_id":"test-e4t2s1","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:49:12.213084-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s2","title":"Implement temperature assessment prompt with rubric","description":"Create the prompt engineering for lead temperature extraction. Build rubric that maps conversational signals to temperature: timeline mentions ('looking this month' = hot, 'maybe next year' = cool), engagement indicators ('super motivated' = hot, 'just browsing' = cold), objection patterns, and decision-maker involvement. Include few-shot examples of messy real estate language and correct classifications. Output includes temperature enum, numeric score (1-10), and confidence based on signal clarity.\n\n**Context:** Temperature is the most valuable extraction - it determines follow-up urgency. Real estate conversations are notoriously vague ('gonna circle back') so the rubric must handle ambiguity and return appropriate confidence when signals conflict.\n\n**Testing Requirements:**\n- **Unit Tests:** Test rubric classification for 5+ example transcripts covering hot/warm/cool/cold, test confidence scoring when signals conflict, test handling of ambiguous language","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:12.452546-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:12.452546-06:00","labels":["ai","api","backend","integration","integrations"],"dependencies":[{"issue_id":"test-e4t2s2","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:49:12.640428-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s2","depends_on_id":"test-e4t2s1","type":"blocks","created_at":"2026-01-30T12:51:32.537643-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s3","title":"Build Convex action for LFM API call with full extraction prompt","description":"Create Convex action (not mutation) that: takes debrief transcript as input, constructs full prompt with JSON schema, temperature rubric, and extraction instructions for all fields (timeline, follow-ups, property feedback, summary). Call LFM 2.5 API with appropriate parameters. Parse JSON response, validate against schema, calculate overall confidence. Handle API errors (rate limits, timeouts) with retry logic. Return typed extraction result.\n\n**Context:** This is the core extraction engine. Using Convex action (not mutation) is required because LLM calls are external API calls. The prompt must be carefully structured so LFM returns consistent, parseable JSON even with messy input transcripts.\n\n**Testing Requirements:**\n- **Unit Tests:** Test prompt construction with sample transcript, test JSON parsing of mock LFM response, test schema validation catches malformed responses, test retry logic for 429/500 errors, test timeout handling","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:12.950134-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:12.950134-06:00","labels":["ai","api","backend","convex","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e4t2s3","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:49:13.215957-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s3","depends_on_id":"test-e4t2s1","type":"blocks","created_at":"2026-01-30T12:51:32.753773-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s3","depends_on_id":"test-e4t2s2","type":"blocks","created_at":"2026-01-30T12:51:32.974272-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s4","title":"Add date normalization and follow-up extraction logic","description":"Implement post-processing for timeline and follow-up extraction: normalize relative dates ('next Tuesday', 'in two weeks') to ISO dates using current date context, extract explicit dates from various formats, parse follow-up tasks with suggested due dates based on urgency signals. Handle timezone considerations (default to user's timezone from context). Include original text alongside normalized values for human verification.\n\n**Context:** Date extraction is tricky because conversations use relative terms that change meaning based on when the debrief happened. Keeping original text enables human review and builds trust in the automation.\n\n**Testing Requirements:**\n- **Unit Tests:** Test relative date normalization ('next week' → ISO), test various date format parsing, test follow-up due date inference from urgency, test timezone handling, test preservation of original text","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:13.658507-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:13.658507-06:00","labels":["api","backend","calendar","integration","integrations","testing","verification"],"dependencies":[{"issue_id":"test-e4t2s4","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:49:13.85678-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s4","depends_on_id":"test-e4t2s3","type":"blocks","created_at":"2026-01-30T12:51:33.191189-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s5","title":"Integration test with sample transcripts and verify confidence scoring","description":"Create 3-5 realistic sample debrief transcripts covering different scenarios: hot motivated buyer, lukewarm seller with timeline, cold lead just browsing, complex multi-topic conversation. Run full extraction pipeline, verify all fields extract correctly, check confidence scores reflect signal clarity (clear signals = high confidence, ambiguous = low). Test edge cases: very short transcripts, transcripts with contradictory signals, transcripts missing key information.\n\n**Context:** End-to-end validation ensures the pipeline works with realistic messy input. Confidence scoring is critical for the human-in-the-loop review - low confidence extractions should be flagged for agent review.\n\n**Testing Requirements:**\n- **Unit Tests:** Integration tests with 5 sample transcripts, verify temperature extraction accuracy, verify date normalization, verify confidence correlates with signal clarity, test graceful handling of edge cases","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:14.097276-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:14.097276-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e4t2s5","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:49:14.266105-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s5","depends_on_id":"test-e4t2s4","type":"blocks","created_at":"2026-01-30T12:51:33.430758-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3","title":"Implement OpenRouter fallback for complex extractions","description":"Add fallback logic that routes to OpenRouter (GPT-4-turbo or Claude) when LFM extraction returns low overall confidence or fails. Implement confidence threshold configuration and provider selection logic. Track which model performed extraction for analytics.\n\n**Context:** Some conversations are complex - multiple leads discussed, contradictory signals, industry jargon heavy. OpenRouter fallback ensures data quality at the cost of higher per-extraction expense. This hybrid approach optimizes cost while maintaining accuracy for the edge cases that matter most to brokerages.\n\n**Testing Requirements:**\n- **Unit Tests:** Threshold comparison logic, provider selection, cost calculation, model field population\n- **Integration Tests:** Fallback trigger on low confidence, OpenRouter API calls with test credentials, handling OpenRouter rate limits/errors","design":"Add confidenceThreshold to config (default 0.7). If LFM overall confidence below threshold, retry with OpenRouter. Store extractionModel field in ExtractedData. Use same prompt structure for consistency. Consider retry with different OpenRouter model if first fails. Add extraction cost tracking for business metrics.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:32.131473-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:32.131473-06:00","labels":["ai","backend","integration","orchestration"],"dependencies":[{"issue_id":"test-e4t3","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:47:32.296517-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3","depends_on_id":"test-e4t2","type":"blocks","created_at":"2026-01-30T12:51:33.757926-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s1","title":"Add confidence threshold configuration and ExtractedData model field","description":"Add confidenceThreshold setting to extraction config (default 0.7). Extend ExtractedData type/interface to include extractionModel field (string: 'lfm' | 'openrouter-gpt4' | 'openrouter-claude') and extractionCost field (number in cents). Update any existing extraction result handling to populate these fields.\n\n**Context:** Configuration and data model changes must be in place before implementing fallback logic. The extractionModel field enables analytics on which provider handled each extraction, while extractionCost supports business metrics for cost optimization decisions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test config loads confidenceThreshold with default 0.7, test config override works, test ExtractedData type includes extractionModel and extractionCost fields, test validation rejects invalid extractionModel values","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:14.547021-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:14.547021-06:00","labels":["api","auth","backend","config","database","types"],"dependencies":[{"issue_id":"test-e4t3s1","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:49:14.748099-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s2","title":"Create OpenRouter API client with model selection","description":"Implement OpenRouter API client that supports GPT-4-turbo and Claude models. Include authentication, rate limiting handling, and standardized error responses. The client should accept the same prompt structure used for LFM extraction to ensure consistency. Include cost calculation based on token usage and model pricing.\n\n**Context:** OpenRouter provides access to multiple high-quality models through a single API. Using the same prompt structure as LFM ensures extraction consistency regardless of which model performs it. Cost tracking is essential for the hybrid cost optimization strategy.\n\n**Testing Requirements:**\n- **Unit Tests:** Test authentication with valid/invalid API keys, test model selection (gpt-4-turbo, claude), test prompt formatting matches LFM structure, test cost calculation from token counts, test error handling for 401/429/500 responses, test rate limit backoff logic","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:14.982889-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:14.982889-06:00","labels":["api","backend","frontend","fub-api","matching","scheduling"],"dependencies":[{"issue_id":"test-e4t3s2","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:49:15.20516-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s2","depends_on_id":"test-e4t3s1","type":"blocks","created_at":"2026-01-30T12:51:34.007592-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s3","title":"Implement fallback orchestration logic with retry strategy","description":"Create extraction orchestrator that: 1) Attempts LFM extraction first, 2) Checks if overall confidence is below configured threshold, 3) If below threshold or LFM fails, routes to OpenRouter with GPT-4-turbo, 4) If OpenRouter GPT-4 fails, retry with Claude. Populate extractionModel and extractionCost in results. Log fallback events for monitoring.\n\n**Context:** The orchestrator is the core of the hybrid approach - it balances cost (LFM is cheaper) with accuracy (OpenRouter handles complex cases). The multi-tier fallback ensures maximum reliability for the edge cases that matter most to brokerages.\n\n**Testing Requirements:**\n- **Unit Tests:** Test LFM success path (high confidence) returns LFM result, test low confidence triggers OpenRouter fallback, test LFM failure triggers OpenRouter fallback, test GPT-4 failure triggers Claude retry, test extractionModel populated correctly for each path, test extractionCost accumulated across retries, test confidence threshold from config is respected","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:15.517545-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:15.517545-06:00","labels":["backend","convex","core","frontend","orchestration","scheduling","ui"],"dependencies":[{"issue_id":"test-e4t3s3","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:49:15.83736-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s3","depends_on_id":"test-e4t3s1","type":"blocks","created_at":"2026-01-30T12:51:34.349108-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s3","depends_on_id":"test-e4t3s2","type":"blocks","created_at":"2026-01-30T12:51:34.617254-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s4","title":"Add extraction analytics and verify end-to-end fallback flow","description":"Add logging/metrics for extraction analytics: model used, confidence scores, cost per extraction, fallback rate. Create integration test that exercises full fallback path with mock responses. Verify extractionModel and extractionCost are correctly stored and retrievable for business reporting.\n\n**Context:** Analytics are critical for the business case - brokerages need to understand their extraction costs and the hybrid approach's ROI. The fallback rate metric helps tune the confidence threshold over time.\n\n**Testing Requirements:**\n- **Unit Tests:** Test analytics logger captures model, confidence, cost, test fallback rate calculation, test integration: mock LFM low-confidence → OpenRouter success path, test integration: mock LFM failure → GPT-4 failure → Claude success path, test stored extraction records have correct model and cost values","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:16.978531-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:16.978531-06:00","labels":["analytics","backend","convex","integration","queue","reliability","security","testing"],"dependencies":[{"issue_id":"test-e4t3s4","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:49:17.349209-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s4","depends_on_id":"test-e4t3s3","type":"blocks","created_at":"2026-01-30T12:51:34.89915-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4","title":"Build extraction review dashboard with confidence indicators","description":"Create dashboard view showing extracted data from debriefs with visual confidence indicators. Display all extracted fields with color-coded confidence (green/yellow/red). Filter by extraction status, confidence level, and agent. Link to original transcript for context verification.\n\n**Context:** Team leads and brokerage owners need to quickly identify extractions needing review. Visual confidence indicators let them focus attention on uncertain data rather than reviewing everything. This builds trust in the automation - users see exactly what the AI is confident about vs. uncertain.\n\n**Testing Requirements:**\n- **Unit Tests:** Confidence color mapping, filter logic, status chip rendering\n- **Integration Tests:** Dashboard loads with extraction data, filters update results correctly, real-time updates when extractions change, transcript expansion works","design":"Use shadcn/ui Card components for each extraction. Confidence badges with colors: green (\u003e0.8), yellow (0.5-0.8), red (\u003c0.5). Expandable sections for each field showing source quotes from transcript. Filter sidebar with status chips, confidence range slider, agent dropdown. Pagination for large datasets. Real-time updates via Convex subscriptions.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:32.525093-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:32.525093-06:00","labels":["ai","backend","dashboard","fallback","frontend","ui"],"dependencies":[{"issue_id":"test-e4t4","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:47:32.680349-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4","depends_on_id":"test-e4t1","type":"blocks","created_at":"2026-01-30T12:51:35.198315-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s1","title":"Create TypeScript types and Convex queries for extraction data","description":"Define TypeScript interfaces for extraction records including confidence scores per field. Create Convex query functions: getExtractionsByStatus, getExtractionsByAgent, getExtractionsWithFilters (combining status, confidence range, agent). Include pagination support with cursor-based queries. Types should include: ExtractionRecord, ExtractionField (with value, confidence, sourceQuote), FilterParams, PaginatedResult.\n\n**Context:** The dashboard needs well-typed data structures to display extractions with confidence scores. Convex queries enable real-time subscriptions so the dashboard updates automatically when new extractions complete.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getExtractionsByStatus returns correct records for each status. Test getExtractionsWithFilters correctly applies confidence range filter (e.g., min 0.5, max 0.8). Test pagination returns correct page size and next cursor. Test empty results return proper structure.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:17.952251-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:17.952251-06:00","labels":["backend","convex","dashboard","database","frontend","integration","react"],"dependencies":[{"issue_id":"test-e4t4s1","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:49:18.507467-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s2","title":"Build ExtractionCard component with confidence badges and expandable fields","description":"Create reusable ExtractionCard using shadcn/ui Card. Display extracted fields with color-coded confidence badges: green (\u003e0.8), yellow (0.5-0.8), red (\u003c0.5). Implement expandable/collapsible sections using shadcn Collapsible for each field showing the source quote from transcript. Include link to original transcript. Show agent name, extraction timestamp, overall status badge.\n\n**Context:** This is the core visual element of the dashboard. Users need to quickly scan confidence levels visually and drill down to see exactly what transcript text produced each extraction, building trust in the AI.\n\n**Testing Requirements:**\n- **Unit Tests:** Test confidence badge renders correct color for values 0.9 (green), 0.6 (yellow), 0.3 (red). Test boundary values 0.8 and 0.5. Test expandable section shows/hides source quote. Test transcript link has correct href. Test all field types render properly.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:19.602104-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:19.602104-06:00","labels":["backend","data-table","frontend","react","scheduling","ui"],"dependencies":[{"issue_id":"test-e4t4s2","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:49:20.386667-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s2","depends_on_id":"test-e4t4s1","type":"blocks","created_at":"2026-01-30T12:51:35.621622-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s3","title":"Implement filter sidebar with status chips, confidence slider, and agent dropdown","description":"Build FilterSidebar component with: status filter as selectable chips (pending, reviewed, rejected, approved), confidence range slider using shadcn Slider (0-1 range, dual handles for min/max), agent dropdown using shadcn Select populated from Convex query. Filters should update URL query params for shareability. Use debounced updates for slider to prevent excessive queries.\n\n**Context:** Team leads need to quickly filter to low-confidence extractions requiring review. Agents need to see only their own extractions. URL-based filters let users bookmark or share specific views with their team.\n\n**Testing Requirements:**\n- **Unit Tests:** Test status chip selection updates filter state correctly. Test confidence slider respects min/max boundaries. Test debounce delays query updates by expected interval. Test URL params update on filter change. Test filter reset clears all selections.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:20.984751-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:20.984751-06:00","labels":["ai","backend","forms","frontend","react","sms","team-management","ui"],"dependencies":[{"issue_id":"test-e4t4s3","depends_on_id":"test-e4t4s2","type":"blocks","created_at":"2026-01-30T12:09:45.532147-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s3","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:49:21.481823-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s3","depends_on_id":"test-e4t4s1","type":"blocks","created_at":"2026-01-30T12:51:36.060769-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s4","title":"Assemble dashboard page with Convex subscription, pagination, and loading states","description":"Create the extraction review dashboard page at /dashboard/extractions/review. Wire FilterSidebar to Convex queries using useQuery with real-time subscriptions. Render ExtractionCard list with proper loading skeletons. Implement pagination controls (previous/next) using cursor from query results. Handle empty states with helpful messaging. Add page header with extraction count stats.\n\n**Context:** This brings all components together into a functional dashboard. Real-time Convex subscriptions mean when an extraction completes, it appears instantly without refresh - critical for monitoring active debriefs.\n\n**Testing Requirements:**\n- **Unit Tests:** Test loading state shows skeleton cards. Test empty state shows correct message. Test pagination controls disabled at first/last page. Test Convex subscription updates list when data changes. Test filter changes trigger new query with correct params.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:22.47194-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:22.47194-06:00","labels":["backend","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e4t4s4","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:49:22.717571-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s4","depends_on_id":"test-e4t4s2","type":"blocks","created_at":"2026-01-30T12:51:36.294196-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s4","depends_on_id":"test-e4t4s3","type":"blocks","created_at":"2026-01-30T12:51:36.565585-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5","title":"Create manual edit/correction interface with audit trail","description":"Build inline editing interface for extracted fields. Users can correct any field, add notes explaining correction, and mark as reviewed. All edits tracked in audit history showing who changed what and when. Edited fields show 'manually corrected' indicator.\n\n**Context:** Even with AI extraction, humans need final authority over CRM data. The correction interface lets team leads fix errors while building training data for future improvements. Audit trail is essential for accountability - brokerages need to know who approved what data going into FUB.\n\n**Testing Requirements:**\n- **Unit Tests:** Edit history append logic, status transition on correction, optimistic update handling\n- **Integration Tests:** Full edit flow with Convex mutation, concurrent edits handling, edit history display, Clerk user attribution in audit trail","design":"Use shadcn/ui inline edit pattern with edit icon hover state. On save, append to editHistory array with userId, timestamp, previousValue, newValue, correctionNote. Update status to 'reviewed' after manual correction. Show edit history in expandable section. Optimistic updates with Convex mutations. Consider keyboard shortcuts for power users reviewing many extractions.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:32.865565-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:32.865565-06:00","labels":["backend","dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e4t5","depends_on_id":"test-e4t3","type":"blocks","created_at":"2026-01-30T12:09:45.986452-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:47:33.119439-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5","depends_on_id":"test-e4t4","type":"blocks","created_at":"2026-01-30T12:51:36.807294-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s1","title":"Create TypeScript types for edit history and correction tracking","description":"Define types for EditHistoryEntry (userId, timestamp, fieldName, previousValue, newValue, correctionNote), ReviewStatus, and update ExtractionResult type to include editHistory array and reviewedBy/reviewedAt fields. Add these to the existing extraction schema in Convex.\n\n**Context:** Strong typing ensures consistent audit trail structure across the codebase. These types will be used by the UI, mutations, and queries to maintain data integrity for accountability tracking.\n\n**Testing Requirements:**\n- **Unit Tests:** Test type exports are accessible, verify EditHistoryEntry has all required fields, test optional vs required field constraints","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:49:23.485806-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:23.485806-06:00","labels":["backend","demo","frontend","messaging","security","settings","types"],"dependencies":[{"issue_id":"test-e4t5s1","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:49:23.849136-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s2","title":"Implement Convex mutation for field corrections with audit logging","description":"Create 'correctExtractionField' mutation that accepts extractionId, fieldName, newValue, correctionNote. Mutation should: get current field value, append to editHistory array with full context, update field to new value, set status to 'reviewed', update reviewedBy/reviewedAt. Use optimistic updates pattern. Add 'getEditHistory' query to fetch history for an extraction.\n\n**Context:** The mutation is the core of accountability - every change is permanently logged with who/what/when/why. Optimistic updates give snappy UX while Convex handles sync.\n\n**Testing Requirements:**\n- **Unit Tests:** Test mutation creates correct editHistory entry, test previousValue is captured accurately, test status updates to 'reviewed', test correctionNote is stored, test getEditHistory returns entries in chronological order, test unauthorized user cannot correct","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:24.258457-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:24.258457-06:00","labels":["backend","convex","dashboard","demo","email","frontend","integration","real-time"],"dependencies":[{"issue_id":"test-e4t5s2","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:49:24.543929-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s2","depends_on_id":"test-e4t5s1","type":"blocks","created_at":"2026-01-30T12:51:37.093278-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s3","title":"Build inline edit component with shadcn/ui patterns","description":"Create EditableField component using shadcn/ui Input and Button. Shows field value with edit icon on hover. Click to enter edit mode with input + save/cancel buttons. On save, calls correctExtractionField mutation with optional correction note (small textarea that appears). Shows 'manually corrected' badge if field has edit history. Add keyboard shortcuts: Enter to save, Escape to cancel, Tab to move to next field.\n\n**Context:** Power users reviewing dozens of extractions need efficient editing. Inline editing with keyboard shortcuts lets team leads blast through corrections without reaching for the mouse.\n\n**Testing Requirements:**\n- **Unit Tests:** Test edit mode toggle, test save calls mutation with correct args, test cancel reverts to original, test keyboard shortcuts work (Enter/Escape/Tab), test 'manually corrected' badge appears when editHistory exists, test correction note is passed to mutation","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:24.792137-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:24.792137-06:00","labels":["backend","component","dashboard","demo","external-api","frontend","permissions","ux"],"dependencies":[{"issue_id":"test-e4t5s3","depends_on_id":"test-e4t5s1","type":"blocks","created_at":"2026-01-30T11:11:01.672999-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s3","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:49:25.153987-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s3","depends_on_id":"test-e4t5s2","type":"blocks","created_at":"2026-01-30T12:51:37.351297-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s4","title":"Add expandable edit history section with timeline view","description":"Create EditHistoryPanel component that shows collapsible audit trail below extraction fields. Use shadcn/ui Collapsible and Timeline-style layout showing: timestamp, user who made change, field changed, previous→new value diff, correction note. Sort newest first. Show 'No edits' placeholder if history empty. Wire into extraction detail view.\n\n**Context:** Brokerage owners need to audit who changed what data before it goes to FUB. The timeline view makes it easy to trace accountability and spot patterns in corrections that could improve AI extraction.\n\n**Testing Requirements:**\n- **Unit Tests:** Test renders empty state when no history, test renders multiple entries in correct order, test expand/collapse toggle works, test each entry shows all required fields (user, timestamp, field, values, note), test diff display shows previous and new values clearly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:25.789444-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:25.789444-06:00","labels":["backend","component","demo","documentation","frontend","integration","testing","ux"],"dependencies":[{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5s2","type":"blocks","created_at":"2026-01-30T11:11:01.917686-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5s1","type":"blocks","created_at":"2026-01-30T12:09:46.610707-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:49:26.043008-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5s3","type":"blocks","created_at":"2026-01-30T12:51:37.58724-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t6","title":"Verify extraction pipeline end-to-end with test scenarios","description":"Create comprehensive test suite with realistic real estate conversation transcripts covering: clear hot lead, lukewarm with timeline, cold lead with objections, multi-property discussion, and garbled/unclear conversation. Verify extraction accuracy, confidence scoring calibration, fallback triggering, and dashboard display.\n\n**Context:** Before this epic is complete, we need confidence that the extraction pipeline handles real-world variety. Test scenarios based on actual agent conversation patterns ensure the system works for the messy reality of real estate sales calls, not just clean demo scripts.\n\n**Testing Requirements:**\n- **Unit Tests:** Test fixture loading, accuracy calculation against ground truth\n- **Integration Tests:** Full pipeline test with each scenario type, verify dashboard correctly displays all test extractions, confirm fallback triggers appropriately on ambiguous transcripts","design":"Create test transcript fixtures in tests/ directory. Include edge cases: agent discusses personal life mixed with business, lead contradicts themselves, multiple follow-up types mentioned. Measure extraction accuracy against manually labeled ground truth. Verify confidence scores correlate with actual accuracy. Document any systematic extraction failures for future improvement.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:33.729717-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:33.729717-06:00","labels":["integration","qa","testing"],"dependencies":[{"issue_id":"test-e4t6","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:47:34.329269-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t6","depends_on_id":"test-e4t2","type":"blocks","created_at":"2026-01-30T12:51:37.880197-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t6","depends_on_id":"test-e4t3","type":"blocks","created_at":"2026-01-30T12:51:38.212467-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t6","depends_on_id":"test-e4t4","type":"blocks","created_at":"2026-01-30T12:51:38.447341-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t6","depends_on_id":"test-e4t5","type":"blocks","created_at":"2026-01-30T12:51:38.745284-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t6s1","title":"Create test transcript fixtures for all conversation scenarios","description":"Create realistic test transcript fixtures in tests/fixtures/ directory covering: (1) clear hot lead with urgency and specific property interest, (2) lukewarm lead with vague 6-month timeline, (3) cold lead with price objections and no commitment, (4) multi-property discussion with comparisons, (5) garbled/unclear conversation with interruptions and topic changes. Include edge cases: agent personal life mixed with business, lead contradicts themselves (says 'maybe spring' then 'definitely by summer'), multiple follow-up types mentioned. Each fixture should have manually labeled ground truth extraction data for comparison.\n\n**Context:** Real estate conversations are messy - agents chat about weekend plans, leads change their minds mid-sentence, multiple properties get discussed. These fixtures represent actual call patterns, not clean demos, ensuring the extraction pipeline handles reality.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify each fixture file loads correctly, contains required fields (transcript text, ground_truth object with expected extractions), validate ground_truth schema matches ExtractionResult type","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:26.377547-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:26.377547-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e4t6s1","depends_on_id":"test-e4t6","type":"parent-child","created_at":"2026-01-30T12:49:26.580055-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t6s2","title":"Implement extraction accuracy measurement against ground truth","description":"Create test utilities that compare extraction pipeline output against manually labeled ground truth. Implement field-level accuracy metrics: exact match for categorical fields (lead_temperature, follow_up_type), fuzzy match for text fields (property_interests, objections), range comparison for numeric/date fields (timeline estimates). Calculate overall accuracy score and per-field accuracy breakdown. Output detailed diff showing what was extracted vs expected.\n\n**Context:** Without measurable accuracy, we can't know if extraction improvements actually help. Field-level metrics reveal which extraction types need work - maybe we nail lead temperature but miss timelines.\n\n**Testing Requirements:**\n- **Unit Tests:** Test accuracy calculator with known inputs: perfect match returns 100%, complete miss returns 0%, partial matches return expected percentages. Test fuzzy text matching handles synonyms ('spring' matches 'March-May'), test date range comparison handles approximate matches","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:27.054223-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:27.054223-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e4t6s2","depends_on_id":"test-e4t6","type":"parent-child","created_at":"2026-01-30T12:49:27.294692-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t6s2","depends_on_id":"test-e4t6s1","type":"blocks","created_at":"2026-01-30T12:51:38.949534-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t6s3","title":"Run extraction pipeline against all fixtures and verify confidence calibration","description":"Create integration tests that run the full extraction pipeline against all test fixtures. Verify: (1) extraction accuracy meets minimum thresholds per scenario type, (2) confidence scores correlate with actual accuracy (high confidence extractions should be more accurate than low confidence), (3) fallback triggers fire appropriately for garbled/unclear scenarios, (4) no crashes or unhandled errors on edge case inputs. Calculate confidence calibration metric (when pipeline says 90% confident, is it actually ~90% accurate?).\n\n**Context:** Confidence scores are only useful if they're calibrated - a system that's always 90% confident but only 60% accurate is useless for routing decisions. This test validates the confidence scoring actually means something.\n\n**Testing Requirements:**\n- **Unit Tests:** Test pipeline processes each fixture without throwing, verify confidence scores are in valid range (0-1), test correlation calculation between confidence and accuracy, verify fallback triggers on garbled fixture but not on clear hot lead fixture","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:27.570766-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:27.570766-06:00","labels":["backend","integration","testing"],"dependencies":[{"issue_id":"test-e4t6s3","depends_on_id":"test-e4t6","type":"parent-child","created_at":"2026-01-30T12:49:27.760513-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t6s3","depends_on_id":"test-e4t6s2","type":"blocks","created_at":"2026-01-30T12:51:39.175171-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t6s4","title":"Document systematic extraction failures and verify dashboard display","description":"Analyze test results to identify systematic extraction failures (patterns where pipeline consistently underperforms). Document findings in tests/EXTRACTION_ACCURACY.md with: accuracy metrics per scenario type, confidence calibration analysis, known limitations (e.g., 'struggles with contradictory statements'), recommendations for future improvement. Also verify extraction results display correctly in dashboard - run dev server and manually check that test fixture extractions render properly in the activity feed and call detail views.\n\n**Context:** Shipping with known limitations documented is better than shipping blind. This documentation helps future debugging and sets expectations for what the extraction can/can't handle reliably. Dashboard verification ensures the full user-facing flow works.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify EXTRACTION_ACCURACY.md is created with required sections (metrics, calibration, limitations, recommendations). Manual verification: start dev server, navigate to dashboard, confirm extraction data from test scenarios displays without errors","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:28.13474-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:28.13474-06:00","labels":["documentation","frontend","testing"],"dependencies":[{"issue_id":"test-e4t6s4","depends_on_id":"test-e4t6","type":"parent-child","created_at":"2026-01-30T12:49:29.945384-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t6s4","depends_on_id":"test-e4t6s3","type":"blocks","created_at":"2026-01-30T12:51:39.890303-06:00","created_by":"David Habedank"}]}
{"id":"test-e5","title":"Follow Up Boss CRM Integration","description":"Connect to Follow Up Boss API for bidirectional sync - reading leads for context and writing notes, tasks, stage updates, and field changes back to the CRM.\n\n**Context:** RealHerd only delivers value if data reaches the CRM. Follow Up Boss is the primary integration target. Agents shouldn't need to touch FUB - RealHerd handles the data entry automatically.\n\n**Testing Requirements:**\n- **Unit Tests:** FUB API request formatting, lead matching algorithm, note body formatting\n- **Integration Tests:** FUB API authentication, CRUD operations, rate limit handling, error recovery\n- **Type Tests:** FUB API response types, CRMSyncLog validation\n- **E2E Tests:** Complete debrief results in FUB note + lead update + task creation","acceptance_criteria":"- FUB API key configuration in org settings with connection testing\n- Lead matching works (by phone, email, name)\n- Notes created with formatted summary following FUB conventions\n- Lead fields updated (stage, temperature via custom fields)\n- Tasks created for follow-ups with due dates\n- Sync status displays in dashboard (pending, syncing, synced, failed)\n- Sync error handling with retry logic\n- CRM sync logs for debugging","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:47:19.01958-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:19.01958-06:00","labels":["automation","calendar","crm","integration","sms","sync","triggers"],"dependencies":[{"issue_id":"test-e5","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:46.977305-06:00","created_by":"David Habedank"},{"issue_id":"test-e5","depends_on_id":"test-e3","type":"blocks","created_at":"2026-01-30T12:09:47.16801-06:00","created_by":"David Habedank"},{"issue_id":"test-e5","depends_on_id":"test-e4","type":"blocks","created_at":"2026-01-30T12:51:40.131774-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1","title":"Implement FUB API client with authentication","description":"Create a Follow Up Boss API client wrapper with API key authentication, rate limiting, and error handling. Include methods for core operations: GET/POST people, notes, tasks, and custom fields.\n\n**Context:** FUB API key is per-organization. This client is the foundation for all CRM operations - if it's unreliable, agents lose trust in RealHerd. Must handle FUB's rate limits (120 requests/min) gracefully.\n\n**Testing Requirements:**\n- **Unit Tests:** API client methods, auth header injection, rate limit detection, error parsing, retry logic with backoff calculations\n- **Integration Tests:** Actual FUB API calls with test credentials - verify auth, test rate limit behavior, validate response parsing","design":"Create a FubClient class in lib/integrations/fub/. Use axios with interceptors for auth headers and rate limit handling. Implement exponential backoff for 429 responses. Store API key encrypted in org settings (Convex). Include connection test method that fetches current user.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:35.303214-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:35.303214-06:00","labels":["api","backend","integration","sms","telnyx","webhook"],"dependencies":[{"issue_id":"test-e5t1","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:47:36.670915-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s1","title":"Create FUB API types and configuration schema","description":"Define TypeScript interfaces for FUB API responses (Person, Note, Task, CustomField, User, ApiError). Create configuration types for FubClientConfig (apiKey, baseUrl, rateLimitPerMinute). Add Zod schemas for runtime validation of API responses.\n\n**Context:** Strong typing prevents runtime errors and makes the client self-documenting. FUB's API has specific response shapes that we need to validate - malformed data from FUB shouldn't crash agents.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Zod schemas parse valid FUB responses correctly, test schemas reject malformed responses with descriptive errors, test type exports are accessible from lib/integrations/fub","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:31.181774-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:31.181774-06:00","labels":["backend","convex","database","real-time","types"],"dependencies":[{"issue_id":"test-e5t1s1","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:49:31.593841-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s2","title":"Implement FubClient class with axios interceptors","description":"Create FubClient class in lib/integrations/fub/client.ts. Initialize axios instance with base URL (https://api.followupboss.com/v1). Add request interceptor that adds X-System, X-System-Key headers from config. Add response interceptor for standard error formatting. Implement private _request method that wraps axios calls with Zod validation.\n\n**Context:** Interceptors ensure every request is authenticated and every response is validated. The _request method is the single point of truth for API calls - makes debugging and rate limiting easier.\n\n**Testing Requirements:**\n- **Unit Tests:** Test constructor validates config, test request interceptor adds correct headers (mock axios), test response interceptor formats errors consistently, test _request validates response against provided schema","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:32.110544-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:32.110544-06:00","labels":["api","backend","filtering","frontend","react","security"],"dependencies":[{"issue_id":"test-e5t1s2","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:49:32.940061-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s2","depends_on_id":"test-e5t1s1","type":"blocks","created_at":"2026-01-30T12:51:40.420415-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s3","title":"Add rate limiting and exponential backoff","description":"Implement token bucket rate limiter (120 requests/minute default). Add retry logic with exponential backoff for 429 responses (initial delay 1s, max 3 retries, backoff multiplier 2x). Track rate limit headers from FUB responses (X-RateLimit-Remaining, X-RateLimit-Reset). Add waitForCapacity() method that delays requests when approaching limit.\n\n**Context:** FUB rate limits at 120 req/min. If we blast the API during a sync, we'll get blocked and agents will see stale data. Proactive rate limiting keeps us under the limit; backoff handles edge cases.\n\n**Testing Requirements:**\n- **Unit Tests:** Test rate limiter allows 120 requests then blocks, test exponential backoff delays correctly (1s, 2s, 4s), test 429 response triggers retry with backoff, test rate limit header parsing updates internal state, test waitForCapacity resolves after token replenishment","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:34.090552-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:34.090552-06:00","labels":["api","backend","business-logic","frontend","performance","react","ui"],"dependencies":[{"issue_id":"test-e5t1s3","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:49:34.626592-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s3","depends_on_id":"test-e5t1s2","type":"blocks","created_at":"2026-01-30T12:51:40.751809-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s4","title":"Implement CRUD methods and connection test","description":"Add public methods: getPeople(filters?), getPerson(id), createPerson(data), updatePerson(id, data), getNotes(personId), createNote(personId, data), getTasks(filters?), createTask(data), getCustomFields(), getCurrentUser(). Implement testConnection() that calls getCurrentUser() and returns {success: boolean, user?: User, error?: string}.\n\n**Context:** These methods are what agents actually call. getCurrentUser/testConnection validates the API key works before we try to sync data - catches bad credentials early rather than failing mid-import.\n\n**Testing Requirements:**\n- **Unit Tests:** Test each CRUD method calls correct endpoint with correct HTTP method, test getPeople passes filter params correctly, test createPerson validates input before sending, test testConnection returns success with valid user on 200, test testConnection returns error message on 401/403","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:35.27137-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:35.27137-06:00","labels":["backend","integration","performance","security","testing"],"dependencies":[{"issue_id":"test-e5t1s4","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:49:35.603199-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s4","depends_on_id":"test-e5t1s3","type":"blocks","created_at":"2026-01-30T12:51:40.989387-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s5","title":"Integration test with FUB sandbox and export module","description":"Write integration tests using FUB sandbox API (or mock server if no sandbox). Test full flow: testConnection → getPeople → createNote → verify note appears. Export FubClient and types from lib/integrations/fub/index.ts. Add README.md with usage examples and rate limit documentation.\n\n**Context:** Unit tests with mocks are necessary but not sufficient - we need to verify the real FUB API accepts our requests. README ensures other devs (and LLM agents) can use the client correctly.\n\n**Testing Requirements:**\n- **Unit Tests:** Test exports are accessible (import { FubClient } from 'lib/integrations/fub'), test README examples are syntactically valid TypeScript, integration test full CRUD flow against FUB sandbox/mock","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:35.916559-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:35.916559-06:00","labels":["backend","documentation","integration","testing"],"dependencies":[{"issue_id":"test-e5t1s5","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:49:36.294296-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s5","depends_on_id":"test-e5t1s4","type":"blocks","created_at":"2026-01-30T12:51:41.225078-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2","title":"Build FUB API configuration UI with connection testing","description":"Create organization settings page for FUB API key entry with real-time connection validation. Show connection status, test results, and clear error messages for common issues (invalid key, expired key, wrong permissions).\n\n**Context:** Brokerage owners will configure this once during onboarding. Bad UX here means support tickets. Clear feedback on connection status prevents 'is it working?' anxiety.\n\n**Testing Requirements:**\n- **Unit Tests:** API key masking logic, form validation, status display component states\n- **Integration Tests:** Full flow: enter key → test connection → save → reload page shows connected status","design":"Add FUB settings section to org settings page. Mask API key after save (show last 4 chars). 'Test Connection' button that calls FUB /me endpoint and displays user name on success. Store connection status timestamp. Use Convex mutation for secure key storage.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:37.043439-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:37.043439-06:00","labels":["dashboard","frontend","integration","settings","ui"],"dependencies":[{"issue_id":"test-e5t2","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:47:37.386452-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2","depends_on_id":"test-e5t1","type":"blocks","created_at":"2026-01-30T12:51:41.450412-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s1","title":"Create FUB settings schema and Convex mutation for secure key storage","description":"Define TypeScript types for FUB configuration (apiKey, connectionStatus, lastTestedAt, connectedUserName). Create Convex table schema for organization FUB settings. Implement mutation to securely store API key (the key itself should be stored, but masked in queries - only return last 4 chars to client). Include validation that key is non-empty string.\n\n**Context:** Secure storage is critical - API keys grant full CRM access. Schema design affects all downstream features. Masking protects keys from accidental exposure in logs/UI.\n\n**Testing Requirements:**\n- **Unit Tests:** Test mutation saves key correctly, test query returns masked key (last 4 chars only), test validation rejects empty strings, test upsert behavior (update existing vs create new)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:36.831527-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:36.831527-06:00","labels":["backend","component","convex","forms","frontend","security","ui"],"dependencies":[{"issue_id":"test-e5t2s1","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:49:37.156347-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s2","title":"Implement FUB connection test action that calls /me endpoint","description":"Create Convex action (not mutation - needs HTTP) that takes org ID, retrieves stored API key, calls FUB /me endpoint to validate. Return success with user name/email on 200, or structured error for common failures: 401 (invalid/expired key), 403 (wrong permissions), 429 (rate limited), network errors. Update org's connectionStatus and lastTestedAt timestamp on test.\n\n**Context:** This is the feedback loop that prevents support tickets. Clear error categorization lets UI show actionable messages like 'Your API key has expired' vs generic 'connection failed'.\n\n**Testing Requirements:**\n- **Unit Tests:** Test successful connection returns user info, test 401 returns 'invalid_key' error type, test 403 returns 'insufficient_permissions', test 429 returns 'rate_limited', test network error handling, test timestamp updates on both success and failure","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:37.574136-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:37.574136-06:00","labels":["api-integration","backend","component","convex","drag-drop","frontend","settings","ui"],"dependencies":[{"issue_id":"test-e5t2s2","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:49:37.84258-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2s2","depends_on_id":"test-e5t2s1","type":"blocks","created_at":"2026-01-30T12:51:41.66638-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s3","title":"Build FUB settings UI component with masked input and test button","description":"Create FUB settings section for org settings page. Include: password-type input for API key (shows dots while typing), display of masked saved key (****XXXX format), prominent 'Test Connection' button, connection status indicator (untested/connected/failed), last tested timestamp, connected user name on success, error messages mapped to user-friendly text. Use optimistic UI for better UX.\n\n**Context:** This is the first thing brokerage owners interact with during setup. Anxiety-reducing UI (clear status, immediate feedback) builds trust. Masked display prevents shoulder-surfing.\n\n**Testing Requirements:**\n- **Unit Tests:** Test input masks characters, test saved key displays last 4 chars only, test button triggers connection test, test success state shows user name, test error states show appropriate messages for each error type, test loading state during test","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:39.529432-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:39.529432-06:00","labels":["analytics","api-integration","auth","frontend","permissions","react","ui"],"dependencies":[{"issue_id":"test-e5t2s3","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:49:39.810611-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2s3","depends_on_id":"test-e5t2s1","type":"blocks","created_at":"2026-01-30T12:51:41.910342-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2s3","depends_on_id":"test-e5t2s2","type":"blocks","created_at":"2026-01-30T12:51:42.122109-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s4","title":"Wire up component to org settings page and verify end-to-end flow","description":"Integrate FUB settings component into existing organization settings page. Ensure proper auth checks (only org admins can view/edit). Test full flow: enter key → save → see masked key → test connection → see status update. Verify key is not exposed in browser network tab responses. Run dev server and manually test with real FUB API key if available, or mock endpoint.\n\n**Context:** Integration testing catches issues that unit tests miss - auth middleware, data flow between components, real network behavior. This is the final quality gate before the feature ships.\n\n**Testing Requirements:**\n- **Unit Tests:** Test component renders in settings page, test non-admin cannot access, test full save→test→display flow works, verify network responses don't leak full API key","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:40.08476-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:40.08476-06:00","labels":["api","backend","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e5t2s4","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:49:40.374798-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2s4","depends_on_id":"test-e5t2s3","type":"blocks","created_at":"2026-01-30T12:51:42.344169-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3","title":"Implement lead matching service","description":"Create service to match RealHerd contacts to FUB people records using phone, email, and name. Handle multiple matches, no matches, and confidence scoring. Cache FUB person IDs on matched contacts.\n\n**Context:** Accurate matching is critical - wrong match means wrong agent gets the note. Phone is most reliable (FUB normalizes), then email, then name (fuzzy). Solo agents have cleaner data; team accounts may have duplicates.\n\n**Testing Requirements:**\n- **Unit Tests:** Phone normalization, email matching logic, name fuzzy matching algorithm, confidence scoring\n- **Integration Tests:** Match against real FUB test account with known people - verify correct matches for phone/email/name scenarios","design":"Search order: phone (exact) → email (exact) → name (fuzzy with Levenshtein). FUB search API: GET /people?phone=X or ?email=Y. For name, use ?q=name and score results. Store fub_person_id on contact record after match. Return confidence: high (phone/email), medium (name \u003e0.85), low (name \u003e0.6), none.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:37.767416-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:37.767416-06:00","labels":["backend","calendar","convex","fub-api","google-api","integration","matching"],"dependencies":[{"issue_id":"test-e5t3","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:47:37.956843-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3","depends_on_id":"test-e5t1","type":"blocks","created_at":"2026-01-30T12:51:42.567358-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s1","title":"Create TypeScript types for matching service","description":"Define interfaces for MatchResult (fub_person_id, confidence level, match_method), MatchConfidence enum (high, medium, low, none), and FUBPersonSearchResult. Include types for the matching service class with search methods.\n\n**Context:** Strong typing ensures confidence levels and match methods are consistent across the codebase. These types will be used by the matcher, the contact sync service, and for storing match results.\n\n**Testing Requirements:**\n- **Unit Tests:** Type compilation tests - ensure MatchResult requires all fields, MatchConfidence only allows valid values, test that match_method is typed to 'phone' | 'email' | 'name'","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:49:40.852725-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:40.852725-06:00","labels":["api","backend","database","security","types"],"dependencies":[{"issue_id":"test-e5t3s1","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:49:41.052593-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s2","title":"Implement FUB person search methods","description":"Add methods to FUB API client: searchByPhone(phone), searchByEmail(email), searchByName(name). Phone and email use exact match endpoints (GET /people?phone=X, ?email=Y). Name uses fuzzy search (GET /people?q=name). Handle empty results, multiple results, and API errors.\n\n**Context:** These are the building blocks for matching. FUB normalizes phone numbers so exact match works well. Email is also exact. Name search returns scored results that need post-processing.\n\n**Testing Requirements:**\n- **Unit Tests:** Test searchByPhone returns person on exact match, returns null on no match. Test searchByEmail same pattern. Test searchByName returns array of candidates. Test error handling for 401/429/500. Mock FUB API responses for each scenario.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:41.487645-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:41.487645-06:00","labels":["analytics","api","auth","backend","frontend","integration","oauth"],"dependencies":[{"issue_id":"test-e5t3s2","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:49:41.737077-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s2","depends_on_id":"test-e5t3s1","type":"blocks","created_at":"2026-01-30T12:51:42.811333-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s3","title":"Implement matching algorithm with confidence scoring","description":"Create LeadMatchingService class with match(contact) method. Search order: phone first (if present), then email (if present), then name (fuzzy). Use Levenshtein distance for name matching (\u003e0.85 = medium confidence, \u003e0.6 = low). Return MatchResult with fub_person_id, confidence, and match_method. Handle multiple matches by preferring highest confidence.\n\n**Context:** This is the core matching logic. Phone/email matches are high confidence because they're exact. Name matching is fuzzy and needs scoring. Wrong matches mean wrong agent gets the note, so conservative matching is better than false positives.\n\n**Testing Requirements:**\n- **Unit Tests:** Test phone match returns high confidence. Test email match returns high confidence when phone absent. Test name match with Levenshtein \u003e0.85 returns medium. Test name match 0.6-0.85 returns low. Test no match returns confidence=none. Test search order (phone tried first even when all fields present). Test multiple name matches picks highest score.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:44.586652-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:44.586652-06:00","labels":["algorithm","backend","components","frontend","integration","permissions","ux"],"dependencies":[{"issue_id":"test-e5t3s3","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:49:45.019913-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s3","depends_on_id":"test-e5t3s1","type":"blocks","created_at":"2026-01-30T12:51:43.049971-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s3","depends_on_id":"test-e5t3s2","type":"blocks","created_at":"2026-01-30T12:51:43.271146-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s4","title":"Add caching of matched FUB person IDs on contact records","description":"After successful match, store fub_person_id on the RealHerd contact record. Add database field if needed. Skip matching for contacts that already have fub_person_id cached. Add method to clear cached ID if re-matching needed.\n\n**Context:** Caching avoids repeated API calls and ensures consistent matching over time. Once a contact is matched, we shouldn't re-match on every sync - that wastes API quota and could cause inconsistencies if FUB data changes.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that match() stores fub_person_id on contact after successful match. Test that match() skips API calls when fub_person_id already cached. Test clearMatchCache() removes stored ID. Test that no-match result does not cache anything.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:45.955763-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:45.955763-06:00","labels":["backend","cron","database","frontend","integration","testing","ux"],"dependencies":[{"issue_id":"test-e5t3s4","depends_on_id":"test-e5t3s2","type":"blocks","created_at":"2026-01-30T12:09:50.709258-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s4","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:49:46.41951-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s4","depends_on_id":"test-e5t3s3","type":"blocks","created_at":"2026-01-30T12:51:43.531637-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4","title":"Create FUB sync service for notes, tasks, and field updates","description":"Build sync service that writes call summaries as FUB notes, creates follow-up tasks with due dates, and updates lead fields (stage, custom fields for temperature/sentiment). Format notes following FUB conventions.\n\n**Context:** This is where RealHerd delivers its core value - automatic CRM data entry. Agents currently skip this manual work. Notes must be scannable (not walls of text). Tasks must have actionable titles and realistic due dates.\n\n**Testing Requirements:**\n- **Unit Tests:** Note formatting, task creation payload building, field update mapping, queue management\n- **Integration Tests:** Full sync flow - create note in test FUB account, verify formatting; create task, verify due date; update custom field","design":"FUB endpoints: POST /notes (personId, body, subject), POST /tasks (personId, description, dueAt, assignedTo), PUT /people/:id for fields. Note format: Header with call type/duration, bullet summary, next steps. Use FUB's custom field API to create/update temperature field. Queue syncs in Convex for reliability.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:38.314217-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:38.314217-06:00","labels":["backend","convex","integration","retry","sms","sync"],"dependencies":[{"issue_id":"test-e5t4","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:47:38.630416-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4","depends_on_id":"test-e5t1","type":"blocks","created_at":"2026-01-30T12:51:43.837068-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4","depends_on_id":"test-e5t3","type":"blocks","created_at":"2026-01-30T12:51:44.088413-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s1","title":"Create FUB sync queue schema and types in Convex","description":"Define Convex table schema for sync queue with fields: id, personId, syncType (note|task|fieldUpdate), payload (JSON), status (pending|processing|completed|failed), retryCount, createdAt, processedAt, errorMessage. Create TypeScript types for NotePayload, TaskPayload, and FieldUpdatePayload. Include validation for required fields.\n\n**Context:** Queue-based sync ensures reliability - if FUB is down or rate-limited, we don't lose data. This is the foundation for all sync operations.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation rejects invalid syncType, test payload type guards for each sync type, test queue item creation with all required fields","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:46.678762-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:46.678762-06:00","labels":["api-integration","backend","database","schema"],"dependencies":[{"issue_id":"test-e5t4s1","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:49:46.949298-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s2","title":"Implement FUB API write methods in existing client","description":"Add methods to FUB client: createNote(personId, subject, body), createTask(personId, description, dueAt, assignedTo?), updatePerson(personId, fields). Handle rate limiting (429) with exponential backoff. Parse FUB error responses for actionable messages. Include custom field API calls for temperature/sentiment fields.\n\n**Context:** These are the core write operations RealHerd uses to update the CRM. Error handling is critical - agents depend on this data being there.\n\n**Testing Requirements:**\n- **Unit Tests:** Test createNote with mock 200 response, test createTask with optional assignedTo, test updatePerson with partial fields, test 429 triggers retry logic, test 401/500 error parsing","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:47.371312-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:47.371312-06:00","labels":["admin-interface","api","backend","frontend","react","scheduling"],"dependencies":[{"issue_id":"test-e5t4s2","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:49:47.618196-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s2","depends_on_id":"test-e5t4s1","type":"blocks","created_at":"2026-01-30T12:51:44.311268-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s3","title":"Build note formatter with scannable FUB-style output","description":"Create formatCallNote(callData) that produces: header line with call type + duration, bullet-point summary (max 5 bullets), 'Next Steps' section if follow-ups exist. Keep total under 500 chars for scannability. Handle edge cases: no summary available, very short calls, failed calls.\n\n**Context:** Notes must be scannable - agents skim CRM data. Wall-of-text notes get ignored. This formatting directly impacts whether agents actually read the AI-generated content.\n\n**Testing Requirements:**\n- **Unit Tests:** Test header includes call type and duration formatted as 'Xm Ys', test bullet count never exceeds 5, test total length under 500 chars, test graceful handling of missing summary, test 'Next Steps' only appears when follow-ups exist","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:47.907761-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:47.907761-06:00","labels":["backend","dashboard","forms","frontend","notifications","sms","twilio"],"dependencies":[{"issue_id":"test-e5t4s3","depends_on_id":"test-e5t4s2","type":"blocks","created_at":"2026-01-30T11:11:05.887301-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s3","depends_on_id":"test-e5t4s1","type":"blocks","created_at":"2026-01-30T12:09:51.554314-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s3","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:49:48.393972-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s4","title":"Create sync service with queue processing and retry logic","description":"Build FUBSyncService class with methods: queueNote(callId, personId, noteData), queueTask(callId, personId, taskData), queueFieldUpdate(callId, personId, fields), processQueue(). Process queue items in order, update status on completion/failure, retry failed items up to 3 times with backoff. Wire to Convex mutation for queue operations.\n\n**Context:** This is the core service that makes automatic CRM updates reliable. Queue processing ensures nothing gets lost even during FUB outages or rate limiting.\n\n**Testing Requirements:**\n- **Unit Tests:** Test queueNote creates pending queue item, test processQueue calls correct FUB API method per syncType, test failed items increment retryCount, test items exceeding 3 retries marked as failed, test successful items marked completed with processedAt timestamp","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:48.792638-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:48.792638-06:00","labels":["backend","deployment","frontend","integration","monitoring","real-time","routing","testing"],"dependencies":[{"issue_id":"test-e5t4s4","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:49:49.31399-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s4","depends_on_id":"test-e5t4s1","type":"blocks","created_at":"2026-01-30T12:51:44.56562-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s4","depends_on_id":"test-e5t4s2","type":"blocks","created_at":"2026-01-30T12:51:44.830031-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s4","depends_on_id":"test-e5t4s3","type":"blocks","created_at":"2026-01-30T12:51:45.085474-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5","title":"Build sync status dashboard with error handling","description":"Add sync status to call/conversation views showing pending/syncing/synced/failed states. Display sync errors with retry button. Create CRM sync log page for debugging failed syncs. Implement retry logic with exponential backoff.\n\n**Context:** Team leads need to know data is actually reaching FUB. Failed syncs erode trust quickly. Clear status prevents 'did it sync?' questions. Sync logs help support debug issues without accessing customer FUB accounts.\n\n**Testing Requirements:**\n- **Unit Tests:** Status badge component, retry countdown logic, log filtering/sorting\n- **Integration Tests:** Trigger sync → verify status updates in real-time; simulate failure → verify retry behavior and log entry","design":"Add sync_status field to conversations (pending → syncing → synced/failed). Show icon badge on conversation cards. Failed state shows error message + retry button. Sync log table: timestamp, conversation_id, operation type, status, error details. Auto-retry failed syncs 3x with 1min/5min/30min delays.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:39.034642-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:39.034642-06:00","labels":["backend","dashboard","frontend","monitoring","sms","telnyx"],"dependencies":[{"issue_id":"test-e5t5","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:47:39.427488-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5","depends_on_id":"test-e5t4","type":"blocks","created_at":"2026-01-30T12:51:45.332216-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s1","title":"Add sync status field and database migrations","description":"Add sync_status enum field to conversations table with values: pending, syncing, synced, failed. Add sync_error text field for error messages. Add sync_attempts integer and last_sync_at timestamp. Create sync_logs table with columns: id, conversation_id, operation_type, status, error_details, created_at. Run migrations and verify schema.\n\n**Context:** Database foundation needed before any UI can display sync status. The sync_logs table enables the debugging page for support.\n\n**Testing Requirements:**\n- **Unit Tests:** Test migration applies cleanly, test sync_status enum accepts only valid values, test sync_logs foreign key to conversations, test default sync_status is 'pending'","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:49.587367-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:49.587367-06:00","labels":["backend","database","dependencies","sms","types"],"dependencies":[{"issue_id":"test-e5t5s1","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:49:49.802442-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s2","title":"Implement sync status UI components with badges and retry button","description":"Create SyncStatusBadge component showing pending (gray), syncing (blue spinner), synced (green check), failed (red x) states. Add badge to conversation cards in list views. For failed state, show error message tooltip and retry button. Wire retry button to trigger manual sync attempt.\n\n**Context:** Visual feedback is critical - team leads need at-a-glance confirmation that data reached FUB. Retry button gives users agency when syncs fail.\n\n**Testing Requirements:**\n- **Unit Tests:** Test SyncStatusBadge renders correct icon/color for each status, test retry button onClick handler fires, test error message displays in tooltip for failed state, test loading state during retry","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:50.046041-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:50.046041-06:00","labels":["backend","dashboard","frontend","security","ui"],"dependencies":[{"issue_id":"test-e5t5s2","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:49:50.228851-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s2","depends_on_id":"test-e5t5s1","type":"blocks","created_at":"2026-01-30T12:51:45.597592-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s3","title":"Build CRM sync log page for debugging","description":"Create /admin/sync-logs page with filterable table showing: timestamp, conversation link, operation type (create_note, update_contact, etc.), status, error details. Add filters for status (all/failed/success), date range, and search by conversation. Include pagination for large datasets. Add 'Retry All Failed' bulk action button.\n\n**Context:** Support needs this page to debug sync issues without accessing customer FUB accounts. Reduces support ticket resolution time significantly.\n\n**Testing Requirements:**\n- **Unit Tests:** Test table renders sync log entries correctly, test filters update query params, test pagination controls, test bulk retry action triggers for selected failed items, test empty state when no logs","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:50.840219-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:50.840219-06:00","labels":["admin","backend","export","frontend","integration","routing","sms"],"dependencies":[{"issue_id":"test-e5t5s3","depends_on_id":"test-e5t5s2","type":"blocks","created_at":"2026-01-30T12:09:53.227136-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s3","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:49:51.161785-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s3","depends_on_id":"test-e5t5s1","type":"blocks","created_at":"2026-01-30T12:51:45.930383-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s4","title":"Implement exponential backoff retry logic for failed syncs","description":"Create SyncRetryService that handles automatic retries with exponential backoff: 1st retry at 1 min, 2nd at 5 min, 3rd at 30 min. Track sync_attempts count. After 3 failures, mark as permanently failed and stop retrying. Log each attempt to sync_logs table. Implement manual retry that resets attempt counter. Add background job/cron to process pending retries.\n\n**Context:** Auto-retry prevents temporary FUB outages from requiring manual intervention. Exponential backoff prevents hammering a down service. 3-strike limit prevents infinite retry loops.\n\n**Testing Requirements:**\n- **Unit Tests:** Test retry delays match 1/5/30 minute schedule, test sync_attempts increments on each failure, test status changes to permanent failure after 3 attempts, test manual retry resets counter, test successful sync clears retry queue, test sync_log entry created for each attempt","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:51.451598-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:51.451598-06:00","labels":["backend","e2e","frontend","integration","pdf","testing"],"dependencies":[{"issue_id":"test-e5t5s4","depends_on_id":"test-e5t5s3","type":"blocks","created_at":"2026-01-30T12:09:53.463051-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s4","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:49:51.645668-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s4","depends_on_id":"test-e5t5s1","type":"blocks","created_at":"2026-01-30T12:51:46.193972-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t6","title":"Create broker configuration UI for call triggering settings","description":"Build admin settings page for brokers to configure: auto-call delay after appointments, retry attempts count, retry intervals, SMS fallback toggle, and team-level overrides. Include sensible defaults.\n\n**Context:** Every brokerage has different rhythms. Some want calls 5 minutes after showings, others prefer 30. Broker configuration ensures RealHerd fits their workflow instead of imposing one.","design":"Settings page under broker admin section. Form with: delayMinutes (5-60), maxRetryAttempts (1-5), retryIntervals (array editor), enableSmsFallback (toggle). Store in brokerage settings. Support team-level overrides. Show preview of retry timeline based on settings.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:07.174848-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:38.495021-06:00","labels":["admin","frontend","settings","ui"],"dependencies":[{"issue_id":"test-e5t6","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:07.362237-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6","depends_on_id":"test-e5t3","type":"blocks","created_at":"2026-01-30T12:09:53.699155-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6","depends_on_id":"test-e5t4","type":"blocks","created_at":"2026-01-30T12:09:53.903954-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:38.495021-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t6s1","title":"Create call configuration TypeScript types and schema","description":"Define TypeScript interfaces for broker call configuration: CallTriggerSettings with delayMinutes (5-60), maxRetryAttempts (1-5), retryIntervals (number[]), enableSmsFallback (boolean). Create Zod validation schema for form validation. Define TeamOverride type that extends base settings with teamId. Add these to the brokerage settings model/schema.\n\n**Context:** Type-safe configuration ensures brokers can only set valid values. The retry intervals array needs special attention - it defines wait times between each retry attempt and must match maxRetryAttempts length.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:16.823019-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:18.509443-06:00","labels":["backend","testing","types"],"dependencies":[{"issue_id":"test-e5t6s1","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:17.584003-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:18.509443-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t6s2","title":"Build call settings form component with defaults","description":"Create CallSettingsForm component with: (1) delayMinutes number input with slider 5-60, default 15, (2) maxRetryAttempts dropdown 1-5, default 3, (3) retryIntervals dynamic array editor that adds/removes fields based on maxRetryAttempts, defaults [5,15,30] minutes, (4) enableSmsFallback toggle, default true. Use react-hook-form with Zod resolver. Include helpful labels explaining each setting's purpose.\n\n**Context:** Sensible defaults (15min delay, 3 retries at 5/15/30min, SMS fallback on) mean most brokers can use RealHerd without configuration. Power users can customize to match their brokerage rhythm.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:17.998702-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:18.354977-06:00","labels":["forms","frontend","testing"],"dependencies":[{"issue_id":"test-e5t6s2","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:18.174363-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6s2","depends_on_id":"test-e5t6s1","type":"blocks","created_at":"2026-01-30T12:09:54.102262-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:18.354977-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t6s3","title":"Add retry timeline preview visualization","description":"Create RetryTimelinePreview component that visualizes the call sequence based on current form values. Show: initial call at T+delayMinutes, each retry at calculated intervals, SMS fallback indicator if enabled. Use a horizontal timeline with icons (phone for calls, message for SMS). Update in real-time as user changes form values. Include example: 'After a showing at 2pm: First call at 2:15pm, retry at 2:20pm, retry at 2:35pm, SMS at 3:05pm'.\n\n**Context:** Brokers think in terms of 'when will my agent get called after a showing' - the preview translates abstract settings into a concrete example they can understand and validate against their workflow.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:18.419142-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:18.21352-06:00","labels":["frontend","ux","visualization"],"dependencies":[{"issue_id":"test-e5t6s3","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:18.57454-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6s3","depends_on_id":"test-e5t6s2","type":"blocks","created_at":"2026-01-30T12:09:54.341838-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:18.21352-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t6s4","title":"Implement settings page with team overrides and save functionality","description":"Create BrokerCallSettingsPage under /admin/settings/calls route. Include: (1) brokerage-wide default settings form, (2) team overrides section - list teams with 'Use custom settings' toggle, showing inherited values or override form, (3) Save button that persists to brokerage settings via API. Load existing settings on mount, show loading state. Display success/error toasts on save. Verify page renders correctly and settings persist across page refresh.\n\n**Context:** Team-level overrides let broker give autonomy to team leads - a luxury team might want longer delays while a high-volume team wants immediate calls. This flexibility without complexity is key to enterprise adoption.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:18.832686-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:18.081569-06:00","labels":["api","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e5t6s4","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:20.298357-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6s4","depends_on_id":"test-e5t6s3","type":"blocks","created_at":"2026-01-30T12:09:54.530969-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:18.081569-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t7","title":"Verify end-to-end call triggering flows","description":"Integration testing of all three trigger pathways (SMS keyword, dashboard button, calendar auto-call) through complete lifecycle including retries, SMS confirmations, and debrief creation. Verify broker settings are respected across all flows.\n\n**Context:** Call triggering is the entry point to RealHerd's core value. All three pathways must work reliably or agents lose trust. This verification ensures the system works as a cohesive whole.","design":"Create test scenarios document covering: SMS trigger happy path, SMS from unknown number, dashboard trigger with/without context, calendar auto-call with successful pickup, calendar auto-call with retries exhausted, broker settings respected. Use Convex test helpers for time manipulation in retry tests.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:07.539437-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:38.361849-06:00","labels":["integration","qa","testing"],"dependencies":[{"issue_id":"test-e5t7","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:07.682879-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7","depends_on_id":"test-e5t2","type":"blocks","created_at":"2026-01-30T12:09:54.701064-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7","depends_on_id":"test-e5t5","type":"blocks","created_at":"2026-01-30T12:09:54.920229-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7","depends_on_id":"test-e5t6","type":"blocks","created_at":"2026-01-30T12:09:55.123177-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:38.361849-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t7s1","title":"Create integration test scaffolding and test scenarios document","description":"Set up integration test file structure for call trigger flows. Create a test scenarios document (as code comments or separate .md) covering all test cases: SMS trigger happy path, SMS from unknown number, dashboard trigger with/without context, calendar auto-call with successful pickup, calendar auto-call with retries exhausted, broker settings respected. Configure Convex test helpers for time manipulation.\n\n**Context:** A clear test plan ensures comprehensive coverage of all trigger pathways. The scaffolding enables consistent test patterns across different trigger types.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:20.778843-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:17.850662-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s1","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:21.082091-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:17.850662-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t7s2","title":"Implement SMS trigger pathway integration tests","description":"Write integration tests for SMS keyword triggers: (1) Happy path - known agent sends keyword, call initiates, SMS confirmation sent. (2) Unknown number - SMS from non-registered number handled gracefully. (3) Verify broker settings (business hours, enabled keywords) are respected. Test complete lifecycle including debrief creation after call completion.\n\n**Context:** SMS is often the quickest trigger method for agents in the field. Must handle edge cases like unknown numbers without crashing or revealing system internals.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:21.576518-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:17.651326-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s2","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:21.922317-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s2","depends_on_id":"test-e5t7s1","type":"blocks","created_at":"2026-01-30T12:09:55.299857-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:17.651326-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t7s3","title":"Implement dashboard and calendar trigger integration tests","description":"Write integration tests for: (1) Dashboard button trigger with context data passed to call. (2) Dashboard trigger without context. (3) Calendar auto-call with successful pickup - verify call initiates at scheduled time, debrief created. (4) Calendar auto-call with retries - use Convex time manipulation to test retry scheduling at 5min/15min/30min intervals and behavior when retries exhausted.\n\n**Context:** Calendar auto-call with retry is the 'set it and forget it' experience that differentiates RealHerd. Time manipulation tests are critical to verify retry logic without waiting real minutes.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:22.223401-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:17.533717-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s3","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:22.355661-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s3","depends_on_id":"test-e5t7s1","type":"blocks","created_at":"2026-01-30T12:09:55.517635-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:17.533717-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e5t7s4","title":"Run full test suite and verify cross-pathway broker settings","description":"Execute all integration tests and verify: (1) All tests pass. (2) Broker-level settings (business hours, call limits, enabled features) are consistently enforced across SMS, dashboard, and calendar triggers. (3) Document any edge cases discovered. Fix any failing tests or implementation bugs found during verification.\n\n**Context:** Broker settings must work identically regardless of how a call is triggered. This final verification ensures the system works as a cohesive whole and agents can trust any trigger method.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:24.822002-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:17.332418-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s4","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:25.192567-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s4","depends_on_id":"test-e5t7s2","type":"blocks","created_at":"2026-01-30T12:09:55.711912-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s4","depends_on_id":"test-e5t7s3","type":"blocks","created_at":"2026-01-30T12:09:55.997619-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:17.332418-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e6","title":"Call Triggering \u0026 SMS Workflows","description":"Enable multiple ways to initiate debrief calls - SMS keyword trigger, dashboard button, and SMS confirmations after calls complete.\n\n**Context:** Agents need frictionless ways to trigger debriefs. SMS 'DEBRIEF' keyword is the easiest - no app needed. Dashboard button provides alternative. SMS confirmations close the loop and build trust.\n\n**Testing Requirements:**\n- **Unit Tests:** SMS keyword parsing, call scheduling logic, confirmation message formatting\n- **Integration Tests:** Telnyx SMS webhook to call initiation, scheduled call execution\n- **Type Tests:** SMS trigger payload types, ScheduledDebrief validation\n- **E2E Tests:** Text DEBRIEF, receive call, complete debrief, receive SMS confirmation","acceptance_criteria":"- SMS 'DEBRIEF' keyword triggers callback within 30 seconds\n- Dashboard 'Call Me Now' button initiates immediate call\n- Lead/property context can be selected before triggering call\n- SMS confirmation sent after call completes with summary\n- Call scheduling works ('call me in 10 minutes')\n- SMS fallback if call not answered after retries","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1440,"created_at":"2026-01-30T12:47:19.836038-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:19.836038-06:00","labels":["accountability","check-ins","scheduling","sms","triggers","ux"],"dependencies":[{"issue_id":"test-e6","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:56.181038-06:00","created_by":"David Habedank"},{"issue_id":"test-e6","depends_on_id":"test-e3","type":"blocks","created_at":"2026-01-30T12:09:56.378968-06:00","created_by":"David Habedank"},{"issue_id":"test-e6","depends_on_id":"test-e4","type":"blocks","created_at":"2026-01-30T12:09:56.5687-06:00","created_by":"David Habedank"},{"issue_id":"test-e6","depends_on_id":"test-e5","type":"blocks","created_at":"2026-01-30T12:51:46.418139-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1","title":"Implement SMS webhook endpoint for DEBRIEF keyword detection","description":"Create a Telnyx SMS webhook endpoint that receives incoming messages, detects the 'DEBRIEF' keyword (case-insensitive), identifies the agent by phone number, and queues a callback request.\n\n**Context:** SMS 'DEBRIEF' keyword is the lowest-friction way for agents to trigger debriefs - they don't need to open any app. This is critical for adoption since agents are often in their car or between showings. The 30-second callback window is a key UX promise.\n\n**Testing Requirements:**\n- **Unit Tests:** Keyword detection logic (case variations, with/without spaces), agent phone lookup, duplicate request filtering, cooldown enforcement\n- **Integration Tests:** Full webhook flow with Telnyx test messages, callback record creation, scheduler triggering","design":"Use Convex HTTP action for webhook. Store incoming SMS in a messages table. On DEBRIEF detection: lookup agent by phone, validate they exist and are active, create a pending_callback record with timestamp. Use Convex scheduler to trigger the actual call within 30 seconds. Handle edge cases: unknown number, agent not found, duplicate requests within cooldown window.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:40.079245-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:40.079245-06:00","labels":["backend","convex","database","sms","telnyx"],"dependencies":[{"issue_id":"test-e6t1","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:47:41.028261-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s1","title":"Create Telnyx SMS webhook HTTP action scaffold","description":"Create a Convex HTTP action at /api/webhooks/telnyx/sms that receives POST requests from Telnyx. Parse the incoming webhook payload to extract: from_number, to_number, message_body, message_id, timestamp. Log the raw payload for debugging. Return 200 OK immediately to acknowledge receipt (Telnyx requires fast response). Add the route to convex/http.ts.\n\n**Context:** Telnyx webhooks timeout quickly, so we need to acknowledge receipt immediately and process asynchronously. This scaffold establishes the entry point for all SMS-triggered features.\n\n**Testing Requirements:**\n- **Unit Tests:** Test payload parsing with mock Telnyx webhook body, test 200 response returned, test malformed payload handling returns 400, test missing required fields logged but still returns 200","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:51.878173-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:51.878173-06:00","labels":["backend","database","webhook"],"dependencies":[{"issue_id":"test-e6t1s1","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:49:52.055634-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s2","title":"Implement DEBRIEF keyword detection and agent lookup","description":"Add keyword detection logic: normalize message_body (trim, uppercase), check if it equals 'DEBRIEF' or starts with 'DEBRIEF' (to handle 'DEBRIEF please' etc). Create a query to lookup agent by phone number (normalize to E.164 format). Return agent record if found and status is 'active'. Handle cases: phone not found (log, no action), agent inactive (log, no action), agent found and active (proceed to callback creation).\n\n**Context:** Case-insensitive matching and phone normalization are critical - agents text from various devices with different formatting. Only active agents should trigger callbacks to prevent spam from former agents.\n\n**Testing Requirements:**\n- **Unit Tests:** Test 'DEBRIEF', 'debrief', 'Debrief', 'DEBRIEF please' all match, test 'DEBRIEFING' does not match, test phone lookup with +1, without +1, with dashes/spaces all normalize correctly, test inactive agent returns null","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:52.392007-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:52.392007-06:00","labels":["api","backend"],"dependencies":[{"issue_id":"test-e6t1s2","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:49:52.599357-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s2","depends_on_id":"test-e6t1s1","type":"blocks","created_at":"2026-01-30T12:51:46.627436-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s3","title":"Create pending_callback record with duplicate prevention","description":"Create pending_callbacks table schema with fields: agent_id, phone_number, requested_at, status (pending/processing/completed/failed), source ('sms'). On DEBRIEF detection from active agent: check for existing pending/processing callback within 5-minute cooldown window. If exists, skip creation (idempotent). If not, insert new pending_callback record. Use Convex scheduler to schedule the callback trigger mutation to run within 30 seconds.\n\n**Context:** Duplicate prevention is essential - excited agents might text DEBRIEF multiple times. The 30-second callback promise is a key UX differentiator that builds trust. Scheduler ensures reliability even under load.\n\n**Testing Requirements:**\n- **Unit Tests:** Test callback record created with correct fields, test duplicate request within 5 minutes is ignored, test request after cooldown creates new record, test scheduler is invoked with correct delay (\u003c30s)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:52.847379-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:52.847379-06:00","labels":["analytics","api","backend","database"],"dependencies":[{"issue_id":"test-e6t1s3","depends_on_id":"test-e6t1s1","type":"blocks","created_at":"2026-01-30T11:11:08.759193-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s3","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:49:53.018752-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s3","depends_on_id":"test-e6t1s2","type":"blocks","created_at":"2026-01-30T12:51:46.886616-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s4","title":"Add error handling, logging, and verify end-to-end flow","description":"Add comprehensive error handling: try/catch around all operations, log errors with context (phone, message_id). Add structured logging for: webhook received, keyword detected, agent found/not found, callback queued, duplicate skipped. Test full flow: send mock Telnyx webhook → verify pending_callback created → verify scheduler invoked. Add Telnyx webhook signature validation (optional but recommended for production).\n\n**Context:** Good logging is essential for debugging SMS issues since we can't easily reproduce them. Signature validation prevents spoofed requests from creating fake callbacks.\n\n**Testing Requirements:**\n- **Unit Tests:** Test error in agent lookup doesn't crash webhook (returns 200), test all log points fire correctly, test signature validation rejects invalid signatures, integration test: mock webhook → callback record exists","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:53.284762-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:53.284762-06:00","labels":["alerts","api","backend","database","testing"],"dependencies":[{"issue_id":"test-e6t1s4","depends_on_id":"test-e6t1s2","type":"blocks","created_at":"2026-01-30T11:11:08.97757-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s4","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:49:53.504316-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s4","depends_on_id":"test-e6t1s3","type":"blocks","created_at":"2026-01-30T12:51:47.127692-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2","title":"Build outbound call initiation system","description":"Create the core system that initiates outbound calls via Telnyx when triggered by SMS keyword, dashboard button, or scheduled callbacks. Handle call connection, failure, and retry logic.\n\n**Context:** This is the engine that makes debrief calls happen. Whether triggered by SMS or dashboard, calls must connect quickly and reliably. Retry logic prevents missed debriefs if agent doesn't answer immediately.\n\n**Testing Requirements:**\n- **Unit Tests:** Call state machine transitions, retry counter logic, context payload validation\n- **Integration Tests:** Telnyx call initiation with test numbers, webhook status updates, retry scheduling","design":"Create Convex action that calls Telnyx Voice API to initiate outbound call. Store call state (pending, ringing, connected, failed, completed) in calls table. Implement retry logic: 3 attempts with 30-second intervals. On final failure, trigger SMS fallback. Connect to existing call recording infrastructure if available. Support passing lead/property context that will be used during the debrief.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:47:42.427632-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:42.427632-06:00","labels":["algorithm","backend","convex","telnyx","voice"],"dependencies":[{"issue_id":"test-e6t2","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:47:43.091399-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2","depends_on_id":"test-e6t1","type":"blocks","created_at":"2026-01-30T12:51:47.377276-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s1","title":"Create calls table schema and TypeScript types","description":"Define the Convex schema for the calls table with fields: id, leadId, propertyAddress, agentId, status (pending|ringing|connected|failed|completed), triggerSource (sms|dashboard|scheduled), telnyxCallControlId, attemptNumber, maxAttempts, retryAt, startedAt, connectedAt, endedAt, failureReason, contextData (JSON for lead/property info to use during debrief). Create corresponding TypeScript types for call states and trigger sources.\n\n**Context:** The calls table is the foundation for tracking all outbound debrief calls. Proper schema design ensures we can track call lifecycle, implement retry logic, and maintain audit trail for all call attempts.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation accepts valid call records, test status enum only allows valid states, test contextData properly stores/retrieves nested lead/property objects","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:49:53.875471-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:53.875471-06:00","labels":["backend","database","frontend","layout","types"],"dependencies":[{"issue_id":"test-e6t2s1","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:49:54.290808-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s2","title":"Implement Telnyx Voice API integration action","description":"Create Convex action 'initiateOutboundCall' that: 1) Creates call record with 'pending' status, 2) Calls Telnyx Call Control API to initiate outbound call to agent, 3) Updates call record with telnyxCallControlId and 'ringing' status, 4) Handles Telnyx API errors (auth, rate limits, invalid numbers) gracefully. Use environment variables for Telnyx API key and connection ID. Include agent phone number and callback webhook URL in API request.\n\n**Context:** This is the core action that actually dials the agent. Telnyx Call Control API provides programmatic call initiation. Storing the call control ID allows us to track and manage the call through its lifecycle.\n\n**Testing Requirements:**\n- **Unit Tests:** Test successful call initiation updates status to 'ringing', test Telnyx 401 error marks call as failed with auth error reason, test Telnyx 429 rate limit triggers appropriate error handling, test invalid phone number returns validation error, mock Telnyx API responses for all tests","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:54.546803-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:54.546803-06:00","labels":["algorithm","backend","branding","frontend","integration","navigation"],"dependencies":[{"issue_id":"test-e6t2s2","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:49:54.707112-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s2","depends_on_id":"test-e6t2s1","type":"blocks","created_at":"2026-01-30T12:51:47.605542-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s3","title":"Build retry logic with scheduled function","description":"Create Convex scheduled function 'retryFailedCall' that: 1) Queries for calls with status='failed' and attemptNumber \u003c maxAttempts and retryAt \u003c= now, 2) For each eligible call, increments attemptNumber and calls initiateOutboundCall, 3) On call initiation failure, schedules next retry at retryAt + 30 seconds, 4) On final failure (attemptNumber \u003e= maxAttempts), updates status to 'failed' permanently and triggers SMS fallback mutation. Schedule this function to run every 10 seconds via Convex cron.\n\n**Context:** Retry logic is critical for reliability - agents may not answer immediately due to driving, on another call, etc. Three attempts with 30-second intervals gives reasonable chance of connection without being annoying. SMS fallback ensures the debrief still happens even if calls fail.\n\n**Testing Requirements:**\n- **Unit Tests:** Test retry only picks up calls where attemptNumber \u003c maxAttempts, test retry increments attemptNumber correctly, test 30-second interval between retries, test final failure triggers SMS fallback, test completed/connected calls are not retried","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:54.96917-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:54.96917-06:00","labels":["backend","components","convex","frontend"],"dependencies":[{"issue_id":"test-e6t2s3","depends_on_id":"test-e6t2s1","type":"blocks","created_at":"2026-01-30T11:11:09.802526-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s3","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:49:55.150918-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s3","depends_on_id":"test-e6t2s2","type":"blocks","created_at":"2026-01-30T12:51:48.364107-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s4","title":"Create call initiation triggers and verify end-to-end flow","description":"Create three trigger entry points: 1) 'triggerDebriefFromSms' mutation that parses incoming SMS for 'DEBRIEF' keyword and calls initiateOutboundCall, 2) 'triggerDebriefFromDashboard' mutation callable from frontend with leadId/agentId, 3) 'triggerScheduledDebrief' mutation for callback queue items. Each trigger should populate appropriate contextData (lead name, property address, showing notes) for use during the debrief. Add input validation and duplicate call prevention (no new call if one already pending/ringing for same lead+agent). Test full flow: trigger → call initiated → retry on failure → SMS fallback on final failure.\n\n**Context:** Multiple trigger sources converge on the same call initiation logic. Context propagation ensures the AI debrief has the information it needs. Duplicate prevention avoids agent confusion from multiple simultaneous calls about the same showing.\n\n**Testing Requirements:**\n- **Unit Tests:** Test SMS trigger extracts lead context correctly, test dashboard trigger validates required fields, test duplicate prevention blocks call when pending call exists, test each trigger source correctly populates contextData, test SMS fallback message includes property address","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:55.414459-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:55.414459-06:00","labels":["backend","frontend","testing","ux"],"dependencies":[{"issue_id":"test-e6t2s4","depends_on_id":"test-e6t2s2","type":"blocks","created_at":"2026-01-30T11:11:10.210859-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s4","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:49:55.671743-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s4","depends_on_id":"test-e6t2s3","type":"blocks","created_at":"2026-01-30T12:51:49.147841-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3","title":"Add 'Call Me Now' button to agent dashboard","description":"Create a dashboard UI component that lets agents trigger an immediate debrief call with optional lead/property context selection.\n\n**Context:** Dashboard button provides an alternative trigger method for agents at their desk. Context selection before calling is powerful - it primes the AI with relevant information so the debrief is more efficient and the transcript gets properly tagged.\n\n**Testing Requirements:**\n- **Unit Tests:** Modal state management, form validation, button disabled states\n- **Integration Tests:** Full flow from button click to call initiation, real-time status updates via Convex subscription","design":"Add prominent 'Call Me Now' button to agent dashboard. On click, show modal with: optional lead selector (search FUB leads), optional property address input, confirm button. Call Convex mutation to create callback request. Show real-time status: 'Calling you now...', 'Ringing...', 'Call connected'. Use Convex real-time subscriptions for status updates. Disable button during active call.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:43.762752-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:43.762752-06:00","labels":["backend","convex","cron","dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e6t3","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:47:44.267949-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3","depends_on_id":"test-e6t2","type":"blocks","created_at":"2026-01-30T12:51:49.496327-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s1","title":"Create CallMeNowButton component with modal skeleton","description":"Create the main CallMeNowButton React component for the agent dashboard. Include: prominent styled button with phone icon and 'Call Me Now' text, modal dialog that opens on click with placeholder content areas for lead selector and property input. Use shadcn/ui Dialog and Button components. Export component ready for dashboard integration.\n\n**Context:** This establishes the UI foundation. The button needs to be visually prominent since it's a primary action. Modal pattern keeps the dashboard clean while providing space for context selection.\n\n**Testing Requirements:**\n- **Unit Tests:** Test button renders with correct text and icon, test modal opens on button click, test modal closes on cancel/outside click, test button disabled state renders correctly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:49:55.933426-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:55.933426-06:00","labels":["backend","convex","database","frontend","real-time","ui"],"dependencies":[{"issue_id":"test-e6t3s1","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:49:56.107812-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s2","title":"Implement lead selector with FUB search integration","description":"Add lead selector to the modal using a searchable combobox pattern. Integrate with existing FUB leads query (or create if needed) to search leads by name/email/phone. Display selected lead with name and basic info. Selection should be optional - agent can skip this step. Store selected lead ID in component state.\n\n**Context:** Lead context selection is powerful - it primes the AI with relevant information so the debrief is more efficient and the transcript gets properly tagged to the correct contact in FUB.\n\n**Testing Requirements:**\n- **Unit Tests:** Test combobox renders and accepts input, test search filters leads correctly, test lead selection updates state, test clearing selection works, test empty state when no leads match","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:56.378027-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:56.378027-06:00","labels":["backend","frontend","integration","utilities","visualization"],"dependencies":[{"issue_id":"test-e6t3s2","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:49:56.549771-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s2","depends_on_id":"test-e6t3s1","type":"blocks","created_at":"2026-01-30T12:51:49.794436-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s3","title":"Add property address input and call trigger mutation","description":"Add optional property address text input field to modal. Create Convex mutation 'requestImmediateCallback' that accepts agentId, optional leadId, optional propertyAddress. On confirm button click, call mutation and transition to loading state. Mutation should create a callback request record that will trigger the outbound call flow.\n\n**Context:** Property context helps the AI understand what showing/listing the agent is debriefing about. The mutation creates the handoff point to the telephony system.\n\n**Testing Requirements:**\n- **Unit Tests:** Test property input accepts and stores text, test confirm button calls mutation with correct payload, test mutation validates required agentId, test mutation creates callback request record with all optional fields","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:56.767772-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:56.767772-06:00","labels":["backend","convex","cron","frontend","search"],"dependencies":[{"issue_id":"test-e6t3s3","depends_on_id":"test-e6t3s1","type":"blocks","created_at":"2026-01-30T12:09:58.927608-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s3","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:49:56.970364-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s3","depends_on_id":"test-e6t3s2","type":"blocks","created_at":"2026-01-30T12:51:50.118232-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s4","title":"Implement real-time call status updates with button state management","description":"Subscribe to callback request status using Convex real-time query. Display status progression in modal: 'Calling you now...', 'Ringing...', 'Call connected', 'Call ended'. Disable the Call Me Now button while any call is active (check for in-progress callback requests). Show success/error states. Auto-close modal on successful connection after brief delay.\n\n**Context:** Real-time feedback builds trust - agents see the system is working. Disabling during active calls prevents duplicate requests and confusion.\n\n**Testing Requirements:**\n- **Unit Tests:** Test status subscription updates UI correctly for each state, test button disabled when active call exists, test modal shows correct status text for each phase, test error state displays appropriately, test modal auto-closes on success","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:57.245565-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:57.245565-06:00","labels":["api","backend","convex","frontend","integration","real-time"],"dependencies":[{"issue_id":"test-e6t3s4","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:49:57.4408-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s4","depends_on_id":"test-e6t3s3","type":"blocks","created_at":"2026-01-30T12:51:50.401765-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4","title":"Implement SMS confirmation after call completion","description":"Send an SMS to the agent after each debrief call completes, including a brief summary of what was captured and confirmation that data was synced to FUB.\n\n**Context:** SMS confirmations close the loop and build trust. Agents need to know their debrief was captured correctly without having to log into the dashboard. This reinforces the value of the system and catches any issues early.\n\n**Testing Requirements:**\n- **Unit Tests:** Summary generation from transcript, SMS content formatting, character limit handling\n- **Integration Tests:** End-to-end flow from call completion webhook through SMS delivery","design":"Trigger on call completion webhook from Telnyx. After transcript processing completes, generate brief summary (use LLM to extract key points: deals discussed, action items, follow-ups). Send SMS via Telnyx with: 'Debrief captured! Discussed: [lead names]. [N] updates synced to FUB. View details: [short link]'. Keep under 160 chars or use MMS. Link to dashboard detail view.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:45.539948-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:45.539948-06:00","labels":["backend","conversation","sms","telnyx","voice"],"dependencies":[{"issue_id":"test-e6t4","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:47:45.932399-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4","depends_on_id":"test-e6t2","type":"blocks","created_at":"2026-01-30T12:51:50.760861-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s1","title":"Create SMS summary generation service","description":"Build a service that uses LLM to generate a brief SMS-friendly summary from debrief transcript data. Input: processed transcript with extracted entities (lead names, action items, deal updates). Output: concise summary under 160 chars like 'Discussed: John Smith, Mary Jones. 3 updates synced.' Use OpenAI/Claude API to extract key points: lead names mentioned, count of action items, count of FUB sync operations. Include fallback for when LLM is unavailable.\n\n**Context:** The summary needs to be short enough for SMS (160 chars) while still providing value. Agents should immediately see that their debrief was captured and what was discussed, building trust in the system.\n\n**Testing Requirements:**\n- **Unit Tests:** Test summary generation with mock transcript data, test character limit enforcement (\u003c=160), test extraction of lead names, test fallback when no leads found, test LLM error handling with fallback message","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:57.683063-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:57.683063-06:00","labels":["ai","backend","database","types"],"dependencies":[{"issue_id":"test-e6t4s1","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:49:57.860417-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s2","title":"Build short link generation for dashboard deep links","description":"Create a URL shortening mechanism for dashboard debrief detail links. Store mapping in database: short_code -\u003e debrief_id. Generate 6-char alphanumeric codes. Endpoint GET /d/:code redirects to /dashboard/debriefs/:id. This keeps SMS under 160 chars while providing direct access to full details.\n\n**Context:** Dashboard links are long but agents need quick access to view full debrief details. Short links make SMS fit in 160 chars and are easier to tap on mobile.\n\n**Testing Requirements:**\n- **Unit Tests:** Test short code generation uniqueness, test redirect resolution, test 404 for invalid codes, test code collision handling","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:58.169382-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:58.169382-06:00","labels":["ai","backend","business-logic","database"],"dependencies":[{"issue_id":"test-e6t4s2","depends_on_id":"test-e6t4s1","type":"blocks","created_at":"2026-01-30T12:09:59.995175-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s2","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:49:58.355041-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s3","title":"Implement SMS confirmation sender with Telnyx","description":"Create sendDebriefConfirmation() function that composes and sends confirmation SMS via Telnyx API. Template: 'Debrief captured! Discussed: [names]. [N] updates synced to FUB. View: [short_link]'. Handle MMS fallback if message exceeds 160 chars (include brief summary image). Use existing Telnyx client from SMS trigger feature. Log all sent confirmations for debugging.\n\n**Context:** SMS confirmations close the loop for agents. They know immediately that their voice debrief was captured without logging into any system. This builds trust and catches sync issues early.\n\n**Testing Requirements:**\n- **Unit Tests:** Test message composition under 160 chars, test MMS fallback trigger, test Telnyx API call with mock, test error handling for failed sends, test phone number formatting","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:49:58.703036-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:58.703036-06:00","labels":["backend","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e6t4s3","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:49:58.884615-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s3","depends_on_id":"test-e6t4s1","type":"blocks","created_at":"2026-01-30T12:51:51.129279-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s3","depends_on_id":"test-e6t4s2","type":"blocks","created_at":"2026-01-30T12:51:51.3884-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s4","title":"Wire confirmation SMS to call completion webhook flow","description":"Integrate SMS confirmation into the existing call completion webhook handler. After transcript processing and FUB sync complete: 1) Generate summary via summary service, 2) Create short link for dashboard, 3) Send confirmation SMS. Add to the async job queue to not block webhook response. Handle partial failures gracefully (e.g., FUB sync failed but still send confirmation with warning). Test end-to-end with real Telnyx webhook.\n\n**Context:** The confirmation must be triggered automatically when a debrief call ends. Agents shouldn't have to do anything - the confirmation arrives within seconds of hanging up, reinforcing the system's reliability.\n\n**Testing Requirements:**\n- **Unit Tests:** Test webhook handler triggers confirmation flow, test async job queuing, test partial failure handling (FUB sync failed), test confirmation not sent for failed calls, test idempotency for duplicate webhooks","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:49:59.285193-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:59.285193-06:00","labels":["backend","deployment","integration","testing"],"dependencies":[{"issue_id":"test-e6t4s4","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:49:59.463575-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s4","depends_on_id":"test-e6t4s3","type":"blocks","created_at":"2026-01-30T12:51:51.641313-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5","title":"Add call scheduling via SMS and dashboard","description":"Allow agents to schedule debrief calls for a future time via SMS ('call me in 10 minutes') or dashboard time picker.\n\n**Context:** Agents often can't talk immediately but know when they'll be free. Scheduling lets them trigger while the debrief is fresh in their mind, then receive the call at a convenient time. 'Call me in 10 minutes' is natural language they'd actually text.\n\n**Testing Requirements:**\n- **Unit Tests:** Natural language time parsing (various formats), scheduling logic, cancellation handling\n- **Integration Tests:** Scheduled function execution at correct time, cancellation flow, timezone handling","design":"For SMS: parse natural language time expressions ('in 10 minutes', 'at 3pm', 'in an hour'). Use simple regex patterns first, can enhance with LLM later. For dashboard: add time picker to Call Me modal with presets (5min, 10min, 30min, custom). Store scheduled_for timestamp in callback record. Use Convex scheduled functions to trigger at specified time. Send confirmation SMS: 'Got it! Calling you at [time]'. Allow cancellation via 'CANCEL' SMS keyword.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:46.758439-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:46.758439-06:00","labels":["backend","convex","database","frontend","scheduling","sms"],"dependencies":[{"issue_id":"test-e6t5","depends_on_id":"test-e6t4","type":"blocks","created_at":"2026-01-30T12:10:01.264173-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:47:46.961539-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5","depends_on_id":"test-e6t1","type":"blocks","created_at":"2026-01-30T12:51:51.928664-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5","depends_on_id":"test-e6t3","type":"blocks","created_at":"2026-01-30T12:51:52.244389-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s1","title":"Create natural language time parser for SMS scheduling","description":"Build a time parsing utility that converts natural language expressions to timestamps. Support patterns: 'in X minutes', 'in X hours', 'at Xpm/am', 'in half an hour', 'in an hour'. Use regex-based parsing initially. Return a Date object or null if unparseable. Handle edge cases like past times (interpret as next occurrence) and ambiguous times.\n\n**Context:** SMS scheduling needs to feel natural - agents will text 'call me in 10 minutes' not 'schedule call for 2024-01-15T14:30:00Z'. Simple regex patterns cover 90% of use cases without LLM overhead.\n\n**Testing Requirements:**\n- **Unit Tests:** Test 'in 5 minutes' returns ~5min future, 'in 1 hour' returns ~60min future, 'at 3pm' returns next 3pm, 'at 3:30pm' works, 'in half an hour' = 30min, invalid input returns null, 'in an hour' = 60min, past times roll to next day","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:49:59.725895-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:49:59.725895-06:00","labels":["backend","database","performance","prisma","testing","utility"],"dependencies":[{"issue_id":"test-e6t5s1","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:49:59.889723-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s2","title":"Add scheduled_for field and Convex scheduled function for callbacks","description":"Extend callback record schema to include optional scheduled_for timestamp. Create a Convex scheduled function that triggers the callback at the specified time. When a callback is created with scheduled_for, use ctx.scheduler.runAt() to schedule the actual call trigger. Handle cancellation by storing scheduler job ID and providing cancel mechanism.\n\n**Context:** Convex scheduled functions are the right primitive for delayed execution - they persist across server restarts and handle the timing automatically. Need to track job IDs to support cancellation.\n\n**Testing Requirements:**\n- **Unit Tests:** Test callback creation with scheduled_for stores timestamp, scheduled function triggers initiateCallback at correct time, cancellation removes scheduled job, immediate callbacks (no scheduled_for) work unchanged","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:00.178443-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:00.178443-06:00","labels":["backend","convex","frontend","optimization","typescript"],"dependencies":[{"issue_id":"test-e6t5s2","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:50:00.376203-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s2","depends_on_id":"test-e6t5s1","type":"blocks","created_at":"2026-01-30T12:51:52.556394-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s3","title":"Integrate SMS scheduling with time parser and confirmations","description":"Update SMS webhook handler to detect scheduling intent in DEBRIEF messages (e.g., 'DEBRIEF in 10 minutes', 'call me at 3pm'). Parse time using the utility from 6.5.1. Create scheduled callback record. Send confirmation SMS with human-readable time ('Got it! Calling you at 3:00 PM'). Add CANCEL keyword handler to cancel pending scheduled callbacks for that agent.\n\n**Context:** The SMS flow should be conversational. Agent texts naturally, gets clear confirmation, can cancel if plans change. CANCEL keyword provides simple escape hatch without needing the dashboard.\n\n**Testing Requirements:**\n- **Unit Tests:** Test 'DEBRIEF in 10 minutes' creates scheduled callback, confirmation SMS sent with correct time, 'CANCEL' cancels pending callback, 'CANCEL' with no pending callback sends appropriate response, plain 'DEBRIEF' still triggers immediate callback","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:00.988892-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:00.988892-06:00","labels":["backend","service","setup","testing","twilio","validation"],"dependencies":[{"issue_id":"test-e6t5s3","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:50:01.173537-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s3","depends_on_id":"test-e6t5s1","type":"blocks","created_at":"2026-01-30T12:51:52.80921-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s3","depends_on_id":"test-e6t5s2","type":"blocks","created_at":"2026-01-30T12:51:53.073226-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s4","title":"Add time picker to dashboard Call Me modal","description":"Extend the Call Me modal with scheduling option. Add toggle between 'Call Now' and 'Schedule'. Show preset buttons (5 min, 10 min, 30 min) and a custom time picker. On schedule submit, create callback with scheduled_for timestamp. Show confirmation in modal and update UI to show pending scheduled call with cancel option.\n\n**Context:** Dashboard provides alternative to SMS for agents who prefer visual interface. Presets cover common cases (quick break, after a showing, after lunch) while custom picker handles specific needs.\n\n**Testing Requirements:**\n- **Unit Tests:** Test preset buttons calculate correct future times, custom time picker validates future time only, scheduled callback created with correct timestamp, cancel button removes scheduled callback, UI shows pending scheduled call state","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:01.432967-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:01.432967-06:00","labels":["api","backend","frontend","iteration","react","user-testing","validation"],"dependencies":[{"issue_id":"test-e6t5s4","depends_on_id":"test-e6t5s3","type":"blocks","created_at":"2026-01-30T12:10:02.250312-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s4","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:50:01.603611-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s4","depends_on_id":"test-e6t5s2","type":"blocks","created_at":"2026-01-30T12:51:53.358746-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6","title":"Implement SMS fallback for unanswered calls","description":"When a debrief call isn't answered after all retry attempts, send an SMS offering alternative options: try again, schedule for later, or complete debrief via text.\n\n**Context:** Not every call will connect - agents get busy, phones die, etc. SMS fallback ensures no debrief intent is lost. Offering multiple recovery paths respects agent autonomy while keeping them engaged with the system.\n\n**Testing Requirements:**\n- **Unit Tests:** Response parsing (1, 2, free text), text debrief extraction logic\n- **Integration Tests:** Full fallback flow from failed calls through recovery options","design":"Trigger after 3 failed call attempts. Send SMS: 'Couldn't reach you for debrief. Reply: 1 to try again now, 2 to schedule for later, or just text your update and I'll log it.' Handle numeric responses to trigger appropriate action. For text updates: store as a text-based debrief, process with LLM to extract structured data, sync to FUB. This creates a lightweight async debrief path.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:47.312974-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:47.312974-06:00","labels":["analytics","backend","cron","fallback","sms"],"dependencies":[{"issue_id":"test-e6t6","depends_on_id":"test-e6t3","type":"blocks","created_at":"2026-01-30T12:10:02.50393-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:47:47.517254-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6","depends_on_id":"test-e6t2","type":"blocks","created_at":"2026-01-30T12:51:53.719261-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6","depends_on_id":"test-e6t5","type":"blocks","created_at":"2026-01-30T12:51:54.093488-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s1","title":"Create SMS fallback trigger and message sender","description":"Implement function that detects when a debrief call has exhausted all retry attempts (3 failed attempts) and triggers an SMS fallback. Send the templated message: 'Couldn't reach you for debrief. Reply: 1 to try again now, 2 to schedule for later, or just text your update and I'll log it.' Update the debrief call record status to 'awaiting_sms_response' and store timestamp of SMS sent.\n\n**Context:** This is the critical handoff point - when calls fail, we need to immediately pivot to SMS to capture the debrief intent before the agent moves on. The multi-option message respects agent autonomy while providing clear paths forward.\n\n**Testing Requirements:**\n- **Unit Tests:** Test trigger fires after exactly 3 failed attempts (not 2, not 4). Test SMS message content matches template. Test debrief record status updates to 'awaiting_sms_response'. Test idempotency - duplicate triggers don't send multiple SMS. Test with mock Twilio client.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:01.849136-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:01.849136-06:00","labels":["backend","database","sms"],"dependencies":[{"issue_id":"test-e6t6s1","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:50:02.147046-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s2","title":"Implement numeric response handlers (1 and 2)","description":"Handle incoming SMS responses to the fallback message. Response '1': Immediately trigger a new debrief call attempt, reset retry counter. Response '2': Send follow-up SMS asking for preferred time, then create a scheduled callback record. Parse responses flexibly (handle '1', '1.', 'one', etc. if reasonable). Update debrief record with chosen path.\n\n**Context:** Numeric responses need to be quick and reliable - these agents just want to get their debrief done. The '1' path gets them back into the call flow immediately. The '2' path respects their time and creates a commitment for later.\n\n**Testing Requirements:**\n- **Unit Tests:** Test '1' triggers new call attempt. Test '2' sends scheduling prompt. Test flexible parsing of numeric responses. Test invalid numbers (e.g., '3', '5') get helpful error message. Test state transitions in debrief record. Test webhook signature validation for incoming SMS.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:02.630813-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:02.630813-06:00","labels":["backend","cron","sms"],"dependencies":[{"issue_id":"test-e6t6s2","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:50:02.854465-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6s2","depends_on_id":"test-e6t6s1","type":"blocks","created_at":"2026-01-30T12:51:54.433884-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s3","title":"Implement text-based debrief processing and FUB sync","description":"When agent sends a free-text response (not '1' or '2'), treat it as an async text debrief. Store the raw text with timestamp and source='sms_fallback'. Process with LLM to extract structured debrief data (property address, showing outcome, next steps, buyer temperature). Sync extracted data to FUB as a note on the relevant contact. Mark debrief as completed with type='text'.\n\n**Context:** This is the lightweight async path - agents can just dump their update via text and we handle the structure. This captures debriefs that would otherwise be lost, even if the data extraction isn't perfect. Some data beats no data.\n\n**Testing Requirements:**\n- **Unit Tests:** Test free-text detection (not matching numeric patterns). Test raw text storage with correct metadata. Test LLM extraction with sample debrief texts - verify structured fields populated. Test FUB sync creates note on correct contact. Test status update to completed. Mock LLM responses for deterministic testing.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:03.407548-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:03.407548-06:00","labels":["api","backend","fub-integration","llm"],"dependencies":[{"issue_id":"test-e6t6s3","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:50:03.694531-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6s3","depends_on_id":"test-e6t6s1","type":"blocks","created_at":"2026-01-30T12:51:54.782161-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s4","title":"Add SMS fallback tracking and verification","description":"Add logging and monitoring for SMS fallback flow: track conversion rates (how many SMS fallbacks result in completed debriefs), response times, and which path agents choose most. Add admin visibility in dashboard showing fallback statistics. Verify end-to-end flow works with test scenarios: trigger fallback, respond with each option, confirm correct behavior.\n\n**Context:** Need visibility into whether SMS fallback is actually recovering lost debriefs or just creating noise. This data informs whether we need to adjust retry counts, message wording, or the overall approach. The verification step catches integration issues before production.\n\n**Testing Requirements:**\n- **Unit Tests:** Test analytics events fire for each fallback stage (sent, response received, completed). Test stats aggregation logic. Test dashboard endpoint returns correct fallback metrics. Manual verification: trigger fallback via test, respond with '1', verify call triggered; respond with '2', verify scheduling flow; respond with text, verify FUB note created.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:03.917746-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:03.917746-06:00","labels":["analytics","backend","notifications","testing"],"dependencies":[{"issue_id":"test-e6t6s4","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:50:04.148034-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6s4","depends_on_id":"test-e6t6s2","type":"blocks","created_at":"2026-01-30T12:51:55.114969-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6s4","depends_on_id":"test-e6t6s3","type":"blocks","created_at":"2026-01-30T12:51:56.543834-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t7","title":"Build check-in configuration UI and verification","description":"Create the settings page where agents configure their check-in preferences: frequency, lead count, preferred times, timezone. Include a test button to preview which leads would be selected. Verify full check-in flow works end-to-end.\n\n**Context:** Agents need control over their accountability settings to ensure buy-in. The preview feature builds trust by showing the algorithm's decisions. This UI makes the feature accessible to non-technical users.","design":"Settings form with frequency selector (daily/every 2 days/etc), lead count slider (3-5), time picker for preferred slots, timezone auto-detect with override. Preview shows sample leads that would be selected. Use shadcn/ui components.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:09.514592-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:38.062736-06:00","labels":["frontend","settings","ui"],"dependencies":[{"issue_id":"test-e6t7","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:09.693721-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7","depends_on_id":"test-e6t3","type":"blocks","created_at":"2026-01-30T12:10:03.66898-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7","depends_on_id":"test-e6t6","type":"blocks","created_at":"2026-01-30T12:10:03.852559-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:38.062736-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e6t7s1","title":"Create check-in settings form schema and types","description":"Define TypeScript types and Zod schema for check-in configuration: frequency (daily/every_2_days/every_3_days/weekly), lead_count (3-5 range), preferred_times (array of time slots), timezone (string). Create the form validation schema with appropriate constraints and error messages.\n\n**Context:** Type-safe configuration ensures the form and backend stay in sync. Zod schema provides runtime validation and integrates with react-hook-form for the UI.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:08:38.38853-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:13.071474-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e6t7s1","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:38.562751-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:13.071474-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e6t7s2","title":"Build check-in settings form UI with shadcn/ui","description":"Create CheckInSettings component with: Select for frequency options, Slider for lead count (3-5), TimePicker for preferred check-in times (allow multiple slots), timezone selector with auto-detect (Intl.DateTimeFormat().resolvedOptions().timeZone) and manual override. Use react-hook-form with the Zod schema. Include save button that calls the settings API.\n\n**Context:** This is the primary UI for agents to control their accountability settings. Auto-detecting timezone reduces friction while the override handles edge cases like traveling agents.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:38.747303-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:12.915098-06:00","labels":["frontend"],"dependencies":[{"issue_id":"test-e6t7s2","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:38.888424-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7s2","depends_on_id":"test-e6t7s1","type":"blocks","created_at":"2026-01-30T12:10:04.059399-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:12.915098-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e6t7s3","title":"Implement lead preview feature with test button","description":"Add 'Preview Check-in' button to settings form that calls a preview endpoint with current form values. Display the sample leads that would be selected in a card list showing: lead name, last contact date, priority score, and reason for selection. Show loading state during API call and empty state if no leads qualify.\n\n**Context:** The preview builds trust by making the algorithm transparent. Agents can see exactly which leads would be selected before committing to settings, increasing buy-in to the accountability system.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:39.082826-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:12.755002-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e6t7s3","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:39.286062-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7s3","depends_on_id":"test-e6t7s2","type":"blocks","created_at":"2026-01-30T12:10:04.292098-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:12.755002-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e6t7s4","title":"Verify end-to-end check-in flow and add to settings page","description":"Wire CheckInSettings component into the app's settings page. Test complete flow: configure settings → save → preview leads → verify scheduler picks up new settings → confirm check-in triggers at configured time (can use shorter interval for testing). Add success toast on save, error handling for API failures.\n\n**Context:** End-to-end verification ensures the entire accountability system works together: settings → scheduler → lead selection → notification. This is the moment of truth for the feature.","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:39.775352-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:31:12.607946-06:00","labels":["frontend","integration"],"dependencies":[{"issue_id":"test-e6t7s4","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:39.956659-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7s4","depends_on_id":"test-e6t7s3","type":"blocks","created_at":"2026-01-30T12:10:04.483611-06:00","created_by":"David Habedank"}],"deleted_at":"2026-01-30T12:31:12.607946-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e7","title":"Calendar Integration \u0026 Auto-Call Scheduling","description":"Connect to Google Calendar and FUB Calendar to detect appointment endings and automatically trigger debrief calls with configurable delays and retry logic.\n\n**Context:** Calendar auto-calls are the 'set and forget' experience. Agents connect their calendar once, and RealHerd calls them after every showing without any manual action. This is key for adoption.\n\n**Testing Requirements:**\n- **Unit Tests:** Calendar event parsing, appointment type detection, retry scheduling logic\n- **Integration Tests:** Google Calendar OAuth flow, webhook processing, ScheduledDebrief state machine\n- **Type Tests:** ScheduledDebrief model, calendar event types, retry configuration\n- **E2E Tests:** Calendar appointment ends, auto-call triggers after delay, retry on no-answer, SMS fallback","acceptance_criteria":"- Google Calendar OAuth connection flow works\n- FUB Calendar integration works\n- Appointment end detection triggers scheduled debrief\n- Broker-configurable post-appointment delay (0-60 min, default 5)\n- Retry logic with configurable attempts (default 2 retries)\n- Retry intervals configurable (default 10 min, 30 min)\n- SMS fallback after all attempts fail\n- Call attempt tracking and history in dashboard\n- Agent can opt out of auto-calls in preferences","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:47:20.200603-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:20.200603-06:00","labels":["automation","calendar","multi-tenant","onboarding","organization","scheduling","teams"],"dependencies":[{"issue_id":"test-e7","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:10:04.668787-06:00","created_by":"David Habedank"},{"issue_id":"test-e7","depends_on_id":"test-e6","type":"blocks","created_at":"2026-01-30T12:51:57.108798-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1","title":"Implement Google Calendar OAuth connection flow","description":"Build the OAuth 2.0 flow for agents to connect their Google Calendar accounts. Store refresh tokens securely and handle token refresh automatically.\n\n**Context:** Google Calendar is the most common calendar for real estate agents. This OAuth connection is the foundation for the 'set and forget' auto-call experience - agents connect once and RealHerd monitors their showings automatically.\n\n**Testing Requirements:**\n- **Unit Tests:** OAuth callback handler, token encryption/decryption, token refresh logic, error handling for revoked tokens\n- **Integration Tests:** Full OAuth flow with Google test account, token refresh cycle, connection status persistence in Convex","design":"Use Clerk's OAuth provider support if available, otherwise implement standard Google OAuth 2.0 flow. Store encrypted refresh tokens in Convex. Create a CalendarConnection model to track connection status, scopes granted, and last sync time. Implement token refresh middleware.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:47.750044-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:47.750044-06:00","labels":["backend","database","google-calendar","oauth","schema"],"dependencies":[{"issue_id":"test-e7t1","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:47:48.305685-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s1","title":"Create CalendarConnection schema and types","description":"Define the Convex schema for CalendarConnection including: id, userId, provider (google), encryptedRefreshToken, encryptedAccessToken, tokenExpiresAt, scopesGranted (array), connectionStatus (pending|active|revoked|error), lastSyncAt, createdAt, updatedAt. Create TypeScript types for the connection flow states and API responses.\n\n**Context:** This data model tracks the OAuth connection lifecycle and is critical for knowing which agents have working calendar connections vs those needing re-auth.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation for required fields, test enum values for connectionStatus and provider, test date field handling for tokenExpiresAt","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:04.661433-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:04.661433-06:00","labels":["backend","convex","database"],"dependencies":[{"issue_id":"test-e7t1s1","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:50:04.841258-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s2","title":"Implement Google OAuth initiation and callback endpoints","description":"Create Convex HTTP actions for: 1) /api/calendar/google/connect - generates OAuth URL with calendar.readonly scope, state token for CSRF protection, and redirect URI. 2) /api/calendar/google/callback - exchanges auth code for tokens, encrypts refresh token using Convex's built-in encryption or a secret key, creates/updates CalendarConnection record. Use Google's OAuth 2.0 endpoints (accounts.google.com/o/oauth2/v2/auth and oauth2.googleapis.com/token).\n\n**Context:** Standard OAuth 2.0 flow - the connect endpoint starts the flow, callback completes it. State token prevents CSRF attacks. Encryption protects tokens at rest.\n\n**Testing Requirements:**\n- **Unit Tests:** Test OAuth URL generation includes required params (client_id, redirect_uri, scope, state), test state token validation rejects invalid states, test token exchange with mocked Google response, test refresh token encryption/decryption roundtrip, test error handling for invalid auth codes","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:05.113226-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:05.113226-06:00","labels":["backend","security","typescript"],"dependencies":[{"issue_id":"test-e7t1s2","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:50:05.289508-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s2","depends_on_id":"test-e7t1s1","type":"blocks","created_at":"2026-01-30T12:51:57.503593-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s3","title":"Build automatic token refresh middleware","description":"Create a utility function getValidAccessToken(userId) that: 1) Fetches CalendarConnection for user, 2) Checks if access token is expired or expiring within 5 minutes, 3) If expired, uses refresh token to get new access token from Google, 4) Updates stored tokens and tokenExpiresAt, 5) Handles refresh failures by marking connection as 'error' status. This will be used by all calendar API calls.\n\n**Context:** Google access tokens expire after 1 hour. Automatic refresh means agents never need to re-authenticate unless they revoke access. The 5-minute buffer prevents race conditions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test returns cached token when not expired, test refreshes token when expired, test refreshes token when expiring within 5 minutes, test updates database after refresh, test marks connection as error when refresh fails (invalid_grant), test handles missing CalendarConnection gracefully","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:05.558734-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:05.558734-06:00","labels":["backend","security"],"dependencies":[{"issue_id":"test-e7t1s3","depends_on_id":"test-e7t1s1","type":"blocks","created_at":"2026-01-30T12:10:05.183566-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s3","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:50:05.814402-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s3","depends_on_id":"test-e7t1s2","type":"blocks","created_at":"2026-01-30T12:51:57.749101-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s4","title":"Create React hook and UI for calendar connection management","description":"Build useCalendarConnection() hook that returns: connectionStatus, connect(), disconnect(), lastSyncAt. Create a CalendarConnectionCard component showing: connection status badge, connected email, last sync time, connect/disconnect buttons. Handle loading states and errors. The connect() function should redirect to the OAuth initiation endpoint.\n\n**Context:** Agents need a simple way to connect their calendar from settings. This is the 'connect once' part of the set-and-forget experience. Clear status indicators build trust.\n\n**Testing Requirements:**\n- **Unit Tests:** Test hook returns correct status for each connectionStatus value, test connect() generates correct redirect URL, test disconnect() calls API and updates state, test loading states during async operations, test error display for failed connections","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:06.156498-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:06.156498-06:00","labels":["api","backend","convex","frontend","react"],"dependencies":[{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1s1","type":"blocks","created_at":"2026-01-30T12:10:05.425749-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1s3","type":"blocks","created_at":"2026-01-30T12:10:06.415248-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:50:06.327889-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1s2","type":"blocks","created_at":"2026-01-30T12:51:58.22711-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s5","title":"Integration test and verify complete OAuth flow","description":"Create end-to-end test scenarios: 1) Fresh connection flow - click connect, complete Google OAuth, verify CalendarConnection created with active status, 2) Token refresh - simulate expired token, make calendar API call, verify auto-refresh works, 3) Revoked access - simulate Google returning invalid_grant on refresh, verify connection marked as error and UI shows reconnect prompt. Test with real Google OAuth (staging credentials) in development.\n\n**Context:** OAuth flows have many edge cases. Integration testing catches issues that unit tests miss - wrong redirect URIs, scope mismatches, token format changes.\n\n**Testing Requirements:**\n- **Unit Tests:** Test complete flow with mocked Google responses for: successful auth, token refresh, revoked refresh token (invalid_grant error), network timeout, invalid client credentials","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:06.569769-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:06.569769-06:00","labels":["integration","testing"],"dependencies":[{"issue_id":"test-e7t1s5","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:50:06.732426-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s5","depends_on_id":"test-e7t1s3","type":"blocks","created_at":"2026-01-30T12:51:58.635156-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s5","depends_on_id":"test-e7t1s4","type":"blocks","created_at":"2026-01-30T12:51:58.945352-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2","title":"Implement FUB Calendar integration","description":"Connect to Follow Up Boss Calendar API to fetch agent appointments. Sync appointments and detect appointment types relevant for debrief calls (showings, buyer tours, listing presentations).\n\n**Context:** Many brokerages already use FUB as their CRM, so FUB Calendar integration provides value without requiring agents to use Google Calendar. This broadens adoption by meeting agents where they already work.\n\n**Testing Requirements:**\n- **Unit Tests:** FUB API client methods, appointment normalization logic, appointment type detection/filtering, sync deduplication\n- **Integration Tests:** FUB API calls with sandbox credentials, appointment sync accuracy, handling FUB API rate limits","design":"Use existing FUB API credentials from broker setup. Create unified Appointment model that normalizes data from both Google Calendar and FUB. Implement webhook listener for FUB calendar events if available, otherwise poll at configurable intervals. Filter for real estate appointment types based on keywords/categories.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:48.920272-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:48.920272-06:00","labels":["api","backend","frontend","fub-integration","settings"],"dependencies":[{"issue_id":"test-e7t2","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:47:49.438611-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s1","title":"Create unified Appointment model and FUB calendar types","description":"Define TypeScript types for FUB calendar API responses (appointments, events). Create a unified Appointment model that normalizes data from both Google Calendar and FUB Calendar sources. Include fields for: id, source (google|fub), agentId, title, startTime, endTime, appointmentType (showing|buyer_tour|listing_presentation|other), location, attendees, rawData. Add type guards and validation functions.\n\n**Context:** A unified model enables the debrief system to work identically regardless of calendar source, making the codebase maintainable as more integrations are added.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Appointment type validation, test normalization from FUB format to unified format, test appointmentType detection from title keywords (e.g., 'showing at 123 Main St' → 'showing'), test handling of missing/null fields","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:07.017498-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:07.017498-06:00","labels":["backend","frontend","types","ui"],"dependencies":[{"issue_id":"test-e7t2s1","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:50:07.167333-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s2","title":"Implement FUB Calendar API client","description":"Create FUBCalendarClient class that uses existing FUB API credentials from broker setup. Implement methods: getAppointments(agentId, dateRange), getAppointment(appointmentId). Handle FUB API authentication using stored credentials. Implement rate limiting (respect FUB's limits), retry logic for transient failures, and proper error handling for 401/403/429/500 responses. Parse FUB appointment data and convert to unified Appointment model.\n\n**Context:** Leveraging existing FUB credentials from broker setup means zero additional configuration for agents, maximizing the 'set and forget' experience.\n\n**Testing Requirements:**\n- **Unit Tests:** Test authentication header construction, test getAppointments with mock responses, test date range filtering, test conversion to unified Appointment model, test error handling for various HTTP status codes, test rate limit backoff behavior","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:07.411534-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:07.411534-06:00","labels":["api","backend","frontend"],"dependencies":[{"issue_id":"test-e7t2s2","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:50:07.641304-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t2s2","depends_on_id":"test-e7t2s1","type":"blocks","created_at":"2026-01-30T12:51:59.206905-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s3","title":"Build appointment sync service with polling","description":"Create FUBCalendarSyncService that polls FUB Calendar API at configurable intervals (default 5 minutes). Implement sync logic: fetch appointments for all connected agents, detect new/updated/cancelled appointments, store in database with change tracking. Add appointment type detection using keyword matching on title/description (keywords: 'showing', 'buyer tour', 'listing presentation', 'open house', 'walkthrough'). Emit events for appointments that qualify for debrief calls. Handle webhook events if FUB supports them (check API docs), falling back to polling.\n\n**Context:** Reliable syncing ensures agents get called after every relevant appointment. Keyword-based filtering avoids calling agents after irrelevant calendar events like team meetings.\n\n**Testing Requirements:**\n- **Unit Tests:** Test polling interval configuration, test appointment change detection (new/updated/cancelled), test keyword matching for appointment types, test debrief-qualifying logic, test handling of multiple agents in sync batch, test idempotency of sync operations","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:07.903801-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:07.903801-06:00","labels":["backend","database","service"],"dependencies":[{"issue_id":"test-e7t2s3","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:50:08.168695-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t2s3","depends_on_id":"test-e7t2s2","type":"blocks","created_at":"2026-01-30T12:51:59.457033-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s4","title":"Integration test and verify end-to-end flow","description":"Write integration tests that verify: FUB credentials from broker setup can fetch calendar data, appointments sync correctly to database, showing-type appointments trigger debrief events. Create a test script that simulates a full flow: agent has FUB connected → appointment ends → sync detects it → debrief event emitted. Verify unified Appointment model works identically for FUB and Google Calendar sources. Document any FUB API limitations discovered during testing.\n\n**Context:** End-to-end verification ensures the 'set and forget' promise actually works before agents rely on it. Documents edge cases for future maintenance.\n\n**Testing Requirements:**\n- **Unit Tests:** Integration test: mock FUB API → sync service → database → event emission. Test that Google Calendar and FUB appointments produce identical debrief triggers. Test edge cases: overlapping appointments, cancelled appointments, appointments without required fields.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:08.600782-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:08.600782-06:00","labels":["auth","backend","frontend","testing"],"dependencies":[{"issue_id":"test-e7t2s4","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:50:09.072528-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t2s4","depends_on_id":"test-e7t2s3","type":"blocks","created_at":"2026-01-30T12:51:59.733314-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3","title":"Build appointment end detection and call scheduling engine","description":"Create the core scheduling engine that monitors appointments, detects when they end, and schedules debrief calls with the configured delay. Handle timezone conversions and appointment modifications.\n\n**Context:** This is the brain of the auto-call feature. It must reliably trigger calls at the right time without missing appointments or double-calling. Reliability here directly impacts agent trust and adoption.\n\n**Testing Requirements:**\n- **Unit Tests:** Delay calculation, timezone handling, appointment modification detection, scheduling logic, cancellation handling\n- **Integration Tests:** End-to-end flow from appointment detection to scheduled call creation, Convex scheduled function execution, handling rapid appointment changes","design":"Use Convex scheduled functions for call triggering. Create AppointmentWatch records that track detected appointments and their call status. Handle appointment updates/cancellations gracefully. Store call schedule in ScheduledCall model with status tracking. Support broker-configurable delay (0-60 min, default 5 min).","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":420,"created_at":"2026-01-30T12:47:49.771821-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:49.771821-06:00","labels":["backend","clerk","core-feature","frontend","onboarding","scheduling","telnyx"],"dependencies":[{"issue_id":"test-e7t3","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:47:49.996582-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3","depends_on_id":"test-e7t1","type":"blocks","created_at":"2026-01-30T12:52:00.064732-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3","depends_on_id":"test-e7t2","type":"blocks","created_at":"2026-01-30T12:52:00.317222-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s1","title":"Define AppointmentWatch and ScheduledCall Convex schemas with status tracking","description":"Create Convex schema definitions for AppointmentWatch (tracks detected appointments: appointmentId, calendarId, brokerId, title, startTime, endTime, status enum [pending|scheduled|called|cancelled], lastSyncedAt) and ScheduledCall (tracks scheduled calls: appointmentWatchId, brokerId, scheduledFor timestamp, delayMinutes, status enum [pending|triggered|completed|failed|cancelled], triggeredAt, completedAt). Include indexes for efficient queries by brokerId, status, and scheduledFor time.\n\n**Context:** These models are the foundation of the scheduling engine - AppointmentWatch tracks what we're monitoring, ScheduledCall tracks when we'll call. Status enums enable graceful handling of appointment changes and call lifecycle.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation for both models, test status enum transitions are valid, test indexes return correct results for common query patterns (appointments by broker, pending calls ordered by scheduledFor)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:09.370097-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:09.370097-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e7t3s1","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:50:09.611501-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s2","title":"Implement appointment end detection with timezone-aware scheduling logic","description":"Create Convex query/mutation functions: detectEndedAppointments() that queries AppointmentWatch for appointments where endTime has passed and status is 'pending', calculateScheduledCallTime() that takes appointment endTime + broker's configured delay (0-60 min, default 5) and returns UTC timestamp for the call. Handle timezone conversions using broker's timezone setting. Create scheduleDebriefCall() mutation that creates ScheduledCall record and uses Convex scheduler.runAt() to trigger the call at the calculated time.\n\n**Context:** This is the core brain - detecting when showings end and scheduling calls with the right delay. Timezone handling is critical since agents work in local time but we store/schedule in UTC. The broker-configurable delay lets agents customize their workflow.\n\n**Testing Requirements:**\n- **Unit Tests:** Test detectEndedAppointments finds only pending appointments past endTime, test calculateScheduledCallTime with various delays (0, 5, 30, 60 min), test timezone conversion for EST/PST/CST brokers, test scheduleDebriefCall creates both ScheduledCall record and Convex scheduled function","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:09.922016-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:09.922016-06:00","labels":["api","backend","resend","scheduling","telnyx"],"dependencies":[{"issue_id":"test-e7t3s2","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:50:10.113374-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3s2","depends_on_id":"test-e7t3s1","type":"blocks","created_at":"2026-01-30T12:52:00.591927-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s3","title":"Handle appointment modifications and cancellations gracefully","description":"Implement handleAppointmentUpdate() mutation that: 1) When appointment time changes - cancels existing ScheduledCall (set status='cancelled'), removes scheduled function, creates new ScheduledCall with updated time. 2) When appointment is cancelled - marks AppointmentWatch status='cancelled', cancels any pending ScheduledCall. 3) When appointment is deleted from calendar - same as cancellation. Add idempotency checks to prevent duplicate calls. Create reconcileAppointmentChanges() that compares current calendar state with AppointmentWatch records.\n\n**Context:** Calendars are messy - appointments get rescheduled, cancelled, or deleted constantly. Without graceful handling, agents would get calls for cancelled showings or miss rescheduled ones. This directly impacts trust in the auto-call feature.\n\n**Testing Requirements:**\n- **Unit Tests:** Test time change cancels old call and schedules new one, test cancellation marks both records correctly, test idempotency - calling update twice doesn't create duplicate calls, test reconciliation detects calendar deletions","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:10.402415-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:10.402415-06:00","labels":["backend","clerk","frontend","scheduling","telnyx"],"dependencies":[{"issue_id":"test-e7t3s3","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:50:10.648253-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3s3","depends_on_id":"test-e7t3s2","type":"blocks","created_at":"2026-01-30T12:52:00.889237-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s4","title":"Create scheduled call trigger function with status tracking and error handling","description":"Implement triggerScheduledCall() Convex action that: 1) Validates ScheduledCall still has status='pending' (not cancelled). 2) Updates status to 'triggered' with triggeredAt timestamp. 3) Initiates the actual debrief call (integrate with existing call initiation). 4) On success - update status to 'completed' with completedAt. 5) On failure - update status to 'failed', log error, optionally retry once. Add monitoring query getScheduledCallsStatus() that returns counts by status for the scheduling dashboard.\n\n**Context:** This is where the rubber meets the road - actually triggering calls at the scheduled time. Status tracking enables debugging when calls don't work as expected. Validation before triggering prevents double-calls if appointment was cancelled between scheduling and trigger time.\n\n**Testing Requirements:**\n- **Unit Tests:** Test trigger skips cancelled calls, test status transitions through full lifecycle (pending→triggered→completed), test failure handling sets failed status and logs error, test getScheduledCallsStatus returns accurate counts","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:10.993352-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:10.993352-06:00","labels":["backend","scheduling","telnyx","voice"],"dependencies":[{"issue_id":"test-e7t3s4","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:50:11.146941-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3s4","depends_on_id":"test-e7t3s3","type":"blocks","created_at":"2026-01-30T12:52:01.18481-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4","title":"Implement retry logic and SMS fallback system","description":"Build the retry mechanism for failed/unanswered calls with configurable attempts and intervals. Implement SMS fallback notification after all call attempts fail.\n\n**Context:** Agents are often busy or driving after showings. Retry logic ensures we capture their debrief even if they miss the first call. SMS fallback provides a backup capture method and keeps agents informed.\n\n**Testing Requirements:**\n- **Unit Tests:** Retry interval calculation, attempt counting, SMS message generation, fallback trigger conditions\n- **Integration Tests:** Full retry flow with simulated call failures, Telnyx SMS delivery, web form fallback flow","design":"Default: 2 retries at 10 min and 30 min intervals (broker-configurable). Use Convex scheduled functions for retry timing. Track each attempt in CallAttempt model. After final retry fails, send SMS via Telnyx with link to submit debrief via web form. Update ScheduledCall status throughout the process.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:50.33875-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:50.33875-06:00","labels":["backend","frontend","reliability","sms","teams","telnyx"],"dependencies":[{"issue_id":"test-e7t4","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:47:50.812899-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4","depends_on_id":"test-e7t3","type":"blocks","created_at":"2026-01-30T12:52:01.485826-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s1","title":"Create CallAttempt model and extend ScheduledCall schema","description":"Add CallAttempt table in Convex schema to track individual call attempts (attempt number, timestamp, outcome, duration). Add retry configuration fields to ScheduledCall (maxRetries, retryIntervals array, currentAttempt). Add status enum values for retry states (retrying, max_attempts_reached, sms_fallback_sent).\n\n**Context:** Need to track each attempt separately for analytics and debugging. The retry configuration needs to be per-call to support broker-specific settings later. This schema enables the retry state machine.\n\n**Testing Requirements:**\n- **Unit Tests:** Test CallAttempt creation with valid/invalid attempt numbers, test ScheduledCall status transitions (scheduled→in_progress→retrying→max_attempts_reached), test default retry intervals [10, 30] are applied","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:11.384254-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:11.384254-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e7t4s1","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:50:11.560382-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s2","title":"Implement retry scheduling with Convex scheduled functions","description":"Create scheduleRetry mutation that schedules next call attempt using Convex scheduler.runAfter(). Implement getNextRetryDelay function that reads retry intervals from call config (default [10, 30] minutes). Create handleCallOutcome action that checks if call was answered/completed - if not and retries remain, schedule next attempt. Update ScheduledCall.currentAttempt and status on each retry.\n\n**Context:** Convex scheduled functions provide reliable delayed execution without external job queues. The retry logic must be idempotent since scheduled functions can retry on failure.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getNextRetryDelay returns correct interval for attempt 1, 2, and beyond max. Test scheduleRetry creates scheduled function with correct delay. Test handleCallOutcome branches: answered→complete, unanswered+retries→schedule retry, unanswered+no retries→trigger SMS. Mock scheduler.runAfter to verify timing.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:11.823992-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:11.823992-06:00","labels":["api","backend"],"dependencies":[{"issue_id":"test-e7t4s2","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:50:12.001579-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4s2","depends_on_id":"test-e7t4s1","type":"blocks","created_at":"2026-01-30T12:52:01.783261-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s3","title":"Build SMS fallback notification via Telnyx","description":"Create sendSmsFallback action that sends SMS via Telnyx API after all call attempts exhausted. Message includes: showing address, time elapsed since showing, and unique link to web debrief form (using existing debrief submission flow). Generate secure, expiring token for web form link. Update ScheduledCall status to sms_fallback_sent. Handle Telnyx API errors with logging.\n\n**Context:** SMS provides a reliable backup when agents can't answer calls. The web form link gives agents flexibility to submit debrief at their convenience while maintaining data capture. Token prevents unauthorized debrief submissions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test SMS message formatting includes all required fields. Test token generation creates valid, unique tokens. Test Telnyx API call with mock - verify phone number formatting, message content. Test error handling for Telnyx 4xx/5xx responses. Test ScheduledCall status update to sms_fallback_sent.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:12.238412-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:12.238412-06:00","labels":["backend","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e7t4s3","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:50:12.716156-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4s3","depends_on_id":"test-e7t4s2","type":"blocks","created_at":"2026-01-30T12:52:02.033477-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s4","title":"Wire retry flow into call completion handler and verify end-to-end","description":"Integrate retry logic into existing call completion webhook handler from Telnyx. When call ends without debrief completion: check attempt count, either schedule retry or trigger SMS fallback. Add logging for retry state transitions. Test complete flow: initial call → missed → retry scheduled → retry missed → SMS sent. Verify CallAttempt records created for each attempt.\n\n**Context:** This connects all the pieces into a working retry system. The call completion webhook is the trigger point that determines next action based on call outcome.\n\n**Testing Requirements:**\n- **Unit Tests:** Test webhook handler routes to retry logic when call unanswered. Test full state machine: scheduled→attempt1→retrying→attempt2→retrying→attempt3→sms_fallback_sent. Test CallAttempt records created with correct attempt numbers and timestamps. Integration test with mock Telnyx webhook payloads for answered vs unanswered calls.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:12.986596-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:12.986596-06:00","labels":["backend","feature","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e7t4s4","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:50:13.169622-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4s4","depends_on_id":"test-e7t4s3","type":"blocks","created_at":"2026-01-30T12:52:02.32904-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5","title":"Build calendar settings UI and call history dashboard","description":"Create UI for agents to connect calendars, manage auto-call preferences (opt-out option), and view call attempt history. Include broker admin UI for configuring delays and retry settings.\n\n**Context:** Agents need visibility into what RealHerd is doing with their calendar. The settings UI builds trust, and call history helps agents understand missed calls. Broker settings give team leads control over timing.\n\n**Testing Requirements:**\n- **Unit Tests:** Settings form validation, call history data transformation, opt-out state management\n- **Integration Tests:** OAuth flow from UI, settings persistence, real-time call history updates, broker settings applying to agent calls","design":"Agent settings page: Calendar connection status with connect/disconnect buttons, auto-call toggle (opt-out), call history table with attempt details. Broker settings: Post-appointment delay slider (0-60 min), retry count (1-5), retry intervals. Use shadcn/ui components. Real-time updates via Convex subscriptions.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:51.119467-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:51.119467-06:00","labels":["backend","dashboard","frontend","permissions","security","settings","ui"],"dependencies":[{"issue_id":"test-e7t5","depends_on_id":"test-e7t3","type":"blocks","created_at":"2026-01-30T12:10:11.444795-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:47:51.390448-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5","depends_on_id":"test-e7t1","type":"blocks","created_at":"2026-01-30T12:52:02.533174-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5","depends_on_id":"test-e7t2","type":"blocks","created_at":"2026-01-30T12:52:02.809454-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5","depends_on_id":"test-e7t4","type":"blocks","created_at":"2026-01-30T12:52:03.049378-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s1","title":"Create agent calendar settings page with connection management","description":"Build the agent settings page at /settings/calendar with: (1) Calendar connection status display showing current state (connected/disconnected, provider name, last sync time), (2) Connect button that initiates OAuth flow for Google/Outlook calendars, (3) Disconnect button with confirmation modal, (4) Auto-call toggle with clear opt-out option and explanation text. Use shadcn/ui Card, Switch, Button, and AlertDialog components. Wire up to Convex queries for calendar connection status.\n\n**Context:** This is the trust-building interface where agents see and control what RealHerd does with their calendar. The opt-out toggle is critical - agents must feel in control, not surveilled. Clear status display reduces support questions about 'is it working?'\n\n**Testing Requirements:**\n- **Unit Tests:** Test CalendarStatus component renders connected/disconnected states correctly, test AutoCallToggle onChange handler, test disconnect confirmation flow, test loading states during OAuth redirect","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:13.406311-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:13.406311-06:00","labels":["backend","frontend","security","ui"],"dependencies":[{"issue_id":"test-e7t5s1","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:50:13.665904-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s2","title":"Build call history dashboard with attempt details","description":"Create call history table component showing: date/time, property address, call status (completed/missed/voicemail/declined), duration, retry count, and outcome. Include filters for date range and status. Use shadcn/ui DataTable with sorting, pagination, and expandable rows for attempt details (each retry attempt with timestamp and result). Wire up to Convex subscription for real-time updates as new calls complete.\n\n**Context:** Call history helps agents understand what happened when they missed a call and builds confidence the system is working. Real-time updates mean they see calls appear right after showings without refreshing. This visibility is key for adoption.\n\n**Testing Requirements:**\n- **Unit Tests:** Test CallHistoryTable renders empty state, test with mock call data, test filtering by status, test sorting by date, test expandable row shows retry attempts, test real-time subscription updates table","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:13.915192-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:13.915192-06:00","labels":["backend","database","frontend","security","ui"],"dependencies":[{"issue_id":"test-e7t5s2","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:50:14.106581-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s2","depends_on_id":"test-e7t5s1","type":"blocks","created_at":"2026-01-30T12:52:03.302679-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s3","title":"Create broker admin settings panel for auto-call configuration","description":"Build broker settings page at /admin/settings/auto-calls with: (1) Post-appointment delay slider (0-60 minutes, default 15) with explanation of why delay matters, (2) Retry count selector (1-5 attempts, default 3), (3) Retry interval configuration (time between retries, e.g., 5/10/15 min options). Include preview text showing 'Calls will start 15 min after showing ends, with up to 3 attempts spaced 10 min apart'. Save settings to Convex brokerage settings document. Restrict access to broker/admin roles.\n\n**Context:** Team leads need control over timing to match their brokerage culture. Some want immediate calls, others prefer agents have buffer time. Showing the preview text in plain English helps admins understand the impact of their settings without doing math.\n\n**Testing Requirements:**\n- **Unit Tests:** Test delay slider updates state and shows correct value, test retry count selector bounds (1-5), test preview text generates correct sentence, test role-based access control redirects non-admins, test settings save to Convex mutation","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:14.335588-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:14.335588-06:00","labels":["admin","api","backend","frontend","ui"],"dependencies":[{"issue_id":"test-e7t5s3","depends_on_id":"test-e7t5s1","type":"blocks","created_at":"2026-01-30T12:10:12.165537-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s3","depends_on_id":"test-e7t5s2","type":"blocks","created_at":"2026-01-30T12:10:12.549305-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s3","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:50:14.502017-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s4","title":"Integrate settings with backend and verify end-to-end flow","description":"Wire up all UI components to Convex backend: (1) Create/update Convex queries for getUserCalendarSettings, getCallHistory, getBrokerageAutoCallSettings, (2) Create mutations for updateAutoCallPreference, updateBrokerageAutoCallSettings, (3) Add proper error handling with toast notifications for save failures, (4) Test full flow: connect calendar, toggle auto-call, view call history updating in real-time, adjust broker settings. Verify settings are respected by the auto-call system (e.g., delay setting affects when calls are scheduled).\n\n**Context:** The UI is only useful if it actually controls the system. This subtask ensures the frontend changes persist and affect real behavior. The end-to-end verification catches integration bugs before users do.\n\n**Testing Requirements:**\n- **Unit Tests:** Test Convex queries return expected shapes, test mutations validate input ranges, test optimistic updates in UI, test error toast appears on mutation failure, test settings changes reflect in scheduled call timing","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:14.748816-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:14.748816-06:00","labels":["backend","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e7t5s4","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:50:14.898642-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s4","depends_on_id":"test-e7t5s1","type":"blocks","created_at":"2026-01-30T12:52:03.61119-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s4","depends_on_id":"test-e7t5s2","type":"blocks","created_at":"2026-01-30T12:52:03.952965-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s4","depends_on_id":"test-e7t5s3","type":"blocks","created_at":"2026-01-30T12:52:04.24083-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t6","title":"Verify end-to-end calendar auto-call flow","description":"Integration testing task to verify the complete flow: calendar connection → appointment detection → scheduled call → retry logic → SMS fallback → dashboard visibility.\n\n**Context:** This is the flagship 'set and forget' feature. Every component must work together seamlessly. Verification ensures agents get the promised experience.\n\n**Testing Requirements:**\n- **Unit Tests:** N/A - integration verification task\n- **Integration Tests:** All 5 test scenarios executed with real calendar data, Telnyx test calls, and dashboard verification","design":"Create test scenarios: 1) Happy path - appointment ends, call connects, debrief captured. 2) Retry path - first call missed, retry succeeds. 3) SMS fallback - all calls fail, SMS sent with web form. 4) Opt-out respected. 5) Appointment cancelled mid-flow. Document any edge cases discovered.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:51.646635-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:51.646635-06:00","labels":["integration","testing","verification"],"dependencies":[{"issue_id":"test-e7t6","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:47:51.869909-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t6","depends_on_id":"test-e7t3","type":"blocks","created_at":"2026-01-30T12:52:04.819718-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t6","depends_on_id":"test-e7t4","type":"blocks","created_at":"2026-01-30T12:52:05.198789-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t6","depends_on_id":"test-e7t5","type":"blocks","created_at":"2026-01-30T12:52:05.466352-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t6s1","title":"Create integration test infrastructure and test data fixtures","description":"Set up the integration test environment for end-to-end calendar auto-call testing. Create test fixtures including: mock calendar events (past appointments that just ended), mock FUB contacts with phone numbers, test agent accounts with calendar connections. Configure test environment to use test Twilio credentials and mock SMS/voice providers where needed. Create helper functions for advancing time in tests to simulate appointment endings.\n\n**Context:** Integration tests need realistic data and controlled timing to verify the complete flow. Without proper fixtures, tests will be flaky or miss edge cases.\n\n**Testing Requirements:**\n- **Unit Tests:** Test fixture creation functions return valid data structures, test time manipulation helpers work correctly, verify mock providers are properly configured and isolated","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:15.165253-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:15.165253-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e7t6s1","depends_on_id":"test-e7t6","type":"parent-child","created_at":"2026-01-30T12:50:15.35824-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t6s2","title":"Implement happy path and retry path integration tests","description":"Write integration tests for: 1) Happy path - calendar appointment ends, system detects it, schedules call within 15min window, Twilio call connects, agent completes voice debrief, debrief is captured and visible in dashboard. 2) Retry path - first call goes unanswered, system schedules retry per configured logic, second call connects, debrief captured successfully. Tests should verify each stage fires correctly and data flows through the entire pipeline.\n\n**Context:** These are the core scenarios that 90%+ of users will experience. Happy path must work flawlessly. Retry logic ensures agents who miss the first call still get prompted.\n\n**Testing Requirements:**\n- **Unit Tests:** Assert happy path completes in under expected time threshold, verify call record created with correct appointment linkage, verify retry is scheduled after first call failure with correct delay, verify dashboard shows debrief after completion","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:50:15.674298-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:15.674298-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e7t6s2","depends_on_id":"test-e7t6","type":"parent-child","created_at":"2026-01-30T12:50:15.861146-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t6s2","depends_on_id":"test-e7t6s1","type":"blocks","created_at":"2026-01-30T12:52:05.827496-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t6s3","title":"Implement SMS fallback and opt-out integration tests","description":"Write integration tests for: 1) SMS fallback - all configured call attempts fail (unanswered/declined), system sends SMS with web form link, verify SMS contains correct debrief URL. 2) Opt-out respected - agent has opted out of auto-calls, appointment ends, verify NO call is scheduled and no SMS sent. Also test: agent opts out mid-flow (after first attempt), subsequent retries should be cancelled.\n\n**Context:** SMS fallback ensures no debrief is lost even when calls fail. Opt-out compliance is critical for user trust and potentially legal compliance. Mid-flow opt-out is an edge case that could cause bad UX if not handled.\n\n**Testing Requirements:**\n- **Unit Tests:** Assert SMS sent only after all call attempts exhausted, verify SMS contains valid debrief URL with correct appointment context, verify opted-out agents receive zero calls/SMS, verify mid-flow opt-out cancels pending retries","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:16.109321-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:16.109321-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e7t6s3","depends_on_id":"test-e7t6","type":"parent-child","created_at":"2026-01-30T12:50:16.28243-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t6s3","depends_on_id":"test-e7t6s1","type":"blocks","created_at":"2026-01-30T12:52:06.083982-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t6s4","title":"Implement edge case tests and document findings","description":"Write integration tests for edge cases: 1) Appointment cancelled mid-flow - after call scheduled but before execution, verify call is cancelled. 2) Appointment rescheduled - verify old trigger cancelled, new one created. 3) Duplicate appointments (same time/property) - verify only one call flow triggered. 4) Calendar disconnected mid-flow - graceful handling. Run all integration tests, document any discovered edge cases in test comments, create bug issues for any failures found.\n\n**Context:** Edge cases are where 'set and forget' breaks down. Calendar data is messy in the real world - appointments get cancelled, moved, duplicated. These tests ensure the system handles chaos gracefully.\n\n**Testing Requirements:**\n- **Unit Tests:** Assert cancelled appointment stops pending call within 1 minute, verify rescheduled appointment creates new call trigger with updated time, verify duplicate detection prevents multiple call flows, verify calendar disconnect logs error and doesn't crash flow","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:16.556691-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:16.556691-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e7t6s4","depends_on_id":"test-e7t6","type":"parent-child","created_at":"2026-01-30T12:50:16.699684-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t6s4","depends_on_id":"test-e7t6s2","type":"blocks","created_at":"2026-01-30T12:52:06.624114-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t6s4","depends_on_id":"test-e7t6s3","type":"blocks","created_at":"2026-01-30T12:52:06.851231-06:00","created_by":"David Habedank"}]}
{"id":"test-e8","title":"Database Check-In Calls","description":"Build the proactive check-in system that calls agents on a regular cadence to review stale leads, update statuses, and maintain database hygiene.\n\n**Context:** Debriefs capture new information, but databases rot over time. Check-ins are the accountability mechanism - the virtual sales manager asking 'what's happening with your leads?' on a regular schedule.\n\n**Testing Requirements:**\n- **Unit Tests:** Lead selection algorithm scoring, check-in scheduling logic, compliance calculation\n- **Integration Tests:** ScheduledCheckIn execution, multi-lead FUB sync, conversation flow for multiple leads\n- **Type Tests:** ScheduledCheckIn model, LeadUpdate validation, check-in settings schema\n- **E2E Tests:** Scheduled check-in calls agent, reviews 5 leads, all updates appear in FUB","acceptance_criteria":"- Check-in scheduling system works (configurable frequency, default every 3 days)\n- Lead selection algorithm identifies leads needing attention (stale, hot, approaching timeline)\n- Check-in conversation flow reviews 3-5 leads per call\n- Multi-lead updates sync to FUB in single call\n- LeadUpdate tracking per lead discussed\n- Check-in configuration in org/team settings\n- Compliance tracking shows which agents completed check-ins\n- Missed check-in handling and rescheduling","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:47:20.677404-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:20.677404-06:00","labels":["accountability","check-ins","core-feature","dashboard","reporting","visibility"],"dependencies":[{"issue_id":"test-e8","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:10:12.966207-06:00","created_by":"David Habedank"},{"issue_id":"test-e8","depends_on_id":"test-e4","type":"blocks","created_at":"2026-01-30T12:10:13.432554-06:00","created_by":"David Habedank"},{"issue_id":"test-e8","depends_on_id":"test-e6","type":"blocks","created_at":"2026-01-30T12:10:13.616512-06:00","created_by":"David Habedank"},{"issue_id":"test-e8","depends_on_id":"test-e7","type":"blocks","created_at":"2026-01-30T12:52:07.12238-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1","title":"Design check-in scheduling data model and configuration","description":"Create the database schema for check-in schedules, configuration settings, and tracking. Include org/team level settings for check-in frequency (default 3 days), time windows, and agent-specific overrides.\n\n**Context:** Check-ins are the 'virtual sales manager' accountability mechanism. The scheduling system needs to be configurable per org/team because different brokerages have different management styles - some want daily accountability, others weekly. This foundation enables all downstream check-in features.\n\n**Testing Requirements:**\n- **Unit Tests:** Schedule calculation functions (next due date with timezone), frequency validation, config inheritance (org → team → agent defaults)\n- **Integration Tests:** Convex mutations for schedule creation/updates, config propagation when org settings change","design":"Convex tables needed: checkInSchedules (agent schedules, next_due, frequency), checkInConfig (org/team settings), checkInSessions (completed/missed calls). Store frequency in hours for flexibility. Include timezone handling for agents. Add missed_count and last_completed fields for compliance tracking.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:52.147413-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:52.147413-06:00","labels":["backend","convex","dashboard","database","frontend","real-time"],"dependencies":[{"issue_id":"test-e8t1","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:47:52.372902-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s1","title":"Create checkInConfig Convex table for org/team settings","description":"Define the checkInConfig table in Convex schema with fields: orgId (string, indexed), teamId (optional string, indexed), defaultFrequencyHours (number, default 72 for 3 days), checkInWindowStart (number, hour of day 0-23), checkInWindowEnd (number, hour of day 0-23), timezone (string, IANA format), isActive (boolean), createdAt (number), updatedAt (number). Team-level configs override org-level when present.\n\n**Context:** This table stores the configurable defaults that determine how often agents get check-in calls. Different brokerages have different management styles - daily vs weekly accountability - so this must be org/team configurable.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation for frequency bounds (min 1 hour, max 168 hours/weekly), test timezone string validation (valid IANA zones), test window validation (start \u003c end), test default values applied correctly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:16.92638-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:16.92638-06:00","labels":["backend","convex","database","real-time"],"dependencies":[{"issue_id":"test-e8t1s1","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:50:17.118403-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s2","title":"Create checkInSchedules Convex table for agent schedules","description":"Define the checkInSchedules table with fields: agentId (string, indexed), orgId (string, indexed), frequencyOverrideHours (optional number, overrides config), nextDueAt (number, Unix timestamp), lastCompletedAt (optional number), missedCount (number, default 0), consecutiveMissedCount (number, resets on completion), agentTimezone (string, IANA format, may differ from org), status (union: 'active' | 'paused' | 'disabled'), pausedUntil (optional number), createdAt (number), updatedAt (number). Index on nextDueAt for efficient scheduling queries.\n\n**Context:** Each agent has their own schedule tracking when their next check-in is due. The missed counts enable compliance dashboards showing which agents are avoiding accountability. Agent timezone may differ from org timezone for remote agents.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schedule creation with defaults from config, test frequencyOverride takes precedence over config, test missedCount increments, test consecutiveMissedCount resets on completion, test status transitions (active-\u003epaused-\u003eactive)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:17.360883-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:17.360883-06:00","labels":["backend","component","database","frontend","ui"],"dependencies":[{"issue_id":"test-e8t1s2","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:50:17.502477-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s2","depends_on_id":"test-e8t1s1","type":"blocks","created_at":"2026-01-30T12:52:07.402049-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s3","title":"Create checkInSessions Convex table for completed/missed calls","description":"Define the checkInSessions table with fields: scheduleId (string, indexed, references checkInSchedules), agentId (string, indexed), orgId (string, indexed), scheduledFor (number, Unix timestamp), status (union: 'completed' | 'missed' | 'rescheduled' | 'in_progress'), startedAt (optional number), completedAt (optional number), durationSeconds (optional number), voiceCallId (optional string, links to voice call record), missedReason (optional union: 'no_answer' | 'declined' | 'system_error' | 'window_expired'), rescheduledTo (optional number), notes (optional string), createdAt (number). Compound index on [agentId, scheduledFor] for history queries.\n\n**Context:** This is the audit trail of all check-in attempts. Critical for compliance reporting - managers need to see which agents consistently miss check-ins. The voiceCallId links to the actual call record for playback.\n\n**Testing Requirements:**\n- **Unit Tests:** Test session creation with required fields, test status transitions (in_progress-\u003ecompleted, in_progress-\u003emissed), test duration calculation, test missedReason only set when status is missed, test rescheduledTo only set when status is rescheduled","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:17.754769-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:17.754769-06:00","labels":["backend","database","frontend","state-management","ux"],"dependencies":[{"issue_id":"test-e8t1s3","depends_on_id":"test-e8t1s1","type":"blocks","created_at":"2026-01-30T12:10:14.286235-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s3","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:50:17.945926-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s3","depends_on_id":"test-e8t1s2","type":"blocks","created_at":"2026-01-30T12:52:07.652098-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s4","title":"Create TypeScript types and validation helpers for check-in data model","description":"Create types/checkIn.ts with exported TypeScript types matching all three tables. Add validation helpers: validateFrequencyHours(hours: number), validateTimeWindow(start: number, end: number), validateTimezone(tz: string), calculateNextDueAt(lastCompleted: number | null, frequencyHours: number, timezone: string). Use date-fns-tz for timezone calculations. Export a getEffectiveFrequency(schedule, config) helper that returns the override or default.\n\n**Context:** Strong typing prevents bugs in scheduling logic. The calculation helpers centralize complex timezone-aware date math that will be used by scheduling queries and UI components.\n\n**Testing Requirements:**\n- **Unit Tests:** Test validateFrequencyHours rejects 0, negative, and \u003e168, test validateTimeWindow rejects start \u003e= end, test validateTimezone with valid/invalid IANA zones, test calculateNextDueAt respects timezone (test with America/New_York and UTC), test getEffectiveFrequency returns override when present","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:18.186668-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:18.186668-06:00","labels":["backend","frontend","integration","performance","types"],"dependencies":[{"issue_id":"test-e8t1s4","depends_on_id":"test-e8t1s2","type":"blocks","created_at":"2026-01-30T12:10:14.475041-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s4","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:50:18.389498-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s4","depends_on_id":"test-e8t1s3","type":"blocks","created_at":"2026-01-30T12:52:07.956306-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2","title":"Build lead selection algorithm for check-in calls","description":"Implement the algorithm that identifies which 3-5 leads an agent should review during each check-in call. Prioritize leads that are stale, marked hot, approaching their timeline, or have recent activity that needs follow-up.\n\n**Context:** Check-ins only work if they surface the RIGHT leads - not random ones. A good check-in call should feel like a smart assistant reminding the agent of exactly who needs attention. This is the intelligence that makes check-ins valuable rather than annoying busy-work.\n\n**Testing Requirements:**\n- **Unit Tests:** Lead scoring function, sort/filter logic, tie-breaking rules, edge cases (no leads, all leads fresh)\n- **Integration Tests:** FUB API calls to fetch lead data, scoring against real lead shapes, performance with 100+ leads","design":"Scoring algorithm: days since last contact (higher = more urgent), lead status (hot \u003e warm \u003e cold), timeline proximity (closer = more urgent), recent activity without follow-up. Pull from FUB via existing API client. Configurable lead count (default 5, range 3-8). Exclude leads updated in last 24 hours to avoid redundancy with debriefs.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:52.590645-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:52.590645-06:00","labels":["algorithm","backend","convex","dashboard","frontend","fub-api","visualization"],"dependencies":[{"issue_id":"test-e8t2","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:47:52.805526-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2","depends_on_id":"test-e8t1","type":"blocks","created_at":"2026-01-30T12:52:08.217568-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s1","title":"Create lead scoring types and algorithm interface","description":"Define TypeScript interfaces for lead scoring: LeadScore (with breakdown of stale_score, status_score, timeline_score, activity_score), ScoredLead (lead data + score), and LeadSelectionConfig (lead_count, exclude_hours, score_weights). Create the algorithm function signature that takes leads and config, returns sorted scored leads.\n\n**Context:** Clear typing ensures the scoring algorithm is transparent and debuggable - agents and brokers need to understand WHY these leads were surfaced.\n\n**Testing Requirements:**\n- **Unit Tests:** Test LeadScore type has all required fields, test ScoredLead extends FUB lead type, test LeadSelectionConfig defaults to count=5 and exclude_hours=24","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:50:18.81982-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:18.81982-06:00","labels":["backend","convex","queries","types"],"dependencies":[{"issue_id":"test-e8t2s1","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:50:18.98108-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s2","title":"Implement individual scoring functions","description":"Create pure functions for each scoring dimension: calcStalenessScore(lastContactDate) returns 0-100 based on days since contact (exponential decay curve, peaks at 14+ days), calcStatusScore(status) returns 100/70/40 for hot/warm/cold, calcTimelineScore(targetDate) returns 0-100 based on days until timeline (higher as deadline approaches), calcActivityScore(activities) returns bonus points for unaddressed recent activity (new inquiry, property view, etc).\n\n**Context:** Separating scoring functions makes the algorithm tunable and testable - brokerages may want to weight dimensions differently based on their sales process.\n\n**Testing Requirements:**\n- **Unit Tests:** Test staleness: 0 days=0 score, 7 days=50, 14+ days=100. Test status: hot=100, warm=70, cold=40, unknown=30. Test timeline: 30+ days=20, 7 days=70, 0-3 days=100, past=100. Test activity: no activity=0, activity with follow-up=0, activity without follow-up=25","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:19.246018-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:19.246018-06:00","labels":["algorithm","backend","frontend","react","visualization"],"dependencies":[{"issue_id":"test-e8t2s2","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:50:19.404772-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s2","depends_on_id":"test-e8t2s1","type":"blocks","created_at":"2026-01-30T12:52:08.492609-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s3","title":"Build lead selection algorithm with filtering and sorting","description":"Implement selectLeadsForCheckIn(leads, config) that: 1) Filters out leads updated in last 24 hours (configurable), 2) Calculates composite score using weighted sum of all dimensions, 3) Sorts by score descending, 4) Returns top N leads (configurable 3-8, default 5) with full score breakdown. Include tie-breaker logic (prefer hot status, then earlier timeline).\n\n**Context:** This is the core intelligence - it must reliably surface the leads that genuinely need attention while respecting the 24-hour exclusion to avoid overlap with debriefs.\n\n**Testing Requirements:**\n- **Unit Tests:** Test excludes leads updated \u003c24h ago, test returns exactly config.lead_count leads, test leads are sorted by score descending, test tie-breaker prefers hot over warm with same score, test empty input returns empty array, test input smaller than count returns all eligible leads","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:19.635927-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:19.635927-06:00","labels":["algorithm","backend","charts","frontend","recharts"],"dependencies":[{"issue_id":"test-e8t2s3","depends_on_id":"test-e8t2s1","type":"blocks","created_at":"2026-01-30T12:10:15.309979-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s3","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:50:19.807526-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s3","depends_on_id":"test-e8t2s2","type":"blocks","created_at":"2026-01-30T12:52:09.16317-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s4","title":"Create FUB integration function to fetch and score agent leads","description":"Implement getCheckInLeads(agentId, config) that: 1) Uses existing FUB API client to fetch agent's active leads with last contact date, status, timeline, and recent activities, 2) Passes leads through selection algorithm, 3) Returns ScoredLead[] with all context needed for check-in prompts. Handle FUB API errors gracefully with fallback to return empty array with logged warning.\n\n**Context:** This bridges the algorithm to real FUB data - the output directly feeds into check-in call prompts that voice agents will use.\n\n**Testing Requirements:**\n- **Unit Tests:** Test calls FUB client with correct agent filter, test transforms FUB response to algorithm input format, test passes through to selection algorithm, test returns empty array on FUB API error, test logs warning on error without throwing","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:20.031633-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:20.031633-06:00","labels":["backend","frontend","integration","navigation"],"dependencies":[{"issue_id":"test-e8t2s4","depends_on_id":"test-e8t2s2","type":"blocks","created_at":"2026-01-30T12:10:15.508307-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s4","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:50:20.311846-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s4","depends_on_id":"test-e8t2s3","type":"blocks","created_at":"2026-01-30T12:52:09.422182-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3","title":"Create check-in conversation flow and voice interaction","description":"Build the voice conversation flow for check-in calls. Guide agent through reviewing each selected lead, capture status updates, notes, and next steps. Handle multi-lead review in a single call session.\n\n**Context:** This is the core user experience - the phone call where the agent reviews their pipeline. It needs to feel efficient (not a chore), capture actionable updates, and handle the natural flow of 'actually, skip that one' or 'let me add context'. The conversation builds on the debrief infrastructure but has different goals.\n\n**Testing Requirements:**\n- **Unit Tests:** Conversation state machine, command parsing (skip, go back, done), transcript aggregation\n- **Integration Tests:** Full call flow simulation, Telnyx webhook handling, LLM response generation for lead presentation","design":"Use existing Telnyx/voice infrastructure from debriefs. Conversation states: intro → lead review loop (present lead → get update → confirm) → summary → close. Support skip, go back, add note commands. Track which leads were reviewed vs skipped. Store transcripts for compliance. Target 5-10 min call duration for 5 leads.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:47:53.054327-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:53.054327-06:00","labels":["backend","convex","dashboard","frontend","llm","metrics","telnyx","voice"],"dependencies":[{"issue_id":"test-e8t3","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:47:53.252692-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3","depends_on_id":"test-e8t2","type":"blocks","created_at":"2026-01-30T12:52:10.078978-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s1","title":"Define conversation state machine and TypeScript types","description":"Create the state machine definition for check-in conversation flow. States: intro, lead_presentation, awaiting_update, confirm_update, summary, close. Define transitions for: next_lead, skip_lead, go_back, add_note, end_call. Create TypeScript interfaces for CheckInSession (leads to review, current index, reviewed leads, skipped leads, updates collected), LeadUpdate (status change, notes, next steps, next contact date), and ConversationState. Include timeout handling states for no response.\n\n**Context:** The state machine is the foundation - it defines every possible path through the conversation and prevents edge cases like getting stuck or losing data mid-call.\n\n**Testing Requirements:**\n- **Unit Tests:** Test state transitions for all valid paths, test invalid transition handling, test session serialization/deserialization, test timeout state transitions","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:20.535807-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:20.535807-06:00","labels":["backend","frontend","types","voice"],"dependencies":[{"issue_id":"test-e8t3s1","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:50:20.785308-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s2","title":"Build lead review loop with voice prompts and response parsing","description":"Implement the core lead review loop. For each lead: synthesize presentation prompt ('Next up: John Smith, last contacted 3 weeks ago, interested in downtown condos. What's the latest?'), parse agent response for status keywords (hot, cold, dead, closing, nurture), extract notes and next steps using existing transcript parsing. Handle commands: 'skip' moves to next without update, 'go back' returns to previous lead, 'hold on' or 'wait' pauses for thinking. Use Telnyx voice synthesis for prompts and speech recognition for responses.\n\n**Context:** This is the UX heart of the feature - it needs to feel like a quick conversation with a helpful assistant, not a data entry form read aloud. Natural command handling makes the difference between adoption and abandonment.\n\n**Testing Requirements:**\n- **Unit Tests:** Test prompt generation for various lead states, test status keyword extraction from sample transcripts, test command detection (skip, go back, wait), test handling of ambiguous responses, test lead navigation logic (next, previous, skip tracking)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:21.035791-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:21.035791-06:00","labels":["ai","api","backend","security","voice"],"dependencies":[{"issue_id":"test-e8t3s2","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:50:21.208473-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s2","depends_on_id":"test-e8t3s1","type":"blocks","created_at":"2026-01-30T12:52:10.347355-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s3","title":"Implement session summary and data persistence","description":"Build the call conclusion flow. Generate spoken summary: 'You reviewed 4 leads, skipped 1. I captured updates for John Smith, Jane Doe...' Store all updates to database: create LeadCheckInUpdate records linked to leads, store full transcript for compliance, track session metadata (duration, leads reviewed count, leads skipped count). Handle mid-call disconnection gracefully - persist partial data and mark session as incomplete. Update lead last_contacted timestamps for reviewed leads.\n\n**Context:** The summary gives agents confidence their updates were captured, and the persistence ensures nothing is lost even if the call drops. Compliance transcript storage protects the brokerage.\n\n**Testing Requirements:**\n- **Unit Tests:** Test summary generation with various review/skip combinations, test database persistence of updates, test partial session recovery after disconnect, test transcript storage, test last_contacted timestamp updates","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:21.453246-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:21.453246-06:00","labels":["backend","component","dashboard","database","frontend","voice"],"dependencies":[{"issue_id":"test-e8t3s3","depends_on_id":"test-e8t3s1","type":"blocks","created_at":"2026-01-30T12:10:16.416918-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s3","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:50:21.593178-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s3","depends_on_id":"test-e8t3s2","type":"blocks","created_at":"2026-01-30T12:52:10.59665-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s4","title":"Wire up Telnyx webhook handlers and end-to-end call flow","description":"Connect the conversation state machine to Telnyx call infrastructure. Create webhook endpoint for incoming check-in calls (or outbound call initiation). Handle call events: answer → run intro state, speech events → feed to response parser, hangup → trigger session save. Integrate with existing Telnyx client from debrief infrastructure. Add call duration tracking and implement 10-minute soft warning ('We're at 10 minutes - want to wrap up or keep going?'). Test full flow with 5-lead sample session.\n\n**Context:** This is the integration layer that makes everything work together. The soft time warning respects agents' busy schedules while giving them control.\n\n**Testing Requirements:**\n- **Unit Tests:** Test webhook event parsing, test call state management across events, test duration tracking and warning trigger, test graceful hangup handling, integration test with mock Telnyx events for full 5-lead session","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:21.840653-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:21.840653-06:00","labels":["backend","frontend","integration","testing","voice"],"dependencies":[{"issue_id":"test-e8t3s4","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:50:22.040047-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s4","depends_on_id":"test-e8t3s3","type":"blocks","created_at":"2026-01-30T12:52:10.946174-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4","title":"Implement multi-lead FUB sync and LeadUpdate tracking","description":"Build the system to batch-sync all lead updates from a check-in call to Follow Up Boss. Create LeadUpdate records for each lead discussed, linking them to the check-in session.\n\n**Context:** A check-in call might update 5 leads at once. We need to sync all of these efficiently (not 5 separate API calls if avoidable) and track which leads were updated for reporting. This connects check-ins to the existing LeadUpdate tracking that debriefs use.\n\n**Testing Requirements:**\n- **Unit Tests:** Batch update formatting, partial failure handling, LeadUpdate record creation\n- **Integration Tests:** FUB API batch operations, Convex transaction for multiple LeadUpdates, retry queue behavior","design":"Leverage existing FUB sync patterns from debrief module. Create LeadUpdate records with source='check-in' and link to checkInSession. Handle partial failures gracefully (some leads sync, some fail). Queue updates for retry on failure. Include skip tracking - leads presented but not updated still get logged.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:53.626858-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:53.626858-06:00","labels":["backend","convex","dashboard","export","frontend","fub-api","reporting"],"dependencies":[{"issue_id":"test-e8t4","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:47:53.834031-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4","depends_on_id":"test-e8t3","type":"blocks","created_at":"2026-01-30T12:52:11.278034-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s1","title":"Create LeadUpdate schema extension for check-in source","description":"Extend the existing LeadUpdate model to support check-in sessions as a source. Add 'check-in' to the source enum, add optional checkInSessionId foreign key, and add 'skipped' boolean to track leads that were presented but not updated. Create the migration file.\n\n**Context:** Check-ins need the same LeadUpdate tracking as debriefs for reporting consistency. The 'skipped' flag enables accountability reporting - showing which leads an agent reviewed but chose not to update.\n\n**Testing Requirements:**\n- **Unit Tests:** Test LeadUpdate creation with source='check-in', test checkInSessionId foreign key constraint, test skipped field defaults to false, test that existing debrief LeadUpdates still work after migration","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:22.300552-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:22.300552-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e8t4s1","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:50:22.463985-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s2","title":"Build batch FUB sync service for check-in updates","description":"Create a CheckInFubSyncService that accepts an array of lead updates and syncs them to Follow Up Boss efficiently. Batch updates where FUB API allows, otherwise parallelize with rate limiting. Return a result object with success/failure status per lead. Leverage existing FUB client patterns from debrief module.\n\n**Context:** A check-in might update 5+ leads. Individual API calls are slow and wasteful. Batching or parallelizing with proper rate limiting ensures efficiency while respecting FUB API limits.\n\n**Testing Requirements:**\n- **Unit Tests:** Test batch sync with 5 mock leads returns success array, test partial failure (2 succeed, 1 fails) returns correct status per lead, test rate limiting respects FUB limits (mock timing), test empty array returns empty results, test FUB 429 response triggers appropriate handling","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:22.71941-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:22.71941-06:00","labels":["backend","components","frontend","integration"],"dependencies":[{"issue_id":"test-e8t4s2","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:50:22.90791-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4s2","depends_on_id":"test-e8t4s1","type":"blocks","created_at":"2026-01-30T12:52:11.587665-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s3","title":"Implement LeadUpdate creation with retry queue for failures","description":"Create a service that: 1) Creates LeadUpdate records for each lead discussed in a check-in (including skipped leads), 2) Links them to the checkInSession, 3) Calls the batch FUB sync, 4) Updates LeadUpdate records with sync status, 5) Queues failed syncs for retry using existing job queue infrastructure. Handle the full lifecycle from check-in completion to synced state.\n\n**Context:** Partial failures are expected with external APIs. Users shouldn't lose their work because one lead failed to sync. The retry queue ensures eventual consistency while LeadUpdate records provide immediate tracking.\n\n**Testing Requirements:**\n- **Unit Tests:** Test LeadUpdate records created for all leads in check-in, test skipped leads get LeadUpdate with skipped=true, test successful sync updates LeadUpdate.syncedAt, test failed sync queues retry job, test retry job processes and updates LeadUpdate on success, test checkInSessionId correctly links all LeadUpdates","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:23.15508-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:23.15508-06:00","labels":["backend","frontend","reporting"],"dependencies":[{"issue_id":"test-e8t4s3","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:50:23.341311-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4s3","depends_on_id":"test-e8t4s1","type":"blocks","created_at":"2026-01-30T12:52:11.854587-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4s3","depends_on_id":"test-e8t4s2","type":"blocks","created_at":"2026-01-30T12:52:12.113219-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s4","title":"Integration test and verify end-to-end check-in sync flow","description":"Write integration tests that verify the complete flow: check-in session with multiple leads → LeadUpdate records created → FUB sync attempted → success/failure handling → retry queue for failures. Test with mock FUB API. Verify database state at each step. Run tests and confirm all pass.\n\n**Context:** This is the critical path for check-in value delivery. Integration tests catch issues that unit tests miss - like transaction boundaries, queue timing, and data consistency across the full flow.\n\n**Testing Requirements:**\n- **Unit Tests:** Integration test: complete check-in with 3 updated leads + 1 skipped creates 4 LeadUpdate records with correct states, Integration test: FUB failure for 1 lead results in 2 synced + 1 queued for retry, Integration test: retry job successfully syncs previously failed lead, Integration test: verify checkInSession.leadsUpdated count matches LeadUpdate records","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:23.879538-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:23.879538-06:00","labels":["backend","export","frontend","testing"],"dependencies":[{"issue_id":"test-e8t4s4","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:50:24.187198-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4s4","depends_on_id":"test-e8t4s3","type":"blocks","created_at":"2026-01-30T12:52:12.402802-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5","title":"Build check-in trigger system and missed call handling","description":"Create the scheduled job system that initiates check-in calls when due. Handle missed calls (no answer, declined), implement rescheduling logic, and track compliance for reporting.\n\n**Context:** Accountability only works if check-ins actually happen. This system ensures calls go out on schedule and handles the reality that agents miss calls. Brokerage owners need to see who's completing check-ins vs who's dodging them.\n\n**Testing Requirements:**\n- **Unit Tests:** Due check-in query logic, reschedule calculation, compliance stat updates\n- **Integration Tests:** Scheduled function execution, Telnyx outbound call initiation, missed call webhook handling","design":"Convex scheduled functions to check for due check-ins. Outbound call initiation via Telnyx. Missed call handling: retry once after 1 hour, then mark missed and reschedule to next day. Compliance fields: completed_count, missed_count, last_completed, streak. No-answer vs declined tracking.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:54.069426-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:54.069426-06:00","labels":["agent-view","backend","convex","dashboard","frontend","mobile","scheduled-jobs","telnyx"],"dependencies":[{"issue_id":"test-e8t5","depends_on_id":"test-e8t3","type":"blocks","created_at":"2026-01-30T12:10:18.546814-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:47:54.257627-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5","depends_on_id":"test-e8t4","type":"blocks","created_at":"2026-01-30T12:52:12.665776-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s1","title":"Create compliance tracking schema and types","description":"Add compliance tracking fields to the database schema: completed_count (number), missed_count (number), last_completed (timestamp), streak (number of consecutive completed check-ins). Create TypeScript types for check-in status tracking including 'scheduled', 'in_progress', 'completed', 'missed_no_answer', 'missed_declined'. Add fields to track attempt_count and last_attempt_time for retry logic.\n\n**Context:** Brokerage owners need visibility into who's completing check-ins vs dodging them. These fields power the accountability reporting that makes the system valuable.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation for all compliance fields, test status enum includes all required states, verify default values (counts start at 0, streak starts at 0)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:24.416053-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:24.416053-06:00","labels":["backend","dashboard","database","frontend"],"dependencies":[{"issue_id":"test-e8t5s1","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:50:24.580045-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s2","title":"Implement scheduled check-in trigger function","description":"Create a Convex scheduled function that runs every 5 minutes to find check-ins due within the next window. Query for agents with scheduled check-ins where due_time \u003c= now and status is 'scheduled'. For each due check-in, initiate outbound call via Telnyx API and update status to 'in_progress'. Include rate limiting to avoid overwhelming Telnyx. Schedule the cron job in convex/crons.ts.\n\n**Context:** This is the heartbeat of the accountability system - it ensures check-in calls actually go out when scheduled rather than relying on manual triggers.\n\n**Testing Requirements:**\n- **Unit Tests:** Test query returns only due check-ins (not future ones), test status updates to in_progress on trigger, test Telnyx call initiation with mock, test rate limiting prevents more than X calls per minute, test cron registration","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:24.842723-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:24.842723-06:00","labels":["backend","convex","frontend","telnyx"],"dependencies":[{"issue_id":"test-e8t5s2","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:50:25.047142-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5s2","depends_on_id":"test-e8t5s1","type":"blocks","created_at":"2026-01-30T12:52:12.979456-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s3","title":"Build missed call detection and retry logic","description":"Create webhook handler for Telnyx call status events (no-answer, declined, completed). On no-answer or declined: increment attempt_count, if attempt_count \u003c 2 schedule retry in 1 hour using Convex scheduler, update status to 'missed_no_answer' or 'missed_declined'. On second missed attempt: mark as final missed, increment missed_count, reset streak to 0, auto-reschedule to next day at same time. On completed: increment completed_count, increment streak, update last_completed timestamp.\n\n**Context:** Agents miss calls - that's reality. The retry gives them a second chance, but after that we need to track it as missed for accountability reporting and move on to the next scheduled check-in.\n\n**Testing Requirements:**\n- **Unit Tests:** Test no-answer triggers retry scheduling after 1 hour, test declined triggers retry scheduling, test second miss marks as final and reschedules to next day, test completed updates all compliance fields correctly, test streak resets on miss, test streak increments on complete, verify webhook signature validation","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:25.32672-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:25.32672-06:00","labels":["backend","convex","frontend","integration","telnyx","webhooks"],"dependencies":[{"issue_id":"test-e8t5s3","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:50:25.562897-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5s3","depends_on_id":"test-e8t5s2","type":"blocks","created_at":"2026-01-30T12:52:13.221256-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s4","title":"Add compliance query functions and verify end-to-end flow","description":"Create query functions for compliance reporting: getAgentCompliance(agentId) returns all compliance fields, getTeamComplianceStats(teamId) returns aggregated stats across team members, getComplianceTrends(agentId, days) returns daily completion data for charts. Write integration test that simulates full flow: scheduled check-in → trigger fires → call initiated → missed → retry scheduled → retry missed → rescheduled to next day with compliance fields updated.\n\n**Context:** These queries power the brokerage owner dashboard showing who's completing check-ins. The integration test ensures the entire trigger→miss→retry→reschedule flow works correctly before shipping.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getAgentCompliance returns correct fields, test getTeamComplianceStats aggregates correctly (average completion rate, total missed), test getComplianceTrends returns correct date range data, integration test for full missed-call-retry-reschedule flow","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:25.966261-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:25.966261-06:00","labels":["backend","convex","frontend","testing","workflow"],"dependencies":[{"issue_id":"test-e8t5s4","depends_on_id":"test-e8t5s1","type":"blocks","created_at":"2026-01-30T12:10:19.264727-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5s4","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:50:26.208872-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5s4","depends_on_id":"test-e8t5s3","type":"blocks","created_at":"2026-01-30T12:52:13.491416-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t6","title":"Add check-in configuration UI and compliance dashboard","description":"Build the settings UI for configuring check-in frequency at org/team level, and a compliance view showing which agents have completed their check-ins vs missed them.\n\n**Context:** Brokerage owners and team leads need to configure how aggressive the check-in cadence is and see who's actually using the system. This visibility is core to the 'virtual sales manager' value prop - managers can see accountability metrics without manually tracking.\n\n**Testing Requirements:**\n- **Unit Tests:** Config form validation, compliance calculation functions\n- **Integration Tests:** Config save/load round-trip, real-time compliance updates when check-ins complete","design":"Settings page with frequency selector (daily, every 2 days, every 3 days, weekly), time window preferences. Compliance dashboard showing: agents with completed/missed/upcoming check-ins, streak tracking, completion rate over time. Use existing shadcn/ui components and dashboard patterns.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:47:54.516384-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:54.516384-06:00","labels":["dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e8t6","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:47:54.683855-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t6","depends_on_id":"test-e8t5","type":"blocks","created_at":"2026-01-30T12:52:13.796653-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t6s1","title":"Create check-in settings form component with frequency controls","description":"Build a React component for check-in configuration using shadcn/ui form components. Include: frequency selector (daily/every 2 days/every 3 days/weekly) using RadioGroup or Select, time window preferences (morning/afternoon/evening or specific time range), and scope selector (org-wide default vs team-level override). Store configuration in Convex with org_id/team_id foreign keys. The form should show current settings and allow saving changes with optimistic UI updates.\n\n**Context:** This is the configuration entry point - brokerage owners set the cadence here. Getting the UX right matters because overly aggressive check-ins will cause pushback, while too lenient defeats the accountability purpose.\n\n**Testing Requirements:**\n- **Unit Tests:** Test form validation (frequency required, valid time ranges), test save handler calls mutation with correct payload, test loading state shows current settings, test team-level override shows inheritance indicator from org default","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:26.433349-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:26.433349-06:00","labels":["frontend","settings"],"dependencies":[{"issue_id":"test-e8t6s1","depends_on_id":"test-e8t6","type":"parent-child","created_at":"2026-01-30T12:50:26.612551-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t6s2","title":"Build Convex schema and queries for check-in compliance data","description":"Create Convex schema for check_in_configs table (org_id, team_id nullable, frequency, time_window_start, time_window_end). Add queries: getComplianceStats(org_id, date_range) returning per-agent stats, getAgentCheckInHistory(agent_id, limit) for individual drill-down, getStreakData(org_id) for streak calculations. Compliance stats should calculate: completed count, missed count, completion_rate, current_streak, longest_streak per agent.\n\n**Context:** The compliance dashboard needs aggregated data efficiently. Pre-computing streaks and rates in queries (vs client-side) keeps the dashboard fast even with 100 agents.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getComplianceStats returns correct counts for mixed completed/missed check-ins, test streak calculation resets on miss, test date range filtering excludes out-of-range records, test team_id filter returns only team members","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:26.875208-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:26.875208-06:00","labels":["backend","convex"],"dependencies":[{"issue_id":"test-e8t6s2","depends_on_id":"test-e8t6","type":"parent-child","created_at":"2026-01-30T12:50:27.035463-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t6s3","title":"Implement compliance dashboard with agent status grid","description":"Build the compliance dashboard view showing all agents' check-in status. Use a data table (shadcn/ui Table or DataTable) with columns: agent name, last check-in date, status (completed/missed/upcoming), current streak, completion rate (last 30 days). Add visual indicators: green checkmark for completed, red X for missed, yellow clock for upcoming/due today. Include filters for team and date range. Add summary cards at top showing org-wide: total completion rate, agents with perfect streaks, agents needing attention (missed 2+).\n\n**Context:** This is the 'virtual sales manager' view - at a glance, managers see who's engaged vs who's slipping. The 'needing attention' metric is the actionable insight that drives follow-up conversations.\n\n**Testing Requirements:**\n- **Unit Tests:** Test status badge renders correct color/icon for each state, test completion rate formats as percentage, test team filter updates displayed agents, test summary cards calculate from visible data, test empty state when no check-ins exist","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":105,"created_at":"2026-01-30T12:50:27.325708-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:27.325708-06:00","labels":["dashboard","frontend"],"dependencies":[{"issue_id":"test-e8t6s3","depends_on_id":"test-e8t6","type":"parent-child","created_at":"2026-01-30T12:50:27.554552-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t6s3","depends_on_id":"test-e8t6s2","type":"blocks","created_at":"2026-01-30T12:52:14.058368-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t6s4","title":"Add completion trend chart and agent drill-down modal","description":"Enhance compliance dashboard with: 1) A line/area chart showing org completion rate over time (last 30/60/90 days) using existing chart library or recharts. 2) Clickable agent rows that open a modal/sheet showing that agent's check-in history (date, status, time completed), their personal trend, and streak details. This drill-down lets managers have specific conversations about patterns rather than just 'you missed check-ins'.\n\n**Context:** The trend chart shows if accountability is improving over time (value of the system). The drill-down enables managers to have data-driven 1:1s with specific agents about their engagement patterns.\n\n**Testing Requirements:**\n- **Unit Tests:** Test chart renders with mock time-series data, test date range selector updates chart data, test agent row click opens modal with correct agent_id, test modal displays check-in history in chronological order, test empty history state in modal","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:27.781507-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:27.781507-06:00","labels":["charts","dashboard","frontend"],"dependencies":[{"issue_id":"test-e8t6s4","depends_on_id":"test-e8t6","type":"parent-child","created_at":"2026-01-30T12:50:28.195969-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t6s4","depends_on_id":"test-e8t6s3","type":"blocks","created_at":"2026-01-30T12:52:14.30973-06:00","created_by":"David Habedank"}]}
{"id":"test-e9","title":"Organization \u0026 Team Management","description":"Build multi-tenant support for brokerages including organization setup, agent invitations, team structure, role-based permissions, and onboarding flows.\n\n**Context:** RealHerd sells to brokerages, not individual agents. Organizations need to invite agents, create teams, assign team leads, and configure settings at org and team levels. Role-based access controls who sees what.\n\n**Testing Requirements:**\n- **Unit Tests:** Permission checking logic, invitation token generation, role hierarchy validation\n- **Integration Tests:** Invitation flow end-to-end, onboarding call trigger, team assignment\n- **Type Tests:** Organization model, User roles, Team structure validation\n- **E2E Tests:** Broker creates org, invites agent, agent onboards, team lead created with correct permissions","acceptance_criteria":"- Organization creation with FUB API key configuration\n- Agent invitation flow via email and SMS\n- Agent onboarding welcome call explaining the system\n- Team creation with team lead assignment\n- Role-based permissions (broker sees all, team lead sees team, agent sees self)\n- Team-level settings can override org defaults\n- Agent activate/deactivate functionality\n- Org settings page with all configuration options","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:47:21.027658-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:21.027658-06:00","labels":["multi-tenant","onboarding","permissions","polish","production","teams","ux"],"dependencies":[{"issue_id":"test-e9","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:10:19.496303-06:00","created_by":"David Habedank"},{"issue_id":"test-e9","depends_on_id":"test-e7","type":"blocks","created_at":"2026-01-30T12:10:19.699137-06:00","created_by":"David Habedank"},{"issue_id":"test-e9","depends_on_id":"test-e8","type":"blocks","created_at":"2026-01-30T12:52:14.564376-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1","title":"Implement organization data model and creation flow","description":"Create the multi-tenant organization schema in Convex including organizations table with FUB API key storage, billing info, and settings. Build the organization creation flow for new brokerage signups.\n\n**Context:** RealHerd sells to brokerages, so organizations are the primary billing/subscription unit. Each org needs their own FUB API key to sync their CRM data. This is foundational - agents, teams, and all features are scoped to organizations.\n\n**Testing Requirements:**\n- **Unit Tests:** Organization creation mutation, FUB API key validation, settings merge logic, organization lookup queries\n- **Integration Tests:** Full org creation flow with Clerk, FUB API key validation against real FUB test account, organization membership syncing","design":"Convex schema: organizations table with id, name, fub_api_key (encrypted), settings (JSONB), created_at, subscription_status. Use Clerk's organization feature if available, or build custom org membership. FUB API key should be validated on save by making a test API call.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:54.931703-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:54.931703-06:00","labels":["backend","database","frontend","multi-tenant","onboarding","ux"],"dependencies":[{"issue_id":"test-e9t1","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:47:55.090569-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s1","title":"Create Convex organizations schema with all required fields","description":"Define the organizations table in Convex schema with fields: id (auto), name (string), fub_api_key (string, will store encrypted value), fub_api_key_validated (boolean), settings (object for org preferences), subscription_status (string enum: trial, active, past_due, cancelled), billing_email (optional string), created_at (number timestamp), updated_at (number timestamp). Include appropriate indexes for querying by subscription_status. Add TypeScript types for Organization and OrganizationSettings.\n\n**Context:** This is the foundational data model for multi-tenancy. Every other feature (agents, teams, deals) will be scoped to an organization. Getting this schema right is critical for data isolation and billing.\n\n**Testing Requirements:**\n- **Unit Tests:** Test schema validation rejects invalid subscription_status values, test required fields are enforced, test settings object accepts nested preferences, test indexes are created for common query patterns","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:28.534625-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:28.534625-06:00","labels":["backend","convex","database","frontend"],"dependencies":[{"issue_id":"test-e9t1s1","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:50:28.756045-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s2","title":"Implement FUB API key validation helper function","description":"Create a server-side helper function that validates a FUB API key by making a test API call to the FUB API (e.g., GET /v1/me or /v1/people?limit=1). Function should: accept API key as parameter, make authenticated request, return {valid: boolean, error?: string}. Handle common error cases: invalid key (401), rate limited (429), network errors. This will be called during org creation to ensure the API key works before saving.\n\n**Context:** Validating the FUB API key on save prevents organizations from being created with invalid credentials, which would cause sync failures later. Early validation improves user experience by catching config errors immediately.\n\n**Testing Requirements:**\n- **Unit Tests:** Test returns valid:true for successful API response, test returns valid:false with error message for 401, test handles 429 rate limit gracefully, test handles network timeout, test handles malformed API key format","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:29.071885-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:29.071885-06:00","labels":["backend","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e9t1s2","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:50:29.253753-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t1s2","depends_on_id":"test-e9t1s1","type":"blocks","created_at":"2026-01-30T12:52:14.825409-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s3","title":"Build organization creation mutation with API key validation","description":"Create a Convex mutation 'createOrganization' that: accepts name and fub_api_key, calls the FUB validation helper, only creates org if API key is valid, stores the API key (note: encryption to be added in security task), sets initial subscription_status to 'trial', returns the new organization or validation error. Also create 'getOrganization' and 'updateOrganization' queries/mutations for basic CRUD. Integrate with Clerk's organization feature if using Clerk, or track org membership separately.\n\n**Context:** This mutation is the entry point for new brokerage signups. The validation step ensures only organizations with working FUB connections are created, preventing broken states.\n\n**Testing Requirements:**\n- **Unit Tests:** Test createOrganization succeeds with valid API key, test createOrganization fails with invalid API key and returns error, test getOrganization returns null for non-existent org, test updateOrganization preserves existing fields not being updated, test subscription_status defaults to trial","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:29.48722-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:29.48722-06:00","labels":["api","backend","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e9t1s3","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:50:29.649427-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t1s3","depends_on_id":"test-e9t1s2","type":"blocks","created_at":"2026-01-30T12:52:15.159841-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s4","title":"Create organization setup UI component and flow","description":"Build a React component for organization creation with form fields: organization name (required), FUB API key (required, with helper text explaining where to find it in FUB settings). Show loading state during API key validation, display validation errors inline, redirect to dashboard on success. Include a link to FUB documentation for getting API keys. Wire up to the createOrganization mutation.\n\n**Context:** This is the first touchpoint for new brokerage customers. A clear, helpful UI that validates immediately reduces support burden and improves conversion from signup to active use.\n\n**Testing Requirements:**\n- **Unit Tests:** Test form validates required fields before submit, test displays loading spinner during API validation, test shows error message when API key invalid, test redirects to dashboard on successful creation, test helper text renders with FUB docs link","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:29.916663-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:29.916663-06:00","labels":["analytics","frontend","ui","ux"],"dependencies":[{"issue_id":"test-e9t1s4","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:50:30.080261-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t1s4","depends_on_id":"test-e9t1s3","type":"blocks","created_at":"2026-01-30T12:52:15.471005-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2","title":"Build agent invitation and onboarding flow","description":"Create the invitation system for brokers to invite agents via email and SMS. Include invite tracking, acceptance flow, and welcome onboarding that culminates in scheduling a welcome call to explain the system.\n\n**Context:** Brokerages need to onboard 20-100 agents efficiently. Agents receive invites, create accounts via Clerk, and get a welcome call explaining RealHerd. The welcome call is critical for adoption - agents who understand the 'why' behind accountability tracking are more likely to use the system.\n\n**Testing Requirements:**\n- **Unit Tests:** Invitation token generation/validation, expiration logic, SMS message formatting, onboarding step completion tracking\n- **Integration Tests:** Full invite flow via email and Telnyx SMS, Clerk account creation from invite, welcome call scheduling integration","design":"Convex schema: invitations table with token, org_id, email, phone, status, invited_by, expires_at. Use Telnyx for SMS invites. Onboarding wizard: 1) Accept invite, 2) Clerk signup, 3) Profile setup, 4) Schedule welcome call (use Calendly embed or custom scheduler). Track onboarding completion percentage.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:47:55.363144-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:55.363144-06:00","labels":["backend","design","frontend","onboarding","telnyx","ux"],"dependencies":[{"issue_id":"test-e9t2","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:47:55.56756-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2","depends_on_id":"test-e9t1","type":"blocks","created_at":"2026-01-30T12:52:15.847716-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s1","title":"Create invitation schema and generation API","description":"Create Convex invitations table with fields: token (unique, cryptographically secure), org_id, email, phone, status (pending/accepted/expired/revoked), invited_by (user_id), expires_at, created_at, accepted_at. Build mutation to generate invitations with 7-day expiration, unique tokens via crypto.randomUUID(), and validation that email isn't already a member of the org.\n\n**Context:** Invitations are the entry point for agent onboarding. Secure tokens prevent unauthorized access. Tracking status enables brokers to see who hasn't accepted yet and resend invites.\n\n**Testing Requirements:**\n- **Unit Tests:** Test createInvitation mutation: generates unique token, sets correct expiration, rejects duplicate email in same org, stores invited_by correctly. Test getInvitation query: returns null for expired tokens, returns invitation for valid tokens.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:30.28978-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:30.28978-06:00","labels":["backend","database","design-system","frontend"],"dependencies":[{"issue_id":"test-e9t2s1","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:50:30.462694-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s2","title":"Implement invitation sending via email and Telnyx SMS","description":"Create sendInvitation action that sends both email (via Resend/SendGrid) and SMS (via Telnyx) with personalized invite link containing token. Include brokerage name, inviter name, and clear CTA. Build Telnyx integration with proper error handling for invalid phone numbers. Create invite link format: /invite/[token].\n\n**Context:** Dual-channel delivery (email + SMS) maximizes invite visibility. Agents check SMS more frequently than email, but email provides a searchable record. Personalization increases acceptance rates.\n\n**Testing Requirements:**\n- **Unit Tests:** Test sendInvitation action: calls email provider with correct template data, calls Telnyx API with formatted phone number, handles Telnyx 400 errors gracefully, marks invitation as sent. Mock both external APIs.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:30.780785-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:30.780785-06:00","labels":["backend","design","frontend","integration"],"dependencies":[{"issue_id":"test-e9t2s2","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:50:30.953508-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2s2","depends_on_id":"test-e9t2s1","type":"blocks","created_at":"2026-01-30T12:52:16.109704-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s3","title":"Build invitation acceptance and Clerk signup flow","description":"Create /invite/[token] page that validates token (not expired, not used), displays brokerage info, and initiates Clerk signup. On Clerk signup completion, use webhook or useUser() to associate new user with org_id from invitation, update invitation status to 'accepted', and create agent record with org membership. Handle edge cases: expired token shows 'request new invite' message, already-accepted shows 'sign in instead'.\n\n**Context:** Seamless transition from invite to account creation is critical for conversion. Agents should never wonder what to do next. Automatic org association eliminates manual admin work for brokers.\n\n**Testing Requirements:**\n- **Unit Tests:** Test invite validation: rejects expired tokens, rejects already-accepted tokens, returns org details for valid tokens. Test post-signup hook: creates user-org membership, updates invitation status, handles race conditions if webhook fires twice.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:31.207097-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:31.207097-06:00","labels":["auth","backend","frontend","ux"],"dependencies":[{"issue_id":"test-e9t2s3","depends_on_id":"test-e9t2s2","type":"blocks","created_at":"2026-01-30T12:10:21.3924-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2s3","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:50:31.389145-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2s3","depends_on_id":"test-e9t2s1","type":"blocks","created_at":"2026-01-30T12:52:16.37572-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s4","title":"Create onboarding wizard with welcome call scheduling","description":"Build multi-step onboarding wizard after signup: 1) Profile setup (photo, phone, license number), 2) Brief intro to RealHerd value prop (what brokers see, why accountability helps), 3) Schedule welcome call via Calendly embed (use their React component or iframe). Track onboarding_completed_at and onboarding_step in user record. Show progress indicator. Allow skip-for-now on call scheduling but mark as incomplete.\n\n**Context:** The welcome call is the highest-leverage moment for adoption. Agents who understand WHY their broker wants pipeline visibility (to help, not micromanage) embrace the tool. The wizard builds trust before asking for the commitment of a call.\n\n**Testing Requirements:**\n- **Unit Tests:** Test profile update mutation: validates required fields, stores photo URL correctly. Test onboarding progress tracking: correctly increments step, marks complete only when all steps done or call scheduled. Test Calendly embed: renders correctly, fires callback on booking.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":105,"created_at":"2026-01-30T12:50:31.687496-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:31.687496-06:00","labels":["backend","frontend","polish","testing"],"dependencies":[{"issue_id":"test-e9t2s4","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:50:31.869628-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2s4","depends_on_id":"test-e9t2s3","type":"blocks","created_at":"2026-01-30T12:52:16.684327-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3","title":"Implement team structure and team lead assignment","description":"Build the team management system allowing brokers to create teams, assign agents to teams, and designate team leads. Teams can have their own settings that override org defaults.\n\n**Context:** Brokerages organize agents into teams of 4-12 people. Team leads need visibility into their team's pipeline without seeing the whole brokerage. Team-level settings (e.g., different call quotas, different notification preferences) allow customization without affecting the whole org.\n\n**Testing Requirements:**\n- **Unit Tests:** Team creation, member assignment, team lead promotion, settings inheritance/merge logic, team deletion with member handling\n- **Integration Tests:** Create team, add members, assign lead, verify settings cascade correctly, verify team lead can see only team data","design":"Convex schema: teams table with org_id, name, team_lead_id, settings (JSONB, nullable - null means inherit from org). team_memberships table linking agents to teams. An agent can be on one team (simplify v1). Settings inheritance: team.settings ?? org.settings for each setting key.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:55.793709-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:55.793709-06:00","labels":["backend","database","error-handling","frontend","teams","ux"],"dependencies":[{"issue_id":"test-e9t3","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:47:55.990117-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3","depends_on_id":"test-e9t1","type":"blocks","created_at":"2026-01-30T12:52:17.296787-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3","depends_on_id":"test-e9t2","type":"blocks","created_at":"2026-01-30T12:52:17.584314-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s1","title":"Create Convex schema for teams and team_memberships tables","description":"Define the teams table with fields: _id, org_id (reference to organizations), name (string), team_lead_id (optional reference to users), settings (optional object for JSONB-style overrides), created_at, updated_at. Define team_memberships table with: _id, team_id (reference to teams), user_id (reference to users), joined_at. Add index on team_memberships for user_id to enforce one-team-per-agent constraint in v1. Add index on teams for org_id.\n\n**Context:** Teams are the organizational unit between org and individual agent. The schema must support settings inheritance (null settings means inherit from org) and the constraint that agents belong to exactly one team in v1.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify schema compiles with npx convex dev. Test that teams table accepts null settings. Test that team_memberships properly references both teams and users tables.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:50:32.130222-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:32.130222-06:00","labels":["backend","database","error-handling","frontend"],"dependencies":[{"issue_id":"test-e9t3s1","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:50:32.287491-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s2","title":"Implement team CRUD mutations with org-scoped access control","description":"Create mutations: createTeam(orgId, name, teamLeadId?, settings?), updateTeam(teamId, name?, teamLeadId?, settings?), deleteTeam(teamId). All mutations must verify the calling user has broker/admin role in the org. createTeam should validate teamLeadId belongs to the org if provided. deleteTeam should also remove all team_memberships. Implement getTeamsByOrg query for listing teams.\n\n**Context:** Brokers need to manage team structure. Only org admins/brokers can create or modify teams. Team deletion must cascade to memberships to prevent orphaned records.\n\n**Testing Requirements:**\n- **Unit Tests:** Test createTeam creates team with correct org_id. Test updateTeam only works for users with broker role. Test deleteTeam removes associated memberships. Test createTeam rejects teamLeadId not in org. Test getTeamsByOrg returns only teams for specified org.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:32.506521-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:32.506521-06:00","labels":["api","backend","error-handling","frontend"],"dependencies":[{"issue_id":"test-e9t3s2","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:50:32.6583-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s2","depends_on_id":"test-e9t3s1","type":"blocks","created_at":"2026-01-30T12:52:17.828728-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s3","title":"Implement team membership mutations with one-team constraint","description":"Create mutations: addAgentToTeam(teamId, userId), removeAgentFromTeam(teamId, userId), transferAgent(userId, newTeamId). addAgentToTeam must first check if user is already on a team and reject if so (v1 constraint). transferAgent handles the atomic removal from old team and addition to new team. Implement getTeamMembers(teamId) and getAgentTeam(userId) queries.\n\n**Context:** Agents can only be on one team in v1 to simplify permissions and reporting. The transfer operation needs to be atomic to prevent agents being on zero or multiple teams during the operation.\n\n**Testing Requirements:**\n- **Unit Tests:** Test addAgentToTeam fails if agent already on a team. Test removeAgentFromTeam properly deletes membership. Test transferAgent atomically moves agent (no intermediate state with 0 or 2 teams). Test getTeamMembers returns correct list. Test getAgentTeam returns null for unassigned agents.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:32.87997-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:32.87997-06:00","labels":["api","backend","frontend","loading-states"],"dependencies":[{"issue_id":"test-e9t3s3","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:50:33.080387-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s3","depends_on_id":"test-e9t3s1","type":"blocks","created_at":"2026-01-30T12:52:18.125934-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s4","title":"Implement settings inheritance helper and team lead assignment","description":"Create a getEffectiveSettings(teamId) function that merges team.settings with org.settings, with team settings taking precedence for any defined keys. Create assignTeamLead(teamId, userId) mutation that validates userId is a member of the team before assignment. Create getTeamForLead(userId) query that returns teams where user is team_lead_id.\n\n**Context:** Settings inheritance allows teams to customize specific settings while inheriting org defaults for others. Team leads must be members of their team to ensure they have context for the agents they're leading.\n\n**Testing Requirements:**\n- **Unit Tests:** Test getEffectiveSettings returns org settings when team settings is null. Test getEffectiveSettings merges correctly (team overrides org for same key, org provides defaults for missing keys). Test assignTeamLead fails if user not on team. Test assignTeamLead succeeds and updates team_lead_id. Test getTeamForLead returns correct team(s).","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:33.321565-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:33.321565-06:00","labels":["api","backend","error-handling","frontend","integration"],"dependencies":[{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3s1","type":"blocks","created_at":"2026-01-30T12:10:21.860179-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:50:33.537207-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3s2","type":"blocks","created_at":"2026-01-30T12:52:18.46825-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3s3","type":"blocks","created_at":"2026-01-30T12:52:18.941588-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4","title":"Build role-based permissions system","description":"Implement RBAC with three core roles: broker (sees all org data), team_lead (sees team data), agent (sees only self). Create permission checking utilities and apply them to all data queries.\n\n**Context:** Data visibility is critical for trust. Agents shouldn't see each other's pipelines. Team leads need accountability over their team. Brokers need the full picture. Getting permissions wrong breaks trust and potentially violates privacy expectations.\n\n**Testing Requirements:**\n- **Unit Tests:** Permission check functions for each role combination, edge cases (agent with no team, team lead viewing non-team member, broker viewing any agent)\n- **Integration Tests:** End-to-end permission checks: broker dashboard shows all agents, team lead dashboard shows only team, agent dashboard shows only self","design":"Roles: broker, team_lead, agent stored on user membership. Create canViewAgent(viewerId, targetAgentId) utility that checks: same person, team lead of their team, or broker. Apply to all agent-specific queries. Consider Convex's built-in auth patterns. Add role to Clerk user metadata for quick access.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:56.224086-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:56.224086-06:00","labels":["backend","frontend","rbac","security","settings"],"dependencies":[{"issue_id":"test-e9t4","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:47:56.485685-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4","depends_on_id":"test-e9t3","type":"blocks","created_at":"2026-01-30T12:52:19.194882-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s1","title":"Define role types and permission schema","description":"Create TypeScript types for the three roles (broker, team_lead, agent) and add role field to organization membership schema. Define the Role enum type, update the organizationMemberships table to include role field with appropriate default (agent), and create types for permission contexts.\n\n**Context:** Clean type definitions prevent permission bugs. The role field on membership is the source of truth for all permission checks throughout the app.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that Role type only accepts 'broker' | 'team_lead' | 'agent', verify schema migration adds role field with 'agent' default, test that existing memberships get default role","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:33.874643-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:33.874643-06:00","labels":["auth","backend","database","frontend"],"dependencies":[{"issue_id":"test-e9t4s1","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:50:34.049159-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s2","title":"Implement core permission checking utilities","description":"Create permission utility functions: getUserRole(ctx, userId, orgId) to fetch user's role, canViewAgent(ctx, viewerId, targetAgentId) that returns true if same person OR viewer is team_lead of target's team OR viewer is broker in same org. Also create canEditAgent(), isOrgBroker(), isTeamLead() helper functions.\n\n**Context:** Centralized permission logic prevents scattered, inconsistent checks. Every data query will use these utilities, so they must be correct and performant.\n\n**Testing Requirements:**\n- **Unit Tests:** Test canViewAgent returns true for same user, true for broker viewing any org agent, true for team_lead viewing team member, false for team_lead viewing other team's agent, false for agent viewing another agent. Test edge cases: user not in org, invalid IDs","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:34.264172-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:34.264172-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e9t4s2","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:50:34.441216-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s2","depends_on_id":"test-e9t4s1","type":"blocks","created_at":"2026-01-30T12:52:19.468355-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s3","title":"Apply permission checks to all agent-specific queries","description":"Audit and update all Convex queries that return agent-specific data (pipelines, contacts, activities, deals) to use the permission utilities. Add withPermissionCheck wrapper or inline checks. Ensure queries throw appropriate errors for unauthorized access rather than returning empty results.\n\n**Context:** This is where RBAC becomes real. Without applying checks to actual queries, the permission utilities are unused code. Every endpoint that could leak cross-agent data must be protected.\n\n**Testing Requirements:**\n- **Unit Tests:** Test that getPipeline throws for unauthorized viewer, test that listDeals filters correctly by role, test broker sees all org data, test agent only sees own data, test team_lead sees exactly their team's data","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:34.692259-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:34.692259-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e9t4s3","depends_on_id":"test-e9t4s1","type":"blocks","created_at":"2026-01-30T12:10:23.256454-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s3","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:50:34.850366-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s3","depends_on_id":"test-e9t4s2","type":"blocks","created_at":"2026-01-30T12:52:19.780186-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s4","title":"Add role management UI and verify end-to-end","description":"Create UI for brokers to assign/change roles (in org settings or member list). Add role display to team member views. Test complete flow: create org, invite agents, assign team_lead, verify data visibility matches expectations. Run dev server and manually verify each role can only see appropriate data.\n\n**Context:** Role assignment needs to be accessible to brokers without requiring database access. End-to-end verification catches integration issues that unit tests miss.\n\n**Testing Requirements:**\n- **Unit Tests:** Test role change mutation validates only broker can change roles, test role change emits appropriate audit event, integration test: full flow of broker assigning team_lead and verifying permissions change","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:35.376327-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:35.376327-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e9t4s4","depends_on_id":"test-e9t4s1","type":"blocks","created_at":"2026-01-30T12:10:23.46503-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s4","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:50:35.609458-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s4","depends_on_id":"test-e9t4s3","type":"blocks","created_at":"2026-01-30T12:52:20.052707-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5","title":"Create organization and team settings UI","description":"Build the settings pages for organization configuration (FUB API key, notification defaults, branding) and team settings (overrides). Include agent activate/deactivate functionality for managing agent access.\n\n**Context:** Brokers need self-service configuration. Common settings: FUB API key rotation, default notification preferences, call recording policies, team-specific quotas. Agent deactivation is important when agents leave - their data stays for reporting but they can't log in.\n\n**Testing Requirements:**\n- **Unit Tests:** Settings form validation, FUB API key masking/reveal logic, agent status toggle mutations\n- **Integration Tests:** Full settings update flow, verify FUB connection test works, verify deactivated agent cannot access system, verify team settings properly override org defaults","design":"Next.js pages: /settings/organization, /settings/teams/[teamId]. Use shadcn/ui form components. FUB API key field with 'Test Connection' button. Agent list with activate/deactivate toggle (soft delete - set status, don't remove). Settings form with clear inheritance indicators ('Using org default' badge on team settings).","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:47:56.698978-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:56.698978-06:00","labels":["devops","frontend","monitoring","performance","settings","shadcn"],"dependencies":[{"issue_id":"test-e9t5","depends_on_id":"test-e9t2","type":"blocks","created_at":"2026-01-30T12:10:24.270108-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5","depends_on_id":"test-e9t3","type":"blocks","created_at":"2026-01-30T12:10:24.463416-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:47:56.850988-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5","depends_on_id":"test-e9t4","type":"blocks","created_at":"2026-01-30T12:52:20.340739-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s1","title":"Create organization settings page with FUB API configuration","description":"Build /settings/organization page with shadcn/ui form components. Include sections for: FUB API key input with masked display and 'Test Connection' button that validates the key against FUB API, notification defaults (email/SMS preferences, frequency settings), call recording policy toggle, and basic branding options (logo upload, primary color). Use React Hook Form with Zod validation. API key should show last 4 characters when saved.\n\n**Context:** FUB API key is critical - brokers need to connect their Follow Up Boss account. Test Connection gives immediate feedback that their key works before saving.\n\n**Testing Requirements:**\n- **Unit Tests:** Test form validation for required fields, test API key masking shows only last 4 chars, test 'Test Connection' button calls validation endpoint and shows success/error states, test form submission calls correct API endpoint with sanitized data","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:50:35.903777-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:35.903777-06:00","labels":["frontend","performance","settings"],"dependencies":[{"issue_id":"test-e9t5s1","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:50:36.086102-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s2","title":"Build team settings page with inheritance indicators","description":"Create /settings/teams/[teamId] page showing team-specific overrides. Display each setting with 'Using org default' badge when not overridden, and 'Custom' badge when team has own value. Include: notification preferences override, team-specific quotas (deal count thresholds, activity minimums), team lead assignment dropdown. Form should allow clearing overrides to revert to org defaults.\n\n**Context:** Team leads may want different settings than org defaults. Clear inheritance indicators prevent confusion about which settings are active. Reverting to defaults keeps configuration manageable.\n\n**Testing Requirements:**\n- **Unit Tests:** Test inheritance badge shows 'Using org default' when team setting is null, test 'Custom' badge appears when override exists, test clearing override reverts to org default value in UI, test form only submits changed fields","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:36.353617-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:36.353617-06:00","labels":["backend","convex","frontend","performance","settings"],"dependencies":[{"issue_id":"test-e9t5s2","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:50:36.540923-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s2","depends_on_id":"test-e9t5s1","type":"blocks","created_at":"2026-01-30T12:52:20.625839-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s3","title":"Implement agent list with activate/deactivate functionality","description":"Add agent management section to organization settings. Display table of all agents with columns: name, email, team, status (active/inactive), last login date. Include activate/deactivate toggle per agent that performs soft delete (sets status field, preserves data). Add confirmation modal for deactivation explaining data retention. Filter/search by name, team, status.\n\n**Context:** When agents leave the brokerage, their historical data must remain for reporting and compliance. Deactivation prevents login while preserving deal history and activity records.\n\n**Testing Requirements:**\n- **Unit Tests:** Test toggle calls API with correct agent ID and new status, test confirmation modal appears before deactivation, test inactive agents show visual distinction (grayed row), test search filters agent list correctly, test status filter works","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:36.772533-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:36.772533-06:00","labels":["frontend","performance","settings"],"dependencies":[{"issue_id":"test-e9t5s3","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:50:37.045511-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s3","depends_on_id":"test-e9t5s1","type":"blocks","created_at":"2026-01-30T12:52:21.307782-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s4","title":"Wire settings pages to API and verify end-to-end functionality","description":"Connect all settings forms to backend API endpoints. Implement optimistic updates with rollback on error. Add toast notifications for save success/failure. Ensure FUB API test connection shows loading state and detailed error messages (invalid key, rate limited, network error). Test complete flow: update org setting → verify team inherits → override at team level → deactivate agent → verify agent cannot access app.\n\n**Context:** Settings changes must persist correctly and provide clear feedback. The inheritance chain (org → team → agent) is core to multi-tenant configuration.\n\n**Testing Requirements:**\n- **Unit Tests:** Test API integration with MSW mocks for success and error cases, test optimistic update reverts on API failure, test toast messages appear for all outcomes, test FUB connection error messages are user-friendly","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:37.344973-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:37.344973-06:00","labels":["devops","frontend","integration","monitoring","testing"],"dependencies":[{"issue_id":"test-e9t5s4","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:50:37.575976-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s4","depends_on_id":"test-e9t5s1","type":"blocks","created_at":"2026-01-30T12:52:21.593747-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s4","depends_on_id":"test-e9t5s2","type":"blocks","created_at":"2026-01-30T12:52:21.869611-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s4","depends_on_id":"test-e9t5s3","type":"blocks","created_at":"2026-01-30T12:52:22.241168-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t6","title":"Verify organization and team management end-to-end","description":"Test the complete multi-tenant workflow: create org, configure FUB, invite agents, create teams, assign roles, verify permissions work correctly across all views.\n\n**Context:** Multi-tenant systems have complex permission interactions. This verification ensures a broker can onboard their entire team and that data isolation works correctly - critical for selling to brokerages who need to trust their agents' data is protected.\n\n**Testing Requirements:**\n- **Unit Tests:** N/A - this is an integration verification task\n- **Integration Tests:** Full E2E test with Playwright: org creation → agent invites → team setup → permission verification across all three roles","design":"Create test scenario: 1 org, 2 teams, 1 broker, 2 team leads, 6 agents. Verify: broker sees all 8 people, team lead A sees only their 3 agents, agent sees only self. Test edge cases: team lead viewing cross-team agent (should fail), deactivated agent login (should fail), settings inheritance.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:47:57.085613-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:47:57.085613-06:00","labels":["e2e","testing","verification"],"dependencies":[{"issue_id":"test-e9t6","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:47:57.244999-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t6","depends_on_id":"test-e9t5","type":"blocks","created_at":"2026-01-30T12:52:22.525892-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t6s1","title":"Create test organization with complete team hierarchy","description":"Set up the test scenario: create 1 organization, 2 teams (Team A, Team B), and 8 user accounts with roles: 1 broker (org owner), 2 team leads (1 per team), 6 agents (3 per team). Configure FUB API credentials at org level. Ensure all users are properly assigned to their teams with correct roles.\n\n**Context:** This establishes the complete test hierarchy needed to verify all permission boundaries. The 1-2-6 structure (broker-leads-agents) mirrors real brokerage org charts and tests all three permission levels.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify org created with correct settings, verify all 8 users exist with correct roles (1 broker, 2 team_lead, 5 agent), verify team assignments (3 agents + 1 lead per team), verify FUB credentials stored at org level","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:50:37.84007-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:37.84007-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e9t6s1","depends_on_id":"test-e9t6","type":"parent-child","created_at":"2026-01-30T12:50:38.140033-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t6s2","title":"Test broker-level visibility and access","description":"Login as broker account and verify: can see all 8 users in user management, can view activity/pipelines for all teams, can access org settings and FUB configuration, can create/edit/delete teams, can change any user's role or team assignment. Test that broker dashboard shows aggregate metrics across all teams.\n\n**Context:** Brokers pay for RealHerd and need complete visibility into their organization. This verifies the 'god mode' access that makes the product valuable to brokerage owners who need pipeline visibility across 20-100 agents.\n\n**Testing Requirements:**\n- **Unit Tests:** Assert broker sees 8 users in list, assert broker can view Team A and Team B pipelines, assert org settings page accessible, assert team CRUD operations succeed, assert dashboard metrics include all 8 users' data","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:38.396618-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:38.396618-06:00","labels":["backend","frontend","testing"],"dependencies":[{"issue_id":"test-e9t6s2","depends_on_id":"test-e9t6","type":"parent-child","created_at":"2026-01-30T12:50:38.665066-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t6s2","depends_on_id":"test-e9t6s1","type":"blocks","created_at":"2026-01-30T12:52:22.780367-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t6s3","title":"Test team lead visibility and permission boundaries","description":"Login as Team Lead A and verify: can see only their 3 agents (not Team B's 3 agents), can view pipeline/activity for their team only, cannot access org-level settings or FUB configuration, cannot modify other team's users. Then login as Team Lead B and verify same isolation. Test cross-team access attempts return 403 forbidden.\n\n**Context:** Team leads managing 4-12 agents need real-time deal visibility for their team only. This tests the critical middle-tier permission boundary - team leads should never see other teams' sensitive deal data.\n\n**Testing Requirements:**\n- **Unit Tests:** Assert Team Lead A sees exactly 3 agents, assert Team Lead A cannot fetch Team B agent list (403), assert Team Lead A cannot access /api/org/settings (403), assert Team Lead A pipeline query returns only Team A deals, assert same tests pass for Team Lead B with inverse team visibility","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:50:38.963033-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:38.963033-06:00","labels":["backend","security","testing"],"dependencies":[{"issue_id":"test-e9t6s3","depends_on_id":"test-e9t6","type":"parent-child","created_at":"2026-01-30T12:50:39.218401-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t6s3","depends_on_id":"test-e9t6s1","type":"blocks","created_at":"2026-01-30T12:52:23.121663-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t6s4","title":"Test agent-level isolation and edge cases","description":"Login as agent and verify: can only see own profile and activity, cannot see other agents even on same team, cannot access team management. Test edge cases: 1) Team lead attempting to view cross-team agent profile (should 403), 2) Deactivated agent login attempt (should fail auth), 3) Settings inheritance (agent inherits team settings, team inherits org settings), 4) Agent trying to access admin routes (403).\n\n**Context:** Data isolation is critical for selling to brokerages - they need to trust that competitive agents on the same team can't spy on each other's pipelines. Edge cases catch permission escalation vulnerabilities.\n\n**Testing Requirements:**\n- **Unit Tests:** Assert agent profile shows only self, assert agent cannot list other agents (403), assert deactivated user auth returns 401, assert agent inherits correct notification settings from team→org cascade, assert agent accessing /api/admin/* returns 403, assert audit log captures all permission denial events","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:50:39.446077-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:50:39.446077-06:00","labels":["backend","security","testing"],"dependencies":[{"issue_id":"test-e9t6s4","depends_on_id":"test-e9t6","type":"parent-child","created_at":"2026-01-30T12:50:39.606383-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t6s4","depends_on_id":"test-e9t6s2","type":"blocks","created_at":"2026-01-30T12:52:23.407036-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t6s4","depends_on_id":"test-e9t6s3","type":"blocks","created_at":"2026-01-30T12:52:23.77033-06:00","created_by":"David Habedank"}]}
