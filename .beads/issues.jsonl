{"id":"test-e1","title":"Project Foundation \u0026 Core Setup","description":"Initialize the project infrastructure including Next.js 16 app, Convex backend with schema, Clerk authentication with role-based access, and basic dashboard shell. This establishes the foundation all features will build upon.\n\n**Context:** Before any voice or CRM features can be built, the project needs a solid foundation with authentication, database, and basic UI structure. This epic ensures all subsequent development has the infrastructure it needs.","acceptance_criteria":"- Can run npm dev and see basic Next.js app with RealHerd branding\n- Convex backend is connected with organization, user, team, and call schemas\n- Clerk authentication works with broker, team_lead, and agent roles\n- Basic dashboard shell renders with navigation and settings placeholder\n- Tailwind v4 + shadcn/ui configured with RealHerd color palette\n- Environment variables configured for Convex, Clerk","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1440,"created_at":"2026-01-30T12:06:55.504763-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:55.504763-06:00","labels":["auth","foundation","infrastructure"]}
{"id":"test-e1t1","title":"Initialize Next.js 16 project with Tailwind v4 and shadcn/ui","description":"Create the foundational Next.js 16 application with Tailwind CSS v4 configuration and shadcn/ui component library setup. Configure the RealHerd color palette and basic theming.\n\n**Context:** This is the absolute foundation - every feature, every page, every component depends on this project structure being in place. Brokerage owners and agents will interact with RealHerd through this UI, so getting the styling foundation right from the start ensures consistent branding.","design":"Use create-next-app with App Router. Configure tailwind.config.js with RealHerd brand colors (suggest professional blues/greens for trust). Initialize shadcn/ui with 'npx shadcn@latest init'. Set up basic folder structure: /app, /components, /lib, /convex.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":180,"created_at":"2026-01-30T12:06:57.591434-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:57.591434-06:00","labels":["foundation","frontend","setup"],"dependencies":[{"issue_id":"test-e1t1","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:06:57.698433-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s1","title":"Create Next.js 16 project with App Router","description":"Run 'npx create-next-app@latest realherd' with the following options: TypeScript (yes), ESLint (yes), Tailwind CSS (yes), src/ directory (no), App Router (yes), import alias (@/*). This creates the base project structure with /app, /public directories and initial configuration files.\n\n**Context:** Next.js 16 with App Router is the foundation for all UI development. The App Router provides server components by default, better data fetching patterns, and improved performance that RealHerd needs for responsive agent dashboards.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:16.248608-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:16.248608-06:00","labels":["backend","frontend","setup"],"dependencies":[{"issue_id":"test-e1t1s1","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:07:16.443586-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s2","title":"Configure Tailwind v4 with RealHerd brand colors","description":"Update tailwind.config.ts to define RealHerd brand colors: primary (professional blue #1E40AF for trust), secondary (green #059669 for growth/success), accent colors, and semantic colors (success, warning, error). Configure CSS custom properties in globals.css for light/dark mode support. Define spacing scale and typography that works for data-heavy CRM interfaces.\n\n**Context:** Brokerage owners and agents need a professional, trustworthy interface. Blue conveys reliability and trust (important for financial/real estate software), while green accents suggest growth and positive outcomes for lead conversion tracking.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:16.670557-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:16.670557-06:00","labels":["backend","frontend","schema","styling"],"dependencies":[{"issue_id":"test-e1t1s2","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:07:17.388949-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s2","depends_on_id":"test-e1t1s1","type":"blocks","created_at":"2026-01-30T12:09:13.430611-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s3","title":"Initialize shadcn/ui with themed components","description":"Run 'npx shadcn@latest init' selecting: TypeScript (yes), style (New York), base color (Blue to match brand), CSS variables (yes), tailwind.config.ts location, components alias (@/components), utils alias (@/lib/utils). Then install initial essential components: button, card, input, label, dropdown-menu, dialog, toast. Update the generated CSS variables to use RealHerd brand colors.\n\n**Context:** shadcn/ui provides accessible, customizable components that maintain RealHerd's brand identity. These foundational components (buttons, cards, inputs) will be used across every feature - from agent dashboards to lead management forms.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:17.837088-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:17.837088-06:00","labels":["backend","components","frontend","relationships","schema"],"dependencies":[{"issue_id":"test-e1t1s3","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:07:18.014127-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s3","depends_on_id":"test-e1t1s2","type":"blocks","created_at":"2026-01-30T12:09:13.72196-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t1s4","title":"Set up project folder structure and verify build","description":"Create the standard folder structure: /components/ui (shadcn components), /components/shared (shared components), /lib (utilities), /convex (placeholder for Convex setup), /hooks, /types. Create a simple home page in /app/page.tsx that displays RealHerd branding with a heading, tagline, and styled button to verify the full stack works together. Run production build to catch any configuration issues.\n\n**Context:** A clean, predictable folder structure makes it easy for the team to navigate the codebase and for AI assistants to understand where to place new code. Verifying the production build early catches SSR/hydration issues before they compound.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:18.23319-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:18.23319-06:00","labels":["backend","documentation","frontend","setup","testing"],"dependencies":[{"issue_id":"test-e1t1s4","depends_on_id":"test-e1t1","type":"parent-child","created_at":"2026-01-30T12:07:18.386067-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t1s4","depends_on_id":"test-e1t1s3","type":"blocks","created_at":"2026-01-30T12:09:14.174342-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2","title":"Set up Convex backend with core database schemas","description":"Initialize Convex backend and define the core database schemas: organizations, users, teams, and calls. These tables form the data foundation for the entire CRM and voice features.\n\n**Context:** Every CRM feature needs to store and retrieve data. The organization/team/user hierarchy reflects how real estate brokerages actually operate - brokers own organizations with teams led by team_leads containing agents. The calls schema will power the AI voice assistant features.","design":"Install convex, run npx convex init. Define schemas in convex/schema.ts with proper indexes. Organizations have many teams, teams have many users. Calls reference users and include fields for: phone_number, direction, status, recording_url, transcript, extracted_data, duration, timestamps.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:06:57.863148-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:57.863148-06:00","labels":["backend","convex","database"],"dependencies":[{"issue_id":"test-e1t2","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:06:57.98221-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2","depends_on_id":"test-e1t1","type":"blocks","created_at":"2026-01-30T12:09:14.884446-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s1","title":"Install and initialize Convex backend","description":"Install Convex dependencies and run initialization. Execute: npm install convex, then npx convex init. This creates the convex/ directory structure and connects to Convex cloud. Verify the convex/_generated folder is created and .env.local contains CONVEX_DEPLOYMENT.\n\n**Context:** Convex provides the real-time database backend that powers all data operations. Proper initialization ensures the project can deploy functions and sync schemas.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":15,"created_at":"2026-01-30T12:07:18.574007-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:18.574007-06:00","labels":["auth","backend","frontend","setup"],"dependencies":[{"issue_id":"test-e1t2s1","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:07:18.738318-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s2","title":"Define organizations and users schemas","description":"Create convex/schema.ts with organizations and users tables. Organizations: id, name, subscription_tier, created_at, updated_at, owner_id. Users: id, clerk_id, organization_id, email, name, role (enum: owner, team_lead, agent), phone, avatar_url, created_at. Add indexes on users.organization_id, users.clerk_id, and users.email for efficient queries.\n\n**Context:** Organizations represent brokerages, users are the agents/leads/owners within them. The role field enables permission hierarchies - owners manage everything, team_leads manage their team, agents see only their data.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:19.021403-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:19.021403-06:00","labels":["auth","backend","database"],"dependencies":[{"issue_id":"test-e1t2s2","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:07:19.189466-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s2","depends_on_id":"test-e1t2s1","type":"blocks","created_at":"2026-01-30T12:09:15.387075-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s3","title":"Define teams schema with organization relationship","description":"Add teams table to convex/schema.ts. Fields: id, organization_id, name, team_lead_id (references users), created_at, updated_at. Add index on teams.organization_id. This creates the middle tier of the org hierarchy - teams belong to organizations and contain users.\n\n**Context:** Real estate brokerages organize agents into teams led by team_leads. This structure enables team-level reporting, lead distribution, and management without giving every agent org-wide access.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":20,"created_at":"2026-01-30T12:07:19.412129-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:19.412129-06:00","labels":["auth","backend","database","security"],"dependencies":[{"issue_id":"test-e1t2s3","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:07:19.584647-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s3","depends_on_id":"test-e1t2s2","type":"blocks","created_at":"2026-01-30T12:09:16.083304-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t2s4","title":"Define calls schema for voice assistant integration","description":"Add calls table to convex/schema.ts. Fields: id, user_id (who made/received call), organization_id, contact_id (optional, linked lead), phone_number, direction (enum: inbound, outbound), status (enum: initiated, ringing, in_progress, completed, failed, voicemail), recording_url (optional), transcript (optional), extracted_data (optional, JSON for AI-parsed info like lead details), duration_seconds, started_at, ended_at, created_at. Add indexes on calls.user_id, calls.organization_id, calls.phone_number, calls.started_at.\n\n**Context:** The calls schema powers the AI voice assistant feature - the core differentiator of RealHerd. It captures full call lifecycle, recordings for playback/review, AI-generated transcripts, and structured data extracted by the AI (e.g., lead name, property interest, appointment requests).","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:19.884549-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:19.884549-06:00","labels":["auth","backend","database","frontend","integration","voice"],"dependencies":[{"issue_id":"test-e1t2s4","depends_on_id":"test-e1t2","type":"parent-child","created_at":"2026-01-30T12:07:20.047016-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t2s4","depends_on_id":"test-e1t2s2","type":"blocks","created_at":"2026-01-30T12:09:16.562485-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3","title":"Integrate Clerk authentication with role-based access","description":"Set up Clerk authentication with three roles: broker (organization owner), team_lead (manages a team), and agent (individual user). Configure middleware for protected routes and role-based access control.\n\n**Context:** Different users have different permissions - brokers see organization-wide analytics, team_leads see their team's data, agents see only their own calls. This role hierarchy is critical for enterprise sales to brokerages who need data isolation between teams.","design":"Install @clerk/nextjs. Configure ClerkProvider in layout.tsx. Set up middleware.ts for route protection. Use Clerk's publicMetadata for roles. Create helper functions: getUserRole(), canAccessTeam(), canAccessOrganization(). Sync Clerk users to Convex users table on sign-up via webhook.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:06:58.147884-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:58.147884-06:00","labels":["auth","clerk","security"],"dependencies":[{"issue_id":"test-e1t3","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:06:58.280582-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3","depends_on_id":"test-e1t1","type":"blocks","created_at":"2026-01-30T12:09:16.884334-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3","depends_on_id":"test-e1t2","type":"blocks","created_at":"2026-01-30T12:09:17.543758-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s1","title":"Install and configure Clerk with ClerkProvider","description":"Install @clerk/nextjs package. Create Clerk application in dashboard and obtain API keys. Add CLERK_PUBLISHABLE_KEY and CLERK_SECRET_KEY to .env.local. Wrap the root layout.tsx with ClerkProvider. Verify basic auth flow works by testing sign-in/sign-up pages.\n\n**Context:** Clerk provides the foundation for all authentication. Without this setup, no protected routes or role-based access can function. The ClerkProvider must wrap the entire app to provide auth context to all components.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:20.240918-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:20.240918-06:00","labels":["auth","backend","frontend","setup","telephony"],"dependencies":[{"issue_id":"test-e1t3s1","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:07:20.399525-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s2","title":"Configure middleware for protected routes","description":"Create middleware.ts in project root. Configure Clerk's authMiddleware with publicRoutes for landing page, sign-in, sign-up, and API webhooks. Set up route matchers for protected areas: /dashboard/*, /api/* (except webhooks). Test that unauthenticated users are redirected to sign-in.\n\n**Context:** Middleware runs on every request and is the first line of defense for route protection. This ensures users cannot access any dashboard or API routes without being authenticated, which is critical for data security in a multi-tenant brokerage application.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:20.657062-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:20.657062-06:00","labels":["auth","backend","convex","middleware","telephony"],"dependencies":[{"issue_id":"test-e1t3s2","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:07:20.875738-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s2","depends_on_id":"test-e1t3s1","type":"blocks","created_at":"2026-01-30T12:09:18.293138-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s3","title":"Implement role system with helper functions","description":"Define UserRole type: 'broker' | 'team_lead' | 'agent'. Create lib/auth/roles.ts with helper functions: getUserRole(userId) - reads from Clerk publicMetadata, canAccessTeam(userId, teamId) - checks if user is broker, or team_lead of that team, or agent in that team, canAccessOrganization(userId, orgId) - checks if user belongs to org. Add role assignment UI component for brokers to assign roles via Clerk's user management API.\n\n**Context:** The three-tier role hierarchy (broker \u003e team_lead \u003e agent) maps directly to real estate brokerage structure. Brokers own the organization and see everything. Team leads manage subsets of agents. Agents only see their own data. These helpers will be used throughout the app for authorization checks.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:21.164003-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:21.164003-06:00","labels":["auth","backend","convex","rbac","webhooks"],"dependencies":[{"issue_id":"test-e1t3s3","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:07:21.372107-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s3","depends_on_id":"test-e1t3s1","type":"blocks","created_at":"2026-01-30T12:09:18.622384-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t3s4","title":"Set up Clerk-to-Convex user sync webhook","description":"Create API route /api/webhooks/clerk for Clerk webhook events. Handle 'user.created' event to create corresponding user document in Convex users table with clerkId, email, name, role (default 'agent'), createdAt. Handle 'user.updated' to sync profile changes. Handle 'user.deleted' to soft-delete Convex user. Configure webhook in Clerk dashboard pointing to production/preview URLs. Verify webhook signature using Clerk's svix library.\n\n**Context:** Convex needs its own users table to store application-specific data and relationships (team membership, call records, CRM contacts). The webhook ensures Clerk (auth source of truth) and Convex (app data) stay synchronized. This is critical for queries that join user data with calls or contacts.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:21.566561-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:21.566561-06:00","labels":["auth","backend","convex","testing","webhook"],"dependencies":[{"issue_id":"test-e1t3s4","depends_on_id":"test-e1t3","type":"parent-child","created_at":"2026-01-30T12:07:21.741804-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t3s4","depends_on_id":"test-e1t3s1","type":"blocks","created_at":"2026-01-30T12:09:19.114257-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4","title":"Build basic dashboard shell with navigation","description":"Create the main dashboard layout with sidebar navigation, header with user menu, and placeholder pages for: Dashboard (home), Calls, Contacts, Settings. Implement responsive design for mobile use by agents in the field.\n\n**Context:** Real estate agents are often mobile - showing properties, driving between appointments. The dashboard needs to work well on phones. The navigation structure reflects the core features: seeing call activity, managing contacts, and adjusting settings.","design":"Use shadcn/ui Sidebar component. Create /app/(dashboard)/layout.tsx with sidebar + main content area. Navigation items: Dashboard, Calls, Contacts, Settings. Header shows user avatar (from Clerk), role badge, and organization name. Mobile: collapsible sidebar with hamburger menu.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:06:58.463912-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:58.463912-06:00","labels":["frontend","navigation","ui"],"dependencies":[{"issue_id":"test-e1t4","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:06:58.600948-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4","depends_on_id":"test-e1t1","type":"blocks","created_at":"2026-01-30T12:09:19.53119-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4","depends_on_id":"test-e1t3","type":"blocks","created_at":"2026-01-30T12:09:19.955001-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s1","title":"Create dashboard layout with shadcn/ui Sidebar","description":"Create /app/(dashboard)/layout.tsx with shadcn/ui Sidebar component. Install sidebar component if needed (npx shadcn-ui@latest add sidebar). Set up the basic structure: sidebar on left, main content area on right. Import and wrap with SidebarProvider. Create basic sidebar skeleton without navigation items yet.\n\n**Context:** This establishes the core layout pattern that all dashboard pages will use. The sidebar component from shadcn/ui handles responsive behavior and animations out of the box.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:21.975024-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:21.975024-06:00","labels":["frontend","layout","setup"],"dependencies":[{"issue_id":"test-e1t4s1","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:07:22.120594-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s2","title":"Add navigation items and routing structure","description":"Create navigation component with items: Dashboard (/dashboard), Calls (/dashboard/calls), Contacts (/dashboard/contacts), Settings (/dashboard/settings). Use lucide-react icons (Home, Phone, Users, Settings). Create placeholder page.tsx files for each route that just render the page title. Style active state for current route using usePathname().\n\n**Context:** Real estate agents need quick access to calls and contacts - the two features they'll use most. Dashboard gives overview, Settings for configuration.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:22.375951-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:22.375951-06:00","labels":["frontend","routing","ui"],"dependencies":[{"issue_id":"test-e1t4s2","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:07:22.604407-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s2","depends_on_id":"test-e1t4s1","type":"blocks","created_at":"2026-01-30T12:09:20.135906-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s3","title":"Build header with user menu and organization display","description":"Create header component in the main content area. Display: user avatar from Clerk (useUser hook), role badge (Admin/Agent/Lead - can hardcode for now), organization name from Clerk (useOrganization hook). Add dropdown menu on avatar click with Sign Out option using Clerk's signOut(). Style with shadcn/ui Avatar, Badge, and DropdownMenu components.\n\n**Context:** Agents in the field need to quickly see they're in the right account/organization. Role badge helps team leads and admins understand their permission level at a glance.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:22.84158-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:22.84158-06:00","labels":["auth","contacts","frontend"],"dependencies":[{"issue_id":"test-e1t4s3","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:07:23.047563-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s3","depends_on_id":"test-e1t4s1","type":"blocks","created_at":"2026-01-30T12:09:20.391418-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t4s4","title":"Implement mobile-responsive sidebar with hamburger menu","description":"Configure sidebar for mobile responsiveness: collapsible on mobile with hamburger menu button in header. Use shadcn/ui Sidebar's built-in mobile behavior (collapsible='icon' or sheet mode). Add SidebarTrigger button that shows on mobile. Test at various breakpoints (375px, 768px, 1024px). Ensure touch-friendly tap targets (min 44px).\n\n**Context:** Real estate agents are constantly mobile - showing properties, driving between appointments. The dashboard must work seamlessly on phones with easy one-thumb navigation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:23.337349-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:23.337349-06:00","labels":["calling","frontend","mobile","responsive"],"dependencies":[{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4","type":"parent-child","created_at":"2026-01-30T12:07:23.501953-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4s1","type":"blocks","created_at":"2026-01-30T12:09:20.614282-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4s2","type":"blocks","created_at":"2026-01-30T12:09:20.83289-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t4s4","depends_on_id":"test-e1t4s3","type":"blocks","created_at":"2026-01-30T12:09:21.197927-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5","title":"Configure environment variables and verify full stack integration","description":"Set up all environment variables for Convex, Clerk, and future integrations (Telnyx, OpenRouter placeholders). Create a verification checklist/script to ensure the full stack works together: Next.js serves pages, Clerk auth works, Convex queries return data.\n\n**Context:** With multiple services (Convex, Clerk, Telnyx, OpenRouter, Follow Up Boss), environment configuration is critical. A broken env var can cause hours of debugging. This task ensures everything is wired correctly before building features.","design":"Create .env.local.example with all required vars documented. Variables needed: NEXT_PUBLIC_CONVEX_URL, NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY, CLERK_SECRET_KEY, CONVEX_DEPLOYMENT. Add placeholder vars for TELNYX_API_KEY, OPENROUTER_API_KEY, FUB_API_KEY. Create /app/api/health route that checks all connections.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:06:58.809294-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:58.809294-06:00","labels":["config","devops","integration"],"dependencies":[{"issue_id":"test-e1t5","depends_on_id":"test-e1","type":"parent-child","created_at":"2026-01-30T12:06:59.188742-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5","depends_on_id":"test-e1t2","type":"blocks","created_at":"2026-01-30T12:09:21.463571-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5","depends_on_id":"test-e1t3","type":"blocks","created_at":"2026-01-30T12:09:21.708661-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5","depends_on_id":"test-e1t4","type":"blocks","created_at":"2026-01-30T12:09:21.94341-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s1","title":"Create .env.local.example with documented environment variables","description":"Create a comprehensive .env.local.example file with all required and placeholder environment variables. Group variables by service: Convex (NEXT_PUBLIC_CONVEX_URL, CONVEX_DEPLOYMENT), Clerk (NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY, CLERK_SECRET_KEY), and placeholders for future integrations (TELNYX_API_KEY, OPENROUTER_API_KEY, FUB_API_KEY). Add inline comments explaining each variable's purpose and where to obtain it.\n\n**Context:** Developers joining the project need a clear reference for required configuration. Well-documented env vars prevent common setup issues and reduce onboarding time.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:23.733189-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:23.733189-06:00","labels":["backend","config","documentation","telnyx","webhooks"],"dependencies":[{"issue_id":"test-e1t5s1","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:07:24.067764-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s2","title":"Create /api/health endpoint for connection verification","description":"Create /app/api/health/route.ts that checks connectivity to all configured services. Return JSON with status for each service: { convex: 'connected'|'error', clerk: 'configured'|'missing', telnyx: 'placeholder', openrouter: 'placeholder', fub: 'placeholder' }. For Convex, attempt a simple query. For Clerk, verify keys are present. Return 200 if critical services work, 503 if any critical service fails.\n\n**Context:** A health endpoint provides instant verification that the stack is wired correctly. Essential for debugging deployment issues and monitoring in production.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:24.354105-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:24.354105-06:00","labels":["api","audio","backend","file-storage"],"dependencies":[{"issue_id":"test-e1t5s2","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:07:24.557299-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s2","depends_on_id":"test-e1t5s1","type":"blocks","created_at":"2026-01-30T12:09:22.360066-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s3","title":"Create environment validation script for build-time checks","description":"Create scripts/check-env.ts that validates required environment variables at build time. Use zod or simple validation to check: all required vars exist, URLs are valid format, keys match expected patterns (e.g., Clerk keys start with pk_/sk_). Add to package.json as 'check-env' script. Optionally integrate into build process to fail fast on misconfiguration.\n\n**Context:** Build-time validation catches configuration errors before deployment, preventing runtime failures that are harder to debug in production.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:24.753129-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:24.753129-06:00","labels":["backend","database","dx","schema","tooling"],"dependencies":[{"issue_id":"test-e1t5s3","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:07:24.882926-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s3","depends_on_id":"test-e1t5s1","type":"blocks","created_at":"2026-01-30T12:09:22.544078-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t5s4","title":"Verify full stack integration with end-to-end test","description":"Create a manual verification checklist and perform full stack integration test: 1) Start dev server with all env vars configured, 2) Navigate to app and verify Next.js renders, 3) Test Clerk sign-in flow works, 4) After auth, verify Convex query returns data (user record or empty array), 5) Hit /api/health and verify all services show connected. Document any issues found and fix them. Update README with 'Getting Started' section covering env setup.\n\n**Context:** Before building features, we must confirm the foundation works. This verification catches integration issues between services that unit tests might miss.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:25.064265-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:25.064265-06:00","labels":["audio-player","documentation","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e1t5s4","depends_on_id":"test-e1t5","type":"parent-child","created_at":"2026-01-30T12:07:25.229584-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s4","depends_on_id":"test-e1t5s2","type":"blocks","created_at":"2026-01-30T12:09:22.783482-06:00","created_by":"David Habedank"},{"issue_id":"test-e1t5s4","depends_on_id":"test-e1t5s3","type":"blocks","created_at":"2026-01-30T12:09:22.97318-06:00","created_by":"David Habedank"}]}
{"id":"test-e1t6","title":"Create end-to-end foundation verification workflow","description":"Build comprehensive test workflow that verifies complete call flow from login through call completion and recording playback\n\n**Context:** Foundation infrastructure must work reliably before building advanced features. A broken calling system would render the entire product unusable for real estate professionals.","design":"Create test sequence: user authentication, contact selection, call initiation, call completion, recording availability, and playback functionality. Include error scenarios and recovery paths.","status":"tombstone","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T11:51:05.09121-06:00","created_by":"David Habedank","updated_at":"2026-01-30T11:53:29.300001-06:00","labels":["integration","testing","verification"],"deleted_at":"2026-01-30T11:53:29.300001-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e1t6s1","title":"Set up test environment and authentication flow verification","description":"Install and configure testing framework (Jest/Playwright), set up test database, implement login flow test that verifies user can authenticate with Follow Up Boss credentials and access the calling interface\n\n**Context:** Authentication is the entry point for all functionality - if users can't log in reliably, nothing else matters","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T11:51:21.532787-06:00","created_by":"David Habedank","updated_at":"2026-01-30T11:53:44.595291-06:00","labels":["auth","setup","testing"],"deleted_at":"2026-01-30T11:53:44.595291-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e1t6s2","title":"Implement contact selection and call initiation test sequence","description":"Create test that selects a contact from the CRM data, initiates a call through the calling provider, and verifies call state transitions (connecting, connected, ringing). Include error handling for failed connections.\n\n**Context:** Call initiation is the core user action that must work seamlessly to maintain agent productivity","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T11:51:21.834964-06:00","created_by":"David Habedank","updated_at":"2026-01-30T11:53:44.496724-06:00","labels":["calling","integration","testing"],"deleted_at":"2026-01-30T11:53:44.496724-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e1t6s3","title":"Build call completion and recording verification workflow","description":"Create test sequence that completes a call, verifies recording is captured and stored, checks that call metadata is properly saved to database, and validates recording file accessibility and playback functionality\n\n**Context:** Recording and metadata persistence is critical for compliance and follow-up - data loss would be catastrophic for real estate deals","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":105,"created_at":"2026-01-30T11:51:22.122337-06:00","created_by":"David Habedank","updated_at":"2026-01-30T11:53:44.392757-06:00","labels":["recording","storage","testing"],"deleted_at":"2026-01-30T11:53:44.392757-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e1t6s4","title":"Execute comprehensive test suite and validate system reliability","description":"Run complete end-to-end test suite, implement error scenario testing (network failures, API timeouts, invalid credentials), create test report, and verify system recovery paths. Include performance benchmarks for call latency.\n\n**Context:** System reliability verification ensures the foundation can handle real-world usage patterns and edge cases","status":"tombstone","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T11:51:22.428399-06:00","created_by":"David Habedank","updated_at":"2026-01-30T11:53:44.27832-06:00","labels":["performance","testing","validation"],"deleted_at":"2026-01-30T11:53:44.27832-06:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"test-e2","title":"Telephony Infrastructure \u0026 Basic Calling","description":"Integrate Telnyx for outbound phone calls, call recording, and SMS capabilities. Build the basic call initiation flow, recording storage in Convex, and call log display in the dashboard.\n\n**Context:** RealHerd is phone-first - the ability to make outbound calls and record them is the core technical capability everything else depends on. This must work reliably before adding AI voice.","acceptance_criteria":"- Telnyx account configured with phone number provisioned\n- Can initiate outbound call to a phone number from the system\n- Can play audio greeting during call\n- Call recordings are captured and stored in Convex file storage\n- Call log displays in dashboard with status, duration, timestamp\n- SMS send/receive working via Telnyx webhooks\n- Call model tracks status, direction, duration, recording storage ID","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:06:55.804455-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:55.804455-06:00","labels":["core-infrastructure","telephony","telnyx"],"dependencies":[{"issue_id":"test-e2","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:23.127699-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1","title":"Set up Telnyx account and provision phone number","description":"Create Telnyx account, configure API credentials, provision a phone number for outbound calling, and set up webhook endpoints for call events. Store credentials securely in environment variables.\n\n**Context:** RealHerd is phone-first - without a working Telnyx integration and provisioned number, no calls can be made. This is the foundation for all telephony features that enable agents to maintain contact relationships.","design":"Use Telnyx Call Control API for programmable voice. Set up messaging profile for SMS. Configure webhook URLs pointing to Convex HTTP actions. Store TELNYX_API_KEY, TELNYX_PUBLIC_KEY, and phone number in env vars. Consider using Telnyx Connection for SIP trunking configuration.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":180,"created_at":"2026-01-30T12:06:59.372534-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:59.372534-06:00","labels":["backend","infrastructure","telnyx"],"dependencies":[{"issue_id":"test-e2t1","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:06:59.520151-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s1","title":"Create Telnyx account and configure API credentials","description":"Sign up for a Telnyx account at telnyx.com. Navigate to API Keys section and generate API v2 key. Note the public key as well. Create .env.local file with TELNYX_API_KEY and TELNYX_PUBLIC_KEY variables. Add these to .gitignore if not already present.\n\n**Context:** API credentials are required for all Telnyx API interactions. Without valid credentials, no telephony operations are possible.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:25.438127-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:25.438127-06:00","labels":["ai","ai-integration","backend","infrastructure","setup"],"dependencies":[{"issue_id":"test-e2t1s1","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:07:25.582127-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s2","title":"Provision phone number for outbound calling","description":"In Telnyx portal, search for and purchase a phone number with voice capability. Ensure the number supports outbound calling. Create a Messaging Profile for future SMS capability. Store the phone number in TELNYX_PHONE_NUMBER environment variable. Document the number's capabilities (voice, SMS, MMS).\n\n**Context:** A provisioned phone number is the caller ID for all outbound calls. Real estate agents need a consistent, professional number that contacts will recognize.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":20,"created_at":"2026-01-30T12:07:25.945894-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:25.945894-06:00","labels":["backend","frontend","infrastructure","realtime","setup","telephony"],"dependencies":[{"issue_id":"test-e2t1s2","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:07:26.138598-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s2","depends_on_id":"test-e2t1s1","type":"blocks","created_at":"2026-01-30T12:09:23.308068-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s3","title":"Configure Call Control connection and webhook endpoints","description":"Create a Call Control Application in Telnyx portal. Configure webhook URLs pointing to Convex HTTP actions (e.g., https://your-convex-deployment.convex.site/telnyx-webhook). Set up webhook for call events: call.initiated, call.answered, call.hangup, call.recording.saved. Enable call recording settings. Associate the provisioned phone number with this Call Control application.\n\n**Context:** Webhooks enable real-time call event handling. RealHerd needs to know when calls start, end, and when recordings are available to update contact records and provide AI analysis.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:26.49341-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:26.49341-06:00","labels":["audio","backend","infrastructure","streaming"],"dependencies":[{"issue_id":"test-e2t1s3","depends_on_id":"test-e2t1s1","type":"blocks","created_at":"2026-01-30T11:10:42.262266-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s3","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:07:26.701072-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s3","depends_on_id":"test-e2t1s2","type":"blocks","created_at":"2026-01-30T12:09:23.483674-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t1s4","title":"Create placeholder Convex HTTP action for webhook and verify end-to-end","description":"Create a basic Convex HTTP action at convex/http.ts that accepts POST requests at /telnyx-webhook endpoint. Log incoming webhook payloads for debugging. Return 200 OK response. Make a test outbound call using Telnyx portal's test call feature or API to verify webhooks fire and reach Convex endpoint.\n\n**Context:** Verifying the complete flow from Telnyx to Convex ensures the infrastructure is working before building actual call handling logic. Early verification prevents debugging complex issues later.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:26.914817-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:26.914817-06:00","labels":["backend","infrastructure","integration","monitoring","performance","testing"],"dependencies":[{"issue_id":"test-e2t1s4","depends_on_id":"test-e2t1","type":"parent-child","created_at":"2026-01-30T12:07:27.053185-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t1s4","depends_on_id":"test-e2t1s3","type":"blocks","created_at":"2026-01-30T12:09:23.64041-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2","title":"Create Convex schema and mutations for calls and recordings","description":"Define Convex schema for calls table (status, direction, duration, recording_storage_id, from_number, to_number, timestamps, contact_id reference). Create mutations for creating calls, updating status, and storing recording references. Set up file storage bucket for recordings.\n\n**Context:** Call data persistence is essential for the dashboard call log and linking calls to contacts. Brokers and team leads need visibility into agent activity, and agents need their call history to maintain relationships.","design":"Schema: calls table with indexes on contact_id, agent_id, status, created_at. Use Convex file storage for recordings with proper content-type (audio/wav or audio/mp3). Create mutations: createCall, updateCallStatus, attachRecording, getCallsByContact, getCallLog.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:06:59.70899-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:59.70899-06:00","labels":["backend","convex","database"],"dependencies":[{"issue_id":"test-e2t2","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:06:59.845637-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s1","title":"Define Convex schema for calls table with indexes","description":"Create the calls table schema in convex/schema.ts with fields: status (pending/ringing/in_progress/completed/failed), direction (inbound/outbound), duration (number), recording_storage_id (optional Id\u003c'_storage'\u003e), from_number, to_number, contact_id (optional reference), agent_id, started_at, ended_at, created_at. Add indexes on contact_id, agent_id, status, and created_at for efficient queries.\n\n**Context:** The calls schema is the foundation for all call tracking. Indexes are critical because brokers and team leads will frequently query by agent_id to monitor performance, by contact_id to see relationship history, and by created_at for the dashboard call log.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:27.27135-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:27.27135-06:00","labels":["api","backend","database","types"],"dependencies":[{"issue_id":"test-e2t2s1","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:07:27.456154-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s2","title":"Create call lifecycle mutations (create, update status)","description":"Implement mutations in convex/calls.ts: createCall (creates new call record with pending status, returns call ID), updateCallStatus (transitions status and sets timestamps appropriately - started_at when in_progress, ended_at and duration when completed/failed). Include input validation for status transitions.\n\n**Context:** These mutations handle the call lifecycle that Twilio webhooks will trigger. Status transitions must be idempotent and validate proper state machine flow (can't go from completed back to ringing).","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:27.86288-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:27.86288-06:00","labels":["api","backend","crm","state-management"],"dependencies":[{"issue_id":"test-e2t2s2","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:07:28.220052-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s2","depends_on_id":"test-e2t2s1","type":"blocks","created_at":"2026-01-30T12:09:23.852455-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s3","title":"Set up file storage and recording attachment mutation","description":"Configure Convex file storage for recordings. Create attachRecording mutation that: generates an upload URL for audio files (audio/wav, audio/mp3), stores the file, and updates the call record with recording_storage_id. Include getRecordingUrl query to retrieve playable URLs.\n\n**Context:** Recording storage is essential for compliance and training. Brokers need to review calls, and AI features will later analyze recordings. File storage must handle audio content-types properly for browser playback.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:28.496053-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:28.496053-06:00","labels":["ai-prompts","backend","data-processing","storage"],"dependencies":[{"issue_id":"test-e2t2s3","depends_on_id":"test-e2t2s1","type":"blocks","created_at":"2026-01-30T11:10:43.375921-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s3","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:07:28.613569-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s3","depends_on_id":"test-e2t2s2","type":"blocks","created_at":"2026-01-30T12:09:24.138716-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s4","title":"Create call query functions (getCallsByContact, getCallLog)","description":"Implement query functions: getCallsByContact (paginated list of calls for a contact, ordered by created_at desc), getCallLog (paginated call log for agent or entire brokerage with filters for status and date range). Both queries should include contact name when available via join.\n\n**Context:** These queries power the dashboard call log and contact detail views. Agents see their own calls, team leads see their team, brokers see everyone. Pagination is critical as call volume grows.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:28.793826-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:28.793826-06:00","labels":["api","backend","integration","monitoring","real-estate"],"dependencies":[{"issue_id":"test-e2t2s4","depends_on_id":"test-e2t2s3","type":"blocks","created_at":"2026-01-30T11:10:44.172471-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s4","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:07:28.998505-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s4","depends_on_id":"test-e2t2s1","type":"blocks","created_at":"2026-01-30T12:09:24.322765-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t2s5","title":"Verify complete calls schema with manual test and dev server","description":"Run npx convex dev to deploy schema and functions. Use Convex dashboard to manually create a test call, update its status through the lifecycle, attach a mock recording, and query it back via getCallLog and getCallsByContact. Verify all indexes are created correctly.\n\n**Context:** Manual verification ensures the entire call data flow works before integrating with Twilio. Catching schema or mutation issues here is much easier than debugging through the full Twilio integration.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:29.247609-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:29.247609-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e2t2s5","depends_on_id":"test-e2t2","type":"parent-child","created_at":"2026-01-30T12:07:29.38404-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s5","depends_on_id":"test-e2t2s2","type":"blocks","created_at":"2026-01-30T12:09:24.539513-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s5","depends_on_id":"test-e2t2s3","type":"blocks","created_at":"2026-01-30T12:09:24.717867-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t2s5","depends_on_id":"test-e2t2s4","type":"blocks","created_at":"2026-01-30T12:09:24.947484-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3","title":"Implement outbound call initiation with audio greeting","description":"Create Convex HTTP action to initiate outbound calls via Telnyx Call Control API. Implement call flow: dial number, play audio greeting when answered, then bridge or hang up. Handle call state machine (initiated, ringing, answered, completed, failed).\n\n**Context:** The ability to programmatically initiate calls is the core technical capability for RealHerd. Playing an audio greeting proves the call control works and sets up the foundation for AI voice integration later.","design":"Use Telnyx call_control_id to track calls. Implement webhook handlers for call.initiated, call.answered, call.hangup events. Store a default greeting audio file. Use Telnyx 'playback_start' command for greeting. Update call status in Convex as events arrive. Consider retry logic for failed calls.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:00.074743-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:00.074743-06:00","labels":["api","backend","telnyx"],"dependencies":[{"issue_id":"test-e2t3","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:07:00.264591-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3","depends_on_id":"test-e2t1","type":"blocks","created_at":"2026-01-30T12:09:25.142257-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3","depends_on_id":"test-e2t2","type":"blocks","created_at":"2026-01-30T12:09:25.297403-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s1","title":"Create call state machine types and database schema","description":"Define TypeScript types for call states (initiated, ringing, answered, completed, failed) and call control data. Create Convex schema for 'calls' table with fields: id, telnyx_call_control_id, to_number, from_number, status, initiated_at, answered_at, completed_at, error_message. Add indexes for efficient querying by status and call_control_id.\n\n**Context:** A well-defined state machine prevents invalid state transitions and makes debugging call issues much easier. The call_control_id is how Telnyx identifies calls across all webhook events.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:29.564113-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:29.564113-06:00","labels":["audio","backend","database","scheduling","types"],"dependencies":[{"issue_id":"test-e2t3s1","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:07:29.68904-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s2","title":"Implement outbound call initiation HTTP action","description":"Create Convex HTTP action POST /api/calls/initiate that accepts { to_number, from_number? }. Validate phone number format. Call Telnyx Call Control API 'calls' endpoint to initiate call. Store call record in database with 'initiated' status. Return call_control_id to caller. Handle API errors gracefully and store failed status with error message.\n\n**Context:** This is the entry point for all outbound calls. Using an HTTP action (vs mutation) allows external services to trigger calls and handles the async Telnyx API call properly.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:29.870618-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:29.870618-06:00","labels":["ai","api","backend","state-machine","telnyx"],"dependencies":[{"issue_id":"test-e2t3s2","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:07:29.989107-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s2","depends_on_id":"test-e2t3s1","type":"blocks","created_at":"2026-01-30T12:09:25.46168-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s3","title":"Implement call event webhook handlers","description":"Extend the Telnyx webhook handler (from 2.2) to process call.initiated, call.answered, and call.hangup events. On call.answered: update call status, trigger playback_start command with default greeting audio URL. On call.hangup: update call status to 'completed' with timestamp, store hangup cause. Implement idempotent handling (same event received twice doesn't corrupt state).\n\n**Context:** Telnyx uses webhooks to notify us of call progress. The greeting playback on answer demonstrates we have full call control. Idempotency is critical because webhooks can be delivered multiple times.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:30.288783-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:30.288783-06:00","labels":["backend","database","integration","sms","telnyx","webhooks"],"dependencies":[{"issue_id":"test-e2t3s3","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:07:30.454035-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s3","depends_on_id":"test-e2t3s1","type":"blocks","created_at":"2026-01-30T12:09:25.71153-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s3","depends_on_id":"test-e2t3s2","type":"blocks","created_at":"2026-01-30T12:09:25.983937-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t3s4","title":"End-to-end call flow verification","description":"Upload a test greeting audio file (MP3/WAV) to accessible URL (can use Convex file storage or public URL). Create a test script or Convex function to initiate a call to a test phone number. Verify complete flow: call initiates  phone rings  answer  greeting plays  hangup. Check all database state transitions logged correctly. Document any edge cases discovered (e.g., voicemail, busy signal).\n\n**Context:** Proving the complete call flow works end-to-end is the acceptance criteria for this task. This verification ensures RealHerd can actually make calls before building more complex features on top.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:30.725678-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:30.725678-06:00","labels":["backend","configuration","e2e","frontend","testing","verification"],"dependencies":[{"issue_id":"test-e2t3s4","depends_on_id":"test-e2t3","type":"parent-child","created_at":"2026-01-30T12:07:30.926505-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t3s4","depends_on_id":"test-e2t3s3","type":"blocks","created_at":"2026-01-30T12:09:26.168943-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4","title":"Implement call recording capture and storage","description":"Configure Telnyx to record calls automatically. Handle recording.saved webhook to download recording from Telnyx and upload to Convex file storage. Link recording storage ID to the call record.\n\n**Context:** Call recordings are essential for AI transcription, compliance review, and agent training. Brokers need access to recordings to monitor quality, and the AI pipeline will use recordings to extract CRM updates.","design":"Enable recording via call_control record command or connection-level setting. Handle recording.saved webhook with recording URL. Download recording (may need signed URL), upload to Convex file storage, update call record with storage_id. Consider async processing for large files. Set appropriate retention policy.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:00.492214-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:00.492214-06:00","labels":["backend","convex","storage","telnyx"],"dependencies":[{"issue_id":"test-e2t4","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:07:00.670564-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4","depends_on_id":"test-e2t3","type":"blocks","created_at":"2026-01-30T12:09:26.370777-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s1","title":"Configure Telnyx connection for automatic call recording","description":"Update the Telnyx connection settings to enable automatic call recording for all outbound calls. This can be done via connection-level settings in the Telnyx portal or programmatically. Verify the recording format (wav/mp3) and storage duration settings are appropriate for AI transcription needs.\n\n**Context:** Recording must be enabled at the connection level to ensure all calls are captured automatically without requiring per-call configuration. This is prerequisite for the entire recording pipeline.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:31.253972-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:31.253972-06:00","labels":["backend","configuration","conversation-design","frontend","product","telnyx","ui"],"dependencies":[{"issue_id":"test-e2t4s1","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:07:31.45775-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s2","title":"Create recording.saved webhook handler and call record schema update","description":"Add recording.saved event handling to the existing Telnyx webhook endpoint. Update the calls table schema to include recording_storage_id (optional Id\u003c'_storage'\u003e) and recording_status ('pending' | 'processing' | 'saved' | 'failed'). Parse the webhook payload to extract recording_url, call_control_id, and recording metadata.\n\n**Context:** The webhook handler receives notification when Telnyx has finished processing a recording. We need to capture this event and link it to the correct call record before downloading.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:31.683782-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:31.683782-06:00","labels":["backend","conversation-engine","convex","frontend","webhook","webrtc"],"dependencies":[{"issue_id":"test-e2t4s2","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:07:31.86637-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s2","depends_on_id":"test-e2t4s1","type":"blocks","created_at":"2026-01-30T12:09:26.528402-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s3","title":"Implement recording download and Convex file storage upload","description":"Create a Convex action that downloads the recording from Telnyx (using signed URL if required - check Telnyx docs for auth requirements), uploads it to Convex file storage using storage.store(), and returns the storage ID. Handle large files with streaming if needed. Include error handling for download failures, timeout, and storage errors.\n\n**Context:** Recordings need to be stored in Convex's file storage for persistence and later access by AI transcription pipeline. Telnyx recording URLs may expire, so download must happen promptly.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:32.122327-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:32.122327-06:00","labels":["backend","convex","crm-integration","frontend","real-time","storage"],"dependencies":[{"issue_id":"test-e2t4s3","depends_on_id":"test-e2t4s1","type":"blocks","created_at":"2026-01-30T11:10:45.838586-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s3","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:07:32.488959-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s3","depends_on_id":"test-e2t4s2","type":"blocks","created_at":"2026-01-30T12:09:26.737749-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t4s4","title":"Link recording to call record and verify end-to-end flow","description":"Update the call record with recording_storage_id and set recording_status to 'saved' after successful upload. Add a query to retrieve recording URL from storage for playback. Test the complete flow: place call  end call  webhook received  recording downloaded  storage ID linked to call.\n\n**Context:** Brokers need to access recordings for quality monitoring, and the AI pipeline will need to retrieve recordings for transcription. This completes the recording capture pipeline.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:32.782289-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:32.782289-06:00","labels":["backend","convex","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e2t4s4","depends_on_id":"test-e2t4s2","type":"blocks","created_at":"2026-01-30T11:10:46.167821-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s4","depends_on_id":"test-e2t4","type":"parent-child","created_at":"2026-01-30T12:07:33.236535-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t4s4","depends_on_id":"test-e2t4s3","type":"blocks","created_at":"2026-01-30T12:09:26.904159-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5","title":"Implement SMS send/receive via Telnyx webhooks","description":"Create Convex HTTP actions to send SMS via Telnyx Messaging API. Handle inbound SMS webhooks to store received messages. Create messages table schema linked to contacts.\n\n**Context:** SMS is a critical communication channel for real estate. Agents often text clients for quick updates, and RealHerd needs to capture these interactions to maintain the full communication picture in the CRM.","design":"Use Telnyx Messaging API v2. Create messages schema: direction, body, from, to, contact_id, status, timestamps. Handle message.received webhook for inbound. Implement sendSMS mutation. Consider rate limiting and opt-out handling for compliance.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:00.939827-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:00.939827-06:00","labels":["api","backend","sms","telnyx"],"dependencies":[{"issue_id":"test-e2t5","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:07:01.12468-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5","depends_on_id":"test-e2t1","type":"blocks","created_at":"2026-01-30T12:09:27.077328-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5","depends_on_id":"test-e2t2","type":"blocks","created_at":"2026-01-30T12:09:27.29064-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s1","title":"Create messages table schema in Convex","description":"Define the messages table schema in convex/schema.ts with fields: direction (inbound/outbound enum), body (string), from (string - phone number), to (string - phone number), contact_id (optional reference to contacts), status (enum: queued/sent/delivered/failed/received), telnyx_message_id (string for tracking), error_message (optional string), created_at, updated_at. Add appropriate indexes for querying by contact_id and status.\n\n**Context:** The messages table is foundational for SMS tracking. It links to contacts to build a communication history and stores Telnyx-specific data for delivery tracking and debugging.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:07:33.733878-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:33.733878-06:00","labels":["audio","backend","database","integration"],"dependencies":[{"issue_id":"test-e2t5s1","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:07:33.915756-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s2","title":"Implement sendSMS mutation with Telnyx Messaging API v2","description":"Create convex/sms.ts with a sendSMS action that: 1) Accepts to, body, and optional contact_id parameters, 2) Calls Telnyx Messaging API v2 POST /messages endpoint with TELNYX_API_KEY and TELNYX_PHONE_NUMBER from env, 3) Creates a messages record with status 'queued' before sending, 4) Updates record with telnyx_message_id on success or error_message on failure, 5) Returns the message record. Use httpAction for the API call.\n\n**Context:** Outbound SMS is essential for agent-client communication. The mutation must be idempotent-friendly by creating the DB record first, ensuring we never lose track of attempted messages even if the API call fails.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:34.314573-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:34.314573-06:00","labels":["api-integration","audio","backend","database"],"dependencies":[{"issue_id":"test-e2t5s2","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:07:35.51908-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s2","depends_on_id":"test-e2t5s1","type":"blocks","created_at":"2026-01-30T12:09:27.538986-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s3","title":"Create inbound SMS webhook handler for Telnyx message.received","description":"Create HTTP endpoint at convex/http.ts (or add to existing) that handles POST /webhooks/telnyx/sms. Parse the Telnyx message.received webhook payload to extract: from, to, body, message_id. Look up contact by phone number (from field). Create messages record with direction 'inbound', status 'received', and link to contact if found. Return 200 OK. Add webhook signature verification using TELNYX_WEBHOOK_SECRET.\n\n**Context:** Inbound SMS capture ensures RealHerd maintains the complete communication picture. Agents' clients often respond via text, and missing these creates gaps in the CRM history that undermine the product's value proposition.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:36.768824-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:36.768824-06:00","labels":["ai","audio","backend","webhooks"],"dependencies":[{"issue_id":"test-e2t5s3","depends_on_id":"test-e2t5s2","type":"blocks","created_at":"2026-01-30T11:10:47.077648-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s3","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:07:37.113195-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s3","depends_on_id":"test-e2t5s1","type":"blocks","created_at":"2026-01-30T12:09:27.754355-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t5s4","title":"Add message delivery status webhook handler","description":"Extend the webhook handler to process message.finalized events from Telnyx. Update existing message records (matched by telnyx_message_id) with final delivery status: delivered, failed, or undelivered. Store any error codes/descriptions in error_message field. This completes the outbound message lifecycle tracking.\n\n**Context:** Delivery confirmation is critical for agents to know their messages reached clients. Failed deliveries may indicate wrong numbers or opt-outs, which agents need to see to take corrective action.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:37.512128-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:37.512128-06:00","labels":["backend","conversation-flow","integration","webhooks"],"dependencies":[{"issue_id":"test-e2t5s4","depends_on_id":"test-e2t5","type":"parent-child","created_at":"2026-01-30T12:07:37.709361-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s4","depends_on_id":"test-e2t5s2","type":"blocks","created_at":"2026-01-30T12:09:27.911963-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t5s4","depends_on_id":"test-e2t5s3","type":"blocks","created_at":"2026-01-30T12:09:28.266691-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6","title":"Build call log UI in dashboard","description":"Create dashboard page displaying call history with columns: contact name, phone number, direction (inbound/outbound), status, duration, timestamp, and link to recording playback. Include filtering by date range and status.\n\n**Context:** Brokers and team leads need visibility into call activity to monitor agent performance. Agents need their call history to follow up on conversations. This is the primary interface for accessing telephony data.","design":"Use shadcn/ui DataTable component. Create useQuery hook for paginated call log. Include audio player component for recording playback (streaming from Convex storage). Add click-to-call button on contact names. Filter controls for date range, status, agent (for broker view).","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:01.372681-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:01.372681-06:00","labels":["dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e2t6","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:07:01.492143-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6","depends_on_id":"test-e2t3","type":"blocks","created_at":"2026-01-30T12:09:28.484331-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6","depends_on_id":"test-e2t4","type":"blocks","created_at":"2026-01-30T12:09:28.637619-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s1","title":"Create call log data types and useCallLogs query hook","description":"Define TypeScript types for CallLogEntry (id, contactId, contactName, phoneNumber, direction: 'inbound' | 'outbound', status: 'completed' | 'missed' | 'voicemail' | 'failed', duration, timestamp, recordingUrl). Create useCallLogs custom hook wrapping useQuery for paginated call log data with filter parameters (dateRange, status, agentId for broker view). Include proper loading and error states.\n\n**Context:** The data layer and types must be established first so the UI components can be built with proper type safety. The hook will handle pagination and filtering logic that the DataTable needs.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:37.936032-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:37.936032-06:00","labels":["data","frontend","infrastructure","integration","testing"],"dependencies":[{"issue_id":"test-e2t6s1","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:07:38.182698-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s2","title":"Build CallLogTable component with shadcn/ui DataTable","description":"Create CallLogTable component using shadcn/ui DataTable. Columns: contact name (clickable for call), phone number, direction (with icon), status (with colored badge), duration (formatted mm:ss), timestamp (relative + absolute on hover), play button for recording. Implement sortable columns for timestamp and duration. Wire up useCallLogs hook for data. Add pagination controls at bottom.\n\n**Context:** This is the primary interface for viewing call history. The DataTable provides sorting, and the visual design needs to quickly convey call outcomes (status badges) and enable quick actions (click-to-call, play recording).","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:38.413017-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:38.413017-06:00","labels":["admin","frontend","monitoring","performance","testing","ui"],"dependencies":[{"issue_id":"test-e2t6s2","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:07:38.549489-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6s2","depends_on_id":"test-e2t6s1","type":"blocks","created_at":"2026-01-30T12:09:28.840145-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s3","title":"Add filter controls and audio player component","description":"Create CallLogFilters component with: date range picker (today, 7 days, 30 days, custom), status multi-select dropdown, agent selector (visible only for broker role). Create AudioPlayer component for recording playback that streams from Convex storage URL - include play/pause, progress bar, duration display. Wire filters to update useCallLogs query parameters. Add click-to-call handler on contact names that triggers dialer.\n\n**Context:** Brokers need to filter by agent to monitor performance. Date filtering helps find specific calls. The audio player must stream efficiently since recordings can be long. Click-to-call enables quick follow-ups directly from the log.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:38.73954-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:38.73954-06:00","labels":["ai","conversation","demo","frontend","optimization","performance","ui"],"dependencies":[{"issue_id":"test-e2t6s3","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:07:38.875193-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6s3","depends_on_id":"test-e2t6s2","type":"blocks","created_at":"2026-01-30T12:09:29.079223-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t6s4","title":"Create CallLogPage and integrate into dashboard routing","description":"Create /dashboard/calls page component that composes CallLogFilters and CallLogTable. Add page header with title 'Call Log' and refresh button. Add route to dashboard navigation sidebar. Test full page flow: load page, apply filters, play recording, click contact to call. Verify responsive layout works on tablet viewport (brokers may use iPad).\n\n**Context:** The page must be easily accessible from the main dashboard navigation and provide a complete workflow for reviewing and acting on call history. Mobile/tablet support is important for brokers on the go.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:39.158306-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:39.158306-06:00","labels":["admin","frontend","integration","monitoring","testing","validation","verification"],"dependencies":[{"issue_id":"test-e2t6s4","depends_on_id":"test-e2t6","type":"parent-child","created_at":"2026-01-30T12:07:39.372042-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t6s4","depends_on_id":"test-e2t6s3","type":"blocks","created_at":"2026-01-30T12:09:29.24713-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7","title":"Verify end-to-end telephony flow","description":"Comprehensive integration test of the complete telephony flow: initiate call from UI, call connects, greeting plays, recording captured, call log updates in real-time, recording playable from dashboard. Verify SMS send/receive flow as well.\n\n**Context:** Telephony is the core capability of RealHerd - if this doesn't work reliably, the product fails. This verification ensures all pieces work together before building AI voice features on top.","design":"Create test checklist covering: call initiation, webhook processing, recording storage, UI updates. Test failure scenarios: call not answered, call failed, webhook timeout. Verify Clerk role-based access to call logs. Document any Telnyx-specific configuration requirements.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":180,"created_at":"2026-01-30T12:07:01.628052-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:01.628052-06:00","labels":["integration","testing","verification"],"dependencies":[{"issue_id":"test-e2t7","depends_on_id":"test-e2","type":"parent-child","created_at":"2026-01-30T12:07:01.746385-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7","depends_on_id":"test-e2t5","type":"blocks","created_at":"2026-01-30T12:09:29.458589-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7","depends_on_id":"test-e2t6","type":"blocks","created_at":"2026-01-30T12:09:29.621816-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s1","title":"Create end-to-end telephony test checklist and test harness","description":"Create a comprehensive test checklist document and basic test harness for telephony flows. Checklist should cover: call initiation from UI, Telnyx webhook processing, recording capture and storage, real-time UI updates, SMS send/receive. Include failure scenarios: call not answered, call failed, invalid number, webhook timeout. Set up test utilities for simulating calls and verifying webhook responses.\n\n**Context:** A structured checklist ensures no critical path is missed during testing. The test harness enables repeatable verification as the system evolves.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:39.621494-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:39.621494-06:00","labels":["documentation","testing"],"dependencies":[{"issue_id":"test-e2t7s1","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:07:39.776589-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s2","title":"Execute happy path call flow test","description":"Manually execute and verify the complete happy path: 1) Initiate call from dashboard UI, 2) Verify call connects via Telnyx, 3) Confirm greeting audio plays, 4) Complete a test conversation with recording, 5) Verify call log appears in UI with real-time updates, 6) Play back recording from dashboard. Document Telnyx-specific configuration observed (webhook URLs, call control settings, recording format).\n\n**Context:** This validates the core user journey works end-to-end. Documenting Telnyx config ensures the setup is reproducible.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:39.96684-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:39.96684-06:00","labels":["telephony","testing"],"dependencies":[{"issue_id":"test-e2t7s2","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:07:40.090609-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7s2","depends_on_id":"test-e2t7s1","type":"blocks","created_at":"2026-01-30T12:09:29.803521-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s3","title":"Execute failure scenario and access control tests","description":"Test failure scenarios: 1) Call to invalid number - verify graceful error handling, 2) Call not answered - verify timeout behavior and UI state, 3) Simulate webhook timeout - verify system recovery. Test Clerk role-based access: verify team leads only see their team's call logs, agents only see their own calls, brokerage owners see all. Test SMS send/receive flow if implemented.\n\n**Context:** Failure handling is critical for production reliability. Role-based access ensures data isolation between teams and users.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:40.415429-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:40.415429-06:00","labels":["security","telephony","testing"],"dependencies":[{"issue_id":"test-e2t7s3","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:07:40.563982-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7s3","depends_on_id":"test-e2t7s2","type":"blocks","created_at":"2026-01-30T12:09:29.978742-06:00","created_by":"David Habedank"}]}
{"id":"test-e2t7s4","title":"Document test results and create verification report","description":"Compile all test results into a verification report. Include: passed/failed scenarios, any bugs discovered, Telnyx configuration requirements, screenshots of successful flows, recommendations for improvements. Create GitHub issues for any bugs found. Update project documentation with telephony setup requirements for new developers.\n\n**Context:** Documentation ensures findings are actionable and the telephony foundation is validated before building AI voice features on top.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:40.917796-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:40.917796-06:00","labels":["documentation","testing"],"dependencies":[{"issue_id":"test-e2t7s4","depends_on_id":"test-e2t7","type":"parent-child","created_at":"2026-01-30T12:07:41.297167-06:00","created_by":"David Habedank"},{"issue_id":"test-e2t7s4","depends_on_id":"test-e2t7s3","type":"blocks","created_at":"2026-01-30T12:09:30.565693-06:00","created_by":"David Habedank"}]}
{"id":"test-e3","title":"Voice AI Conversation Engine","description":"Integrate LFM 2.5-Audio for real-time bidirectional voice conversations. Implement the debrief conversation flow with natural dialogue, transcript generation, and storage. Build transcript display UI.\n\n**Context:** The AI conversation is what makes RealHerd valuable - it must feel natural and warm, not robotic. This is where the 'magic' happens that turns voice into structured data.","acceptance_criteria":"- LFM 2.5-Audio integrated with real-time bidirectional streaming\n- Debrief conversation flow implemented with prompts and follow-ups\n- AI handles interruptions and knows when to wrap up\n- Transcripts generated with speaker labels and timestamps\n- Transcripts stored and displayed in dashboard\n- Call recordings playable from dashboard\n- Conversation latency under 500ms round-trip\n- Voice feels warm and conversational per brand guidelines","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:06:56.067224-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:56.067224-06:00","labels":["core-feature","lfm","voice-ai"],"dependencies":[{"issue_id":"test-e3","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:30.806278-06:00","created_by":"David Habedank"},{"issue_id":"test-e3","depends_on_id":"test-e2","type":"blocks","created_at":"2026-01-30T12:09:31.757019-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1","title":"Set up LFM 2.5-Audio SDK and streaming infrastructure","description":"Install and configure the Liquid Foundation Model 2.5-Audio SDK. Set up WebSocket infrastructure for bidirectional audio streaming between browser/phone and the AI model. Configure audio encoding/decoding (likely opus or similar) for low-latency streaming.\n\n**Context:** This foundation enables the 'magic' conversational experience. Without proper streaming infrastructure, conversations will feel robotic and laggy - exactly what we need to avoid for agents who are already skeptical of CRM tools.","design":"Use WebSocket for persistent connections. Consider WebRTC for browser-to-server audio if needed. Audio should be streamed in small chunks (20-40ms) for sub-500ms latency. May need a media server component or use Telnyx's streaming capabilities for phone calls.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:07:01.966685-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:01.966685-06:00","labels":["ai","backend","infrastructure"],"dependencies":[{"issue_id":"test-e3t1","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:07:02.104125-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s1","title":"Install and configure LFM 2.5-Audio SDK with TypeScript types","description":"Install the Liquid Foundation Model 2.5-Audio SDK package. Create TypeScript type definitions for the SDK interfaces including AudioStreamConfig, ModelResponse, and ConversationSession. Set up environment variables for API credentials and model configuration. Create a basic initialization module that validates the SDK connection on startup.\n\n**Context:** The SDK is the core AI engine that powers natural conversation. Proper TypeScript types will prevent runtime errors and enable IDE autocompletion for the team. Early validation ensures we catch configuration issues before they reach production.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:43.468942-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:43.468942-06:00","labels":["ai","backend","infrastructure","integration","ml-integration"],"dependencies":[{"issue_id":"test-e3t1s1","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:07:43.725555-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s2","title":"Create WebSocket server for bidirectional audio streaming","description":"Implement a WebSocket server endpoint (e.g., /api/ws/audio-stream) that handles persistent connections for audio streaming. Create connection lifecycle handlers (onOpen, onMessage, onClose, onError). Implement session management to track active conversations with unique session IDs. Add heartbeat/ping-pong mechanism to detect stale connections. Configure for high-frequency small messages (targeting 20-40ms audio chunks).\n\n**Context:** WebSocket provides the persistent, low-latency connection needed for real-time conversation. Unlike REST APIs, it keeps the connection open so audio can flow continuously in both directions - essential for the natural, warm conversation experience agents expect.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:44.453535-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:44.453535-06:00","labels":["backend","data-modeling","infrastructure","integration","websocket"],"dependencies":[{"issue_id":"test-e3t1s2","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:07:45.005974-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s2","depends_on_id":"test-e3t1s1","type":"blocks","created_at":"2026-01-30T12:09:32.039354-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s3","title":"Implement audio codec handling with Opus encoding/decoding","description":"Set up Opus audio codec for encoding/decoding audio streams. Create AudioCodec utility class with encode(pcmBuffer) and decode(opusBuffer) methods. Configure for optimal real-time voice settings: 16kHz sample rate, mono channel, 20ms frame size. Implement audio buffer management to handle incoming chunks and reassemble for processing. Add support for browser MediaStream API format and raw PCM for server-side processing.\n\n**Context:** Opus is the gold standard for real-time voice - it's what Discord, Zoom, and WebRTC use. The 20ms frame size matches our latency target. Proper codec handling ensures audio quality remains high even on poor network connections, which matters for agents calling from their cars or open houses.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:45.555571-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:45.555571-06:00","labels":["audio","backend","codec","integration","ml-prompting"],"dependencies":[{"issue_id":"test-e3t1s3","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:07:45.809514-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s3","depends_on_id":"test-e3t1s2","type":"blocks","created_at":"2026-01-30T12:09:32.274686-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t1s4","title":"Wire audio streaming pipeline and verify end-to-end latency","description":"Connect all components: WebSocket receives audio  decode from Opus  send to LFM SDK  receive AI response  encode to Opus  send back via WebSocket. Implement streaming response handling so AI responses start playing before fully generated. Add latency instrumentation to measure time from audio-in to audio-out. Create a simple test client (can be Node.js script or basic HTML page) to verify the full pipeline. Target: \u003c500ms total round-trip latency.\n\n**Context:** This is where the 'magic' comes together. Sub-500ms latency is critical - anything slower feels like a laggy phone call and breaks the illusion of natural conversation. Streaming responses mean the AI starts talking immediately rather than waiting to generate the full response.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:46.269291-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:46.269291-06:00","labels":["api","backend","integration","performance","testing"],"dependencies":[{"issue_id":"test-e3t1s4","depends_on_id":"test-e3t1","type":"parent-child","created_at":"2026-01-30T12:07:46.489157-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t1s4","depends_on_id":"test-e3t1s3","type":"blocks","created_at":"2026-01-30T12:09:32.512524-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2","title":"Implement debrief conversation flow with prompts and follow-ups","description":"Build the conversational AI logic for debriefs: opening prompts, context-aware follow-up questions, handling agent responses, and graceful wrap-up detection. The AI should guide agents through recounting their day's activities while feeling like a natural conversation, not an interrogation.\n\n**Context:** This is the core value proposition - making CRM updates feel like chatting with a helpful colleague instead of data entry. The conversation must extract actionable information (contacts, tasks, meeting notes) while feeling warm and supportive.","design":"Create a conversation state machine with phases: greeting, open-ended debrief, clarifying questions, wrap-up. Use system prompts that match brand voice (warm, supportive, efficient). Store conversation state in Convex for resumability. Include prompts for common real estate scenarios (showings, offers, client calls).","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:02.289275-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:02.289275-06:00","labels":["ai","backend","conversation-design"],"dependencies":[{"issue_id":"test-e3t2","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:07:02.41889-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2","depends_on_id":"test-e3t1","type":"blocks","created_at":"2026-01-30T12:09:32.72231-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s1","title":"Define conversation state machine types and Convex schema","description":"Create TypeScript types for conversation phases (greeting, open_debrief, clarifying, wrap_up) and state transitions. Define Convex schema for storing conversation state including: current phase, extracted entities so far, question history, and resumability metadata. Include types for real estate-specific entity extraction (contacts, properties, showings, offers, tasks).\n\n**Context:** The state machine is the foundation for natural conversation flow. Storing state in Convex enables resumability if an agent gets interrupted mid-debrief, which is common in real estate.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:46.70945-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:46.70945-06:00","labels":["ai","auth","backend","convex","types"],"dependencies":[{"issue_id":"test-e3t2s1","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:07:46.948338-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s2","title":"Create system prompts for each conversation phase","description":"Write system prompts for each phase that match brand voice (warm, supportive, efficient). Greeting prompt should feel like checking in with a colleague. Open debrief prompt encourages storytelling ('Tell me about your day'). Clarifying prompt extracts specifics without feeling like interrogation. Wrap-up prompt confirms extracted info and ends warmly. Include real estate scenario handling: showings, offers received/made, client calls, listing appointments, open houses.\n\n**Context:** The prompts ARE the product experience. They must feel like talking to a helpful colleague who genuinely wants to help, not a data-hungry robot. Real estate agents deal with rejection daily - this should feel supportive.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:47.431843-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:47.431843-06:00","labels":["ai","api","backend","prompts","ux"],"dependencies":[{"issue_id":"test-e3t2s2","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:07:47.702227-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s2","depends_on_id":"test-e3t2s1","type":"blocks","created_at":"2026-01-30T12:09:32.923877-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s3","title":"Implement conversation flow controller with phase transitions","description":"Build the core conversation controller that: 1) Initializes new conversations with greeting, 2) Processes agent responses and extracts entities using AI, 3) Determines when to ask follow-up questions vs move to next phase, 4) Detects wrap-up signals (agent says 'that's it', conversation naturally concludes), 5) Persists state to Convex after each turn. Include logic for generating context-aware follow-ups based on extracted entities (e.g., 'You mentioned showing 123 Oak St - how did the buyers react?').\n\n**Context:** This controller orchestrates the entire debrief experience. It must balance thoroughness (getting all the CRM data) with respect for the agent's time. Context-aware follow-ups show the AI is actually listening.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:48.316039-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:48.316039-06:00","labels":["ai","backend","core","monitoring","validation"],"dependencies":[{"issue_id":"test-e3t2s3","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:07:48.676212-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s3","depends_on_id":"test-e3t2s1","type":"blocks","created_at":"2026-01-30T12:09:33.171528-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s3","depends_on_id":"test-e3t2s2","type":"blocks","created_at":"2026-01-30T12:09:33.370575-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t2s4","title":"Add conversation API endpoint and verify end-to-end flow","description":"Create Convex mutation/query endpoints for: starting a debrief, submitting agent response, getting AI response, ending conversation. Wire up to existing voice transcription output. Test complete flow: agent speaks  transcription  conversation controller  AI response  text-to-speech. Verify state persists correctly and conversations can be resumed.\n\n**Context:** This connects all the pieces into a working product. The API must be simple enough for the mobile app to integrate easily while handling the complexity of stateful conversations.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:49.006166-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:49.006166-06:00","labels":["api","backend","integration","monitoring","testing","validation"],"dependencies":[{"issue_id":"test-e3t2s4","depends_on_id":"test-e3t2","type":"parent-child","created_at":"2026-01-30T12:07:49.160784-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t2s4","depends_on_id":"test-e3t2s3","type":"blocks","created_at":"2026-01-30T12:09:33.863797-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3","title":"Add interruption handling and conversation control","description":"Implement barge-in detection so the AI stops speaking when the user interrupts. Add logic for the AI to recognize natural conversation endings and wrap up gracefully. Handle edge cases like long pauses, unclear responses, and user requests to repeat or clarify.\n\n**Context:** Natural conversations involve interruptions and back-and-forth. Agents are busy people - if they have to wait for the AI to finish a sentence before correcting it, the experience feels robotic and frustrating.","design":"Implement voice activity detection (VAD) to detect when user starts speaking during AI output. Use silence thresholds to detect conversation lulls. Add explicit wrap-up triggers ('that's all for today', 'I think we're done'). Consider confidence scoring for when AI should ask clarifying questions vs. move on.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:02.578786-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:02.578786-06:00","labels":["ai","audio","ux"],"dependencies":[{"issue_id":"test-e3t3","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:07:02.705378-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3","depends_on_id":"test-e3t1","type":"blocks","created_at":"2026-01-30T12:09:35.097336-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3","depends_on_id":"test-e3t2","type":"blocks","created_at":"2026-01-30T12:09:35.335488-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s1","title":"Implement Voice Activity Detection (VAD) for barge-in","description":"Add voice activity detection to the audio input stream that monitors for user speech while AI is outputting audio. When user voice is detected above threshold, immediately signal the AI audio output to stop. Use Web Audio API's AnalyserNode for real-time audio level monitoring or integrate a VAD library like @ricky0123/vad-web. Configure sensitivity thresholds to distinguish intentional speech from background noise (coughs, TV, etc.).\n\n**Context:** Barge-in is critical for natural conversation - agents will interrupt to correct the AI or redirect, and waiting for the AI to finish feels robotic and wastes their time.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:49.445302-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:49.445302-06:00","labels":["audio","backend","core-experience","frontend","types","utilities"],"dependencies":[{"issue_id":"test-e3t3s1","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:07:49.680116-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s2","title":"Add silence detection and conversation lull handling","description":"Implement silence threshold detection (e.g., 3 seconds of silence after AI finishes speaking) to determine when user isn't responding. Create tiered responses: short silence (2-3s) triggers gentle prompt ('Are you still there?' or 'Would you like to add anything about that showing?'), medium silence (5-7s) triggers recap/offer to continue later, long silence (10s+) gracefully ends the session with summary. Store silence thresholds as configurable values.\n\n**Context:** Real phone calls have natural pauses - the AI needs to handle these gracefully without awkward silence or premature session endings. Agents might be checking notes or thinking.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:49.895916-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:49.895916-06:00","labels":["algorithms","backend","conversation-flow","frontend","matching"],"dependencies":[{"issue_id":"test-e3t3s2","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:07:50.04551-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s2","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T12:09:35.533704-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s3","title":"Implement conversation wrap-up triggers and graceful endings","description":"Add intent recognition for wrap-up phrases in the AI prompt/system context: 'that's all', 'I think we're done', 'nothing else', 'gotta go', 'let's wrap up'. When detected, AI should acknowledge completion, provide brief summary of captured data, confirm any pending actions, and end session cleanly. Implement a wrap-up state machine: detected  summarizing  confirming  ended. Add explicit 'end session' voice command recognition.\n\n**Context:** Agents need to feel in control of the conversation length. A clear ending with confirmation that data was captured gives confidence the tool is working.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:50.257705-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:50.257705-06:00","labels":["ai-prompting","api","backend","business-logic","conversation-flow","fub"],"dependencies":[{"issue_id":"test-e3t3s3","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T11:10:51.871363-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s3","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:07:50.400256-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s3","depends_on_id":"test-e3t3s2","type":"blocks","created_at":"2026-01-30T12:09:35.767844-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s4","title":"Handle edge cases: unclear responses, repeat/clarify requests","description":"Implement confidence scoring in AI responses to determine when to ask clarifying questions vs. accept ambiguous input. Add handlers for user requests: 'can you repeat that?', 'what did you say?', 'I didn't catch that'. Store last AI response for replay. Handle mumbled/unclear user audio by prompting for repetition with context ('I didn't quite catch the client's name - could you say that again?'). Add recovery for conversation derailment (off-topic responses should gently redirect).\n\n**Context:** Real conversations aren't perfect - agents might mumble, phones have bad connections, AI might mishear. Graceful recovery from these moments maintains trust in the system.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:50.790908-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:50.790908-06:00","labels":["ai-prompting","api","backend","edge-cases","frontend","integration","logging","workflow"],"dependencies":[{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3s3","type":"blocks","created_at":"2026-01-30T11:10:52.252375-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:07:50.955949-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T12:09:36.387417-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s4","depends_on_id":"test-e3t3s2","type":"blocks","created_at":"2026-01-30T12:09:36.601948-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t3s5","title":"Integrate and test full interruption handling flow","description":"Wire together VAD, silence detection, wrap-up triggers, and edge case handlers into cohesive conversation controller. Ensure state transitions are clean and predictable. Add logging/telemetry for interruption events (frequency, timing, which phrases trigger wrap-up). Test complete conversation flows with various interruption patterns. Verify no audio overlap or echo issues when interrupting. Document the conversation state machine and configuration options.\n\n**Context:** Individual features must work together seamlessly - a choppy experience from poorly integrated systems would undermine the 'magic' of natural conversation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:51.240794-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:51.240794-06:00","labels":["documentation","integration","testing"],"dependencies":[{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3","type":"parent-child","created_at":"2026-01-30T12:07:51.531133-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s1","type":"blocks","created_at":"2026-01-30T12:09:36.80868-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s2","type":"blocks","created_at":"2026-01-30T12:09:37.056229-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s3","type":"blocks","created_at":"2026-01-30T12:09:37.308001-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t3s5","depends_on_id":"test-e3t3s4","type":"blocks","created_at":"2026-01-30T12:09:37.531826-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4","title":"Build transcript generation with speaker labels and timestamps","description":"Generate structured transcripts from conversations with accurate speaker diarization (AI vs. agent), precise timestamps, and clean formatting. Store transcripts in Convex linked to the conversation/debrief record.\n\n**Context:** Transcripts serve dual purposes: agents can review what they said, and the system uses them for data extraction. Accurate speaker labels are essential for knowing what the agent reported vs. what the AI asked.","design":"Use LFM's transcription output if available, otherwise integrate a separate ASR. Store transcript as array of segments: {speaker, text, start_time, end_time}. Index transcripts for search. Consider storing both raw (with filler words) and cleaned versions.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:02.906079-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:02.906079-06:00","labels":["ai","backend","data"],"dependencies":[{"issue_id":"test-e3t4","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:07:03.031514-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4","depends_on_id":"test-e3t2","type":"blocks","created_at":"2026-01-30T12:09:37.696491-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s1","title":"Define transcript segment schema and Convex table","description":"Create TypeScript types and Convex table schema for transcript storage. Define the segment structure: {speaker: 'agent' | 'ai', text: string, start_time: number, end_time: number, is_cleaned: boolean}. Create a 'transcripts' table with fields: conversation_id (reference), debrief_id (reference), segments (array), raw_segments (array for unprocessed version), created_at, duration_seconds. Add indexes for conversation_id and full-text search on segment text.\n\n**Context:** The transcript schema is foundational - it determines how we store, query, and display conversation history. The dual raw/cleaned approach preserves original data while enabling clean display. Speaker labels ('agent' vs 'ai') are critical for downstream data extraction to know what the agent reported vs what was asked.\n\n**Testing Requirements:**\n- **Unit Tests:** Validate segment type constraints; Test transcript creation with sample data; Verify indexes work for lookups\n- **Integration Tests:** Create transcript linked to conversation record; Query transcripts by conversation_id","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:51.832882-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:51.832882-06:00","labels":["backend","database","infrastructure","integration","schema"],"dependencies":[{"issue_id":"test-e3t4s1","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:07:52.027922-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s2","title":"Implement transcript processing from LFM transcription output","description":"Create a transcript processor that takes LFM's real-time transcription output and structures it into our segment format. Handle speaker diarization by tracking conversation turn-taking (AI speaks, then agent responds). Implement timestamp alignment from LFM's word-level timestamps. Create both raw (with filler words like 'um', 'uh') and cleaned versions. Handle edge cases: overlapping speech, long pauses, incomplete sentences.\n\n**Context:** LFM provides transcription during the conversation - we need to transform that into our structured format. Accurate speaker assignment is essential because the debrief extraction needs to know what the agent said (facts to extract) vs what the AI said (prompts/questions). The warm, natural conversation means agents will use filler words we should preserve in raw but clean for readability.\n\n**Testing Requirements:**\n- **Unit Tests:** Parse LFM transcription format correctly; Assign speakers based on turn-taking; Generate accurate timestamps; Clean filler words while preserving meaning; Handle overlapping speech gracefully\n- **Integration Tests:** Process full mock conversation; Verify segment continuity","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:52.442607-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:52.442607-06:00","labels":["api-integration","audio","backend","data","processing"],"dependencies":[{"issue_id":"test-e3t4s2","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:07:52.769749-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s2","depends_on_id":"test-e3t4s1","type":"blocks","created_at":"2026-01-30T12:09:37.934615-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s3","title":"Create Convex mutations and queries for transcript CRUD","description":"Implement Convex functions: createTranscript (link to conversation, store segments), appendSegments (for real-time updates during conversation), getTranscriptByConversation, getTranscriptByDebrief, searchTranscripts (full-text search across segment text). Include a formatTranscriptForDisplay helper that returns readable text with speaker labels and timestamps.\n\n**Context:** Transcripts need to be created in real-time as the conversation happens (appendSegments), then finalized. Agents reviewing their debriefs need to see what was said (getTranscriptByDebrief). Search enables finding past conversations by content - useful for both agents and the brokerage owner reviewing team activity.\n\n**Testing Requirements:**\n- **Unit Tests:** Create transcript with valid data; Append segments maintains order; Search returns matching transcripts; Format function produces readable output\n- **Integration Tests:** Full CRUD lifecycle; Search across multiple transcripts; Link transcript to existing conversation","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:53.55019-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:53.55019-06:00","labels":["api","backend","convex","crm","frontend","monitoring"],"dependencies":[{"issue_id":"test-e3t4s3","depends_on_id":"test-e3t4s2","type":"blocks","created_at":"2026-01-30T11:10:55.001752-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s3","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:07:53.761422-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s3","depends_on_id":"test-e3t4s1","type":"blocks","created_at":"2026-01-30T12:09:38.149787-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t4s4","title":"Wire transcript generation into conversation flow and verify end-to-end","description":"Integrate transcript processing into the AI conversation handler from Epic 3. When conversation starts, create transcript record. As LFM streams transcription, process segments and append to transcript. On conversation end, finalize transcript with cleaned version. Test full flow: start conversation  speak  verify transcript stored with correct speakers and timestamps. Add error handling for transcription failures (store partial transcript, flag for review).\n\n**Context:** This connects all the pieces - the conversation (Epic 3.1-3.3) generates audio, LFM transcribes it, and this system structures and stores it. Without this integration, we have no record of what was discussed. Error handling is important because a transcription failure shouldn't lose the entire debrief - partial data is better than none.\n\n**Testing Requirements:**\n- **Unit Tests:** Error handling stores partial transcripts; Conversation end triggers finalization\n- **Integration Tests:** Full conversation produces complete transcript; Speaker labels correctly alternate; Timestamps align with actual speech timing","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:53.973628-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:53.973628-06:00","labels":["backend","e2e","integration","reliability","testing"],"dependencies":[{"issue_id":"test-e3t4s4","depends_on_id":"test-e3t4","type":"parent-child","created_at":"2026-01-30T12:07:54.122466-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s4","depends_on_id":"test-e3t4s2","type":"blocks","created_at":"2026-01-30T12:09:38.340205-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t4s4","depends_on_id":"test-e3t4s3","type":"blocks","created_at":"2026-01-30T12:09:38.651066-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5","title":"Create transcript display UI and call recording playback","description":"Build the dashboard UI for viewing conversation transcripts with synchronized audio playback. Include speaker-labeled transcript with clickable timestamps, audio player with waveform visualization, and playback speed controls. Allow agents to review their debriefs easily.\n\n**Context:** Agents need to trust the system and verify what was captured. Being able to listen back and see exactly what was transcribed builds confidence and helps catch any extraction errors before they sync to the CRM.","design":"Use shadcn/ui components for player controls. Highlight current transcript segment during playback. Store call recordings in Convex file storage. Consider privacy controls (who can listen to whose calls based on Clerk roles). Add search within transcript.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:03.212941-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:03.212941-06:00","labels":["dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e3t5","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:07:03.318565-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5","depends_on_id":"test-e3t4","type":"blocks","created_at":"2026-01-30T12:09:38.835059-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s1","title":"Create transcript data types and Convex file storage schema","description":"Define TypeScript interfaces for transcript segments (speaker labels, timestamps, text content) and conversation recordings. Set up Convex file storage schema for audio files with proper metadata (duration, file size, format). Create queries to fetch transcripts with their associated audio file URLs.\n\n**Context:** The transcript display needs structured data to render speaker-labeled segments with clickable timestamps. File storage must support streaming playback and secure access based on user permissions.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:54.330229-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:54.330229-06:00","labels":["api","backend","database","schema"],"dependencies":[{"issue_id":"test-e3t5s1","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:07:54.48903-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s2","title":"Build audio player component with waveform and playback controls","description":"Create a React audio player using shadcn/ui components with: play/pause button, progress bar with waveform visualization (use wavesurfer.js or similar), playback speed controls (0.5x, 1x, 1.5x, 2x), volume control, and current time display. The player should expose callbacks for currentTime changes to sync with transcript.\n\n**Context:** Agents reviewing debriefs need professional playback controls. Waveform visualization helps them visually navigate to specific parts of the conversation and makes the experience feel polished.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:54.657089-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:54.657089-06:00","labels":["backend","component","frontend","reliability","ui"],"dependencies":[{"issue_id":"test-e3t5s2","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:07:54.777088-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s2","depends_on_id":"test-e3t5s1","type":"blocks","created_at":"2026-01-30T12:09:39.036647-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s3","title":"Implement transcript display with synchronized highlighting and search","description":"Build the transcript viewer component showing speaker-labeled segments with timestamps. Implement: clickable timestamps that seek audio to that position, automatic highlight of current segment during playback (based on audio currentTime), search functionality that filters/highlights matching text, and smooth auto-scroll to keep current segment visible.\n\n**Context:** This is where agents verify what was captured. The synchronization between audio and text builds trust - they can hear exactly what was said while reading the transcription, catching any errors before data syncs to CRM.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:55.007146-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:55.007146-06:00","labels":["backend","component","frontend","realtime","ui"],"dependencies":[{"issue_id":"test-e3t5s3","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:07:55.148095-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s3","depends_on_id":"test-e3t5s1","type":"blocks","created_at":"2026-01-30T12:09:39.211182-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s3","depends_on_id":"test-e3t5s2","type":"blocks","created_at":"2026-01-30T12:09:39.401038-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s4","title":"Add privacy controls and role-based access for call recordings","description":"Implement Clerk-based access controls: solo agents see only their own calls, team leads see their team's calls, brokerage owners see all calls. Add Convex query filters based on user role from Clerk JWT. Create UI indicators showing who recorded the call and display appropriate error states for unauthorized access attempts.\n\n**Context:** Real estate conversations contain sensitive client information. Agents must trust that their calls aren't being reviewed without appropriate permissions. Clear access controls build organizational trust in the system.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:55.337469-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:55.337469-06:00","labels":["backend","frontend","integration","security","testing"],"dependencies":[{"issue_id":"test-e3t5s4","depends_on_id":"test-e3t5s3","type":"blocks","created_at":"2026-01-30T11:10:56.8869-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s4","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:07:55.529625-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s4","depends_on_id":"test-e3t5s1","type":"blocks","created_at":"2026-01-30T12:09:39.588001-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t5s5","title":"Integrate transcript view into dashboard and verify end-to-end flow","description":"Wire the transcript display into the main dashboard with navigation from call history to transcript detail view. Add loading states, error boundaries, and empty states (no transcript available). Test the complete flow: select a call from history  view transcript with audio  search, seek, and playback at different speeds  verify privacy controls work correctly.\n\n**Context:** The transcript review must be easily accessible from where agents naturally work. A smooth flow from call list to detailed review encourages agents to verify their debriefs, improving data quality.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:55.837801-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:55.837801-06:00","labels":["frontend","integration"],"dependencies":[{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5","type":"parent-child","created_at":"2026-01-30T12:07:56.318915-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5s2","type":"blocks","created_at":"2026-01-30T12:09:39.768096-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5s3","type":"blocks","created_at":"2026-01-30T12:09:39.96694-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t5s5","depends_on_id":"test-e3t5s4","type":"blocks","created_at":"2026-01-30T12:09:40.179334-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6","title":"Verify end-to-end voice conversation flow","description":"Conduct comprehensive testing of the complete voice AI pipeline: initiate call  stream audio bidirectionally  conduct debrief conversation  handle interruptions  generate transcript  store and display results. Verify latency requirements and conversation quality.\n\n**Context:** All the individual pieces must work together seamlessly. A single weak link (laggy audio, poor transcript, missed interruption) breaks the 'magic' experience that makes agents actually want to use RealHerd.","design":"Create test scenarios covering: smooth conversation, interruption-heavy conversation, poor audio quality, long debrief (20+ minutes), quick debrief (2 minutes). Document latency at each stage. Verify warm/conversational tone in AI responses.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:03.477053-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:03.477053-06:00","labels":["integration","qa","testing"],"dependencies":[{"issue_id":"test-e3t6","depends_on_id":"test-e3","type":"parent-child","created_at":"2026-01-30T12:07:03.578847-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6","depends_on_id":"test-e3t3","type":"blocks","created_at":"2026-01-30T12:09:40.423504-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6","depends_on_id":"test-e3t5","type":"blocks","created_at":"2026-01-30T12:09:40.60949-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s1","title":"Create E2E test infrastructure and test scenarios","description":"Set up end-to-end testing infrastructure for voice conversations. Create test scenario definitions for: (1) smooth 5-minute debrief, (2) interruption-heavy conversation with 10+ interruptions, (3) simulated poor audio quality with dropouts, (4) extended 20+ minute debrief, (5) quick 2-minute debrief. Define expected behaviors and acceptance criteria for each. Create test fixtures including sample audio files and expected transcript patterns.\n\n**Context:** Structured test scenarios ensure we systematically verify all edge cases. Without predefined scenarios, testing will be ad-hoc and miss critical failure modes that users will hit in production.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:56.558291-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:56.558291-06:00","labels":["demo","infrastructure","testing"],"dependencies":[{"issue_id":"test-e3t6s1","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:07:56.731253-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s2","title":"Execute core conversation flow tests with latency measurement","description":"Run E2E tests for smooth conversation and quick debrief scenarios. Measure latency at each stage: (1) call initiation to audio stream start, (2) user speech to AI response start (turn-taking latency), (3) transcript generation time, (4) data storage completion. Document actual values against requirements: turn-taking \u003c500ms, transcript within 2s of speech end. Verify warm/conversational tone in AI responses matches design intent.\n\n**Context:** Core happy-path testing validates that the fundamental pipeline works. Latency measurements establish baseline performance and identify any bottlenecks that break the 'magic' conversational experience.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:56.94858-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:56.94858-06:00","labels":["backend","performance","testing","voice-ai"],"dependencies":[{"issue_id":"test-e3t6s2","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:07:57.230196-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6s2","depends_on_id":"test-e3t6s1","type":"blocks","created_at":"2026-01-30T12:09:40.808904-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s3","title":"Execute stress and edge case tests","description":"Run E2E tests for challenging scenarios: (1) interruption-heavy conversation - verify AI handles being cut off gracefully and doesn't repeat itself, (2) poor audio quality - verify graceful degradation and error messaging, (3) 20+ minute extended debrief - verify no memory issues, consistent performance, accurate full transcript. Document any failures or degraded behavior with reproduction steps.\n\n**Context:** Edge cases are where user trust is won or lost. An AI that handles interruptions poorly or fails on long calls will frustrate power users and team leads who rely on RealHerd for their busiest days.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:57.482856-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:57.482856-06:00","labels":["backend","edge-cases","reporting","testing","voice-ai"],"dependencies":[{"issue_id":"test-e3t6s3","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:07:57.651852-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6s3","depends_on_id":"test-e3t6s2","type":"blocks","created_at":"2026-01-30T12:09:41.141569-06:00","created_by":"David Habedank"}]}
{"id":"test-e3t6s4","title":"Verify data persistence and UI display of conversation results","description":"For all completed test conversations, verify: (1) transcripts are correctly stored in database with proper timestamps and speaker attribution, (2) structured data extraction (showing details, client info) matches transcript content, (3) UI displays conversation history accurately, (4) transcript search/filter works correctly, (5) conversation can be replayed or reviewed. Document any data integrity issues.\n\n**Context:** The voice conversation is only valuable if its insights persist correctly. A perfect conversation that stores corrupted data or displays incorrectly provides zero value to agents reviewing their client interactions.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:07:57.87475-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:57.87475-06:00","labels":["database","demo","documentation","frontend","testing"],"dependencies":[{"issue_id":"test-e3t6s4","depends_on_id":"test-e3t6","type":"parent-child","created_at":"2026-01-30T12:07:58.057339-06:00","created_by":"David Habedank"},{"issue_id":"test-e3t6s4","depends_on_id":"test-e3t6s3","type":"blocks","created_at":"2026-01-30T12:09:41.397393-06:00","created_by":"David Habedank"}]}
{"id":"test-e4","title":"Data Extraction \u0026 CRM Sync","description":"Build the extraction pipeline to pull structured data from voice conversations (temperature, stage, notes, tasks, timeline). Integrate with Follow Up Boss API for automatic CRM updates.\n\n**Context:** The value proposition is keeping CRM current without agent effort. Extraction accuracy and reliable sync are critical - bad data or failed syncs destroy trust.","acceptance_criteria":"- Extraction prompts implemented for debrief calls\n- ExtractedData populated with temperature, stage, summary, tasks, timeline\n- Confidence scoring on all extractions\n- Follow Up Boss API key configuration in org settings\n- FUB connection testing and validation works\n- Lead matching by phone, email, or name\n- Notes created in FUB with formatted summary\n- Lead fields updated (stage, temperature via custom fields)\n- Tasks created in FUB for follow-ups\n- Sync status displayed in dashboard (pending/syncing/synced/failed)\n- OpenRouter fallback for low-confidence extractions\n- CRM sync logs stored for debugging","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:06:56.384357-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:56.384357-06:00","labels":["core-feature","crm","extraction","follow-up-boss"],"dependencies":[{"issue_id":"test-e4","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:41.660753-06:00","created_by":"David Habedank"},{"issue_id":"test-e4","depends_on_id":"test-e3","type":"blocks","created_at":"2026-01-30T12:09:41.901477-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1","title":"Build extraction prompt system for debrief calls","description":"Create the core extraction pipeline that processes transcribed voice conversations and extracts structured data: temperature (hot/warm/cold), stage (lead/active/pending/closed), summary notes, follow-up tasks, and timeline information.\n\n**Context:** This is the foundation of RealHerd's value prop - agents speak naturally about their deals and the system captures everything. Without accurate extraction, the entire CRM sync is worthless. Uses LFM 2.5-Audio-1.5B for primary extraction.","design":"Create Convex actions for extraction processing. Design prompt templates optimized for real estate domain (recognize common terms: listing appointment, showing, offer, under contract, etc.). Structure output as ExtractedData type with all required fields. Implement confidence scoring (0-1) for each extracted field based on signal clarity in transcript.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:03.711443-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:03.711443-06:00","labels":["ai","backend","extraction"],"dependencies":[{"issue_id":"test-e4t1","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:07:03.82664-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s1","title":"Define ExtractedData TypeScript types and schema","description":"Create comprehensive TypeScript types for the extraction output including: ExtractedData type with temperature (hot/warm/cold enum), stage (lead/active/pending/closed enum), summary (string), followUpTasks (array of task objects with description and due date), timeline (key dates mentioned), and confidence scores (0-1 number for each field). Also define the input TranscriptInput type and any intermediate types needed for the extraction pipeline.\n\n**Context:** These types are the contract between the extraction system and the rest of the app. Getting them right upfront ensures type safety throughout the CRM sync pipeline and makes it clear what data we're extracting.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:07:58.365-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:58.365-06:00","labels":["backend","integration","schema","types"],"dependencies":[{"issue_id":"test-e4t1s1","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:07:58.566878-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s2","title":"Create real estate domain-specific prompt templates","description":"Design and implement prompt templates optimized for real estate conversation extraction. Include: (1) System prompt establishing the extraction task and real estate context, (2) Recognition patterns for domain terms (listing appointment, showing, offer, under contract, contingency, closing date, buyer/seller, price points), (3) Stage detection heuristics (e.g., 'just met' = lead, 'under contract' = pending), (4) Temperature inference rules (multiple showings = warm, ready to write offer = hot), (5) Follow-up task extraction patterns. Store templates in a dedicated file for easy iteration.\n\n**Context:** The prompt engineering is where extraction accuracy lives or dies. Real estate has specific vocabulary and workflows that generic extraction would miss. Agents saying 'they want to see it again tomorrow' means a hot showing follow-up, not just a casual mention.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:07:58.813034-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:58.813034-06:00","labels":["ai","backend","mutations","prompts"],"dependencies":[{"issue_id":"test-e4t1s2","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:07:59.102987-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s2","depends_on_id":"test-e4t1s1","type":"blocks","created_at":"2026-01-30T12:09:42.115211-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s3","title":"Implement Convex extraction action with LLM integration","description":"Build the core Convex action that takes a transcript and returns ExtractedData. Implement: (1) Action function that accepts transcript text and optional metadata, (2) LLM API call using the prompt templates (configure for LFM 2.5-Audio-1.5B or fallback), (3) Response parsing to convert LLM output into typed ExtractedData, (4) Confidence score calculation based on signal clarity (explicit mentions = high confidence, inferred = lower), (5) Error handling for malformed LLM responses or API failures. Include retry logic for transient failures.\n\n**Context:** This action is the workhorse that every debrief call flows through. It needs to be reliable, handle edge cases gracefully, and produce structured data that downstream sync can trust.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:07:59.411128-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:59.411128-06:00","labels":["ai","backend","convex","security","settings"],"dependencies":[{"issue_id":"test-e4t1s3","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:07:59.588844-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s3","depends_on_id":"test-e4t1s1","type":"blocks","created_at":"2026-01-30T12:09:42.405153-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s3","depends_on_id":"test-e4t1s2","type":"blocks","created_at":"2026-01-30T12:09:42.586234-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t1s4","title":"Add extraction logging and verify end-to-end pipeline","description":"Implement extraction result logging for debugging and iteration: (1) Store extraction results in Convex table with input transcript, output ExtractedData, confidence scores, and timestamp, (2) Add structured logging for each extraction showing what was detected, (3) Create a simple test harness that runs extraction on 3-5 realistic sample transcripts and outputs results for manual review. Run the full pipeline end-to-end and verify outputs match expected extraction for sample data.\n\n**Context:** We need visibility into extraction quality to iterate on prompts and catch regressions. This logging becomes the foundation for improving accuracy over time based on real conversations.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:07:59.806684-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:59.806684-06:00","labels":["backend","convex","integration","testing","verification"],"dependencies":[{"issue_id":"test-e4t1s4","depends_on_id":"test-e4t1","type":"parent-child","created_at":"2026-01-30T12:07:59.968163-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t1s4","depends_on_id":"test-e4t1s3","type":"blocks","created_at":"2026-01-30T12:09:42.933609-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2","title":"Implement Follow Up Boss API integration","description":"Build the FUB API client with org-level API key configuration, connection testing, and core operations: lead lookup (by phone/email/name), note creation, lead field updates, and task creation.\n\n**Context:** Follow Up Boss is the dominant CRM in real estate. Seamless, reliable sync is what differentiates RealHerd from manual entry. Failed syncs or wrong lead matching destroys agent trust instantly.","design":"Store encrypted API keys in org settings (Convex). Implement FUB API wrapper with: searchPeople (phone, email, name matching with fuzzy logic), createNote (formatted markdown), updatePerson (stage, custom fields for temperature), createTask (with due dates). Include retry logic with exponential backoff. Log all API calls for debugging.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:04.115966-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:04.115966-06:00","labels":["api","backend","integration"],"dependencies":[{"issue_id":"test-e4t2","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:07:04.212122-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s1","title":"Create FUB API key storage and org settings schema","description":"Add encrypted API key storage to Convex org settings. Create schema for storing FUB credentials with encryption at rest. Include fields for: api_key (encrypted), connected_at timestamp, last_verified_at, connection_status enum. Implement encryption/decryption helpers using Convex's recommended patterns.\n\n**Context:** Secure credential storage is foundational - agents trust us with their CRM access. Encryption protects against data breaches. Connection status tracking enables health monitoring and user feedback.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:00.297527-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:00.297527-06:00","labels":["backend","convex","database","frontend","security","ui"],"dependencies":[{"issue_id":"test-e4t2s1","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:08:01.083516-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s2","title":"Build FUB API client with connection testing","description":"Create TypeScript FUB API wrapper class with: base HTTP client configured for FUB's REST API (https://api.followupboss.com/v1/), API key header injection, connection test endpoint (/me or /users), comprehensive error handling for auth failures vs network issues. Include retry logic with exponential backoff (initial 1s, max 3 retries, backoff multiplier 2x). Log all API calls with timestamp, endpoint, response status, and duration for debugging.\n\n**Context:** The API client is the foundation for all FUB operations. Connection testing lets agents verify their key works before trusting the integration. Retry logic handles FUB's occasional rate limits and network blips. Logging is critical for debugging failed syncs - agents need to see what happened.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:01.378844-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:01.378844-06:00","labels":["api","backend","integration","integrations"],"dependencies":[{"issue_id":"test-e4t2s2","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:08:01.520765-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s2","depends_on_id":"test-e4t2s1","type":"blocks","created_at":"2026-01-30T12:09:43.177254-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s3","title":"Implement lead lookup with fuzzy matching","description":"Build searchPeople function using FUB's /people endpoint with multi-strategy matching: 1) Exact phone match (normalized to digits only), 2) Exact email match (case-insensitive), 3) Name fuzzy match (handle 'Bob'/'Robert', last name variations). Return confidence score (high/medium/low) based on match quality. Handle multiple matches by returning all candidates with match reasons. Include phone normalization utility (strip formatting, handle +1 prefix).\n\n**Context:** Lead matching is where trust is made or broken. Wrong matches mean notes on wrong people - agents lose faith immediately. Fuzzy matching handles real-world messiness (nicknames, typos). Confidence scores let the system decide when to auto-match vs ask for confirmation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:01.733933-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:01.733933-06:00","labels":["api","backend","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e4t2s3","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:08:01.90063-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s3","depends_on_id":"test-e4t2s2","type":"blocks","created_at":"2026-01-30T12:09:43.368546-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t2s4","title":"Implement note creation, lead updates, and task creation","description":"Build three FUB write operations: 1) createNote - POST to /notes with formatted markdown body, person_id, optional subject line. 2) updatePerson - PATCH to /people/{id} for stage changes and custom field updates (map temperature to FUB stage or custom field). 3) createTask - POST to /tasks with title, description, due_date, person_id, assignee. All operations must validate inputs, handle FUB's specific error responses, and log outcomes. Return standardized success/failure response with FUB entity IDs.\n\n**Context:** These write operations are the actual value delivery - call summaries become CRM notes, AI insights update lead temperature, follow-up tasks get created automatically. Each must be bulletproof because failed writes mean lost work and broken trust.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:02.0918-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:02.0918-06:00","labels":["api","backend","calendar","integration","integrations","testing","verification"],"dependencies":[{"issue_id":"test-e4t2s4","depends_on_id":"test-e4t2","type":"parent-child","created_at":"2026-01-30T12:08:02.285542-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t2s4","depends_on_id":"test-e4t2s3","type":"blocks","created_at":"2026-01-30T12:09:43.533079-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3","title":"Build CRM sync orchestration and status tracking","description":"Create the sync pipeline that takes ExtractedData, matches leads in FUB, creates/updates records, and tracks sync status (pending/syncing/synced/failed) with full logging.\n\n**Context:** Agents need to trust the system is working. Clear status visibility (did my call notes make it to the CRM?) and debugging capability (why did this sync fail?) are essential for adoption.","design":"Convex mutation for initiating sync from ExtractedData. State machine for sync status with timestamps. Lead matching priority: exact phone  exact email  fuzzy name match. Store sync logs with request/response data for debugging. Handle partial success (note created but task failed). Queue system for retry of failed syncs.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:04.340787-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:04.340787-06:00","labels":["backend","orchestration"],"dependencies":[{"issue_id":"test-e4t3","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:07:04.463972-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3","depends_on_id":"test-e4t1","type":"blocks","created_at":"2026-01-30T12:09:43.733471-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3","depends_on_id":"test-e4t2","type":"blocks","created_at":"2026-01-30T12:09:43.94372-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s1","title":"Create sync status schema and state machine types","description":"Define TypeScript types and Convex schema for sync operations: SyncStatus enum (pending/syncing/synced/failed/partial), SyncRecord table with fields for extractedDataId, status, timestamps (createdAt, startedAt, completedAt), fubLeadId (matched lead), syncLogs array, retryCount, and errorDetails. Include SyncLog type with timestamp, action, request/response data, and success boolean.\n\n**Context:** The state machine and logging schema are foundational - every sync operation needs status tracking and full audit trail for debugging when agents ask 'why didn't my notes sync?'","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:02.463035-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:02.463035-06:00","labels":["api","auth","backend","database","types"],"dependencies":[{"issue_id":"test-e4t3s1","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:08:02.574718-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s2","title":"Implement lead matching logic with priority cascade","description":"Create matchLeadInFUB function that takes ExtractedData and returns matched FUB lead ID or null. Implement matching priority: 1) Exact phone number match (normalized), 2) Exact email match (case-insensitive), 3) Fuzzy name match with confidence threshold (\u003e0.8). Use FUB API's search endpoints. Return match confidence score and match type for logging. Handle multiple potential matches by returning highest confidence.\n\n**Context:** Accurate lead matching is critical - matching to wrong lead corrupts CRM data and destroys agent trust. The priority cascade ensures we use most reliable identifiers first.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:02.789057-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:02.789057-06:00","labels":["backend","frontend","fub-api","matching","scheduling"],"dependencies":[{"issue_id":"test-e4t3s2","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:08:02.983194-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s2","depends_on_id":"test-e4t3s1","type":"blocks","created_at":"2026-01-30T12:09:44.149312-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s3","title":"Build sync orchestration mutation with partial success handling","description":"Create syncExtractedDataToFUB Convex mutation that: 1) Creates SyncRecord with pending status, 2) Matches lead using matchLeadInFUB, 3) Updates status to syncing, 4) Creates/updates FUB records (call notes, tasks, person updates) with individual try/catch, 5) Logs each operation with request/response, 6) Handles partial success (some ops succeed, others fail), 7) Updates final status (synced/failed/partial) with timestamps. Use Convex actions for FUB API calls.\n\n**Context:** Real-world syncs often partially succeed - a note might save but a task fails. Agents need to know exactly what worked and what didn't, not just 'sync failed'.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:08:03.188597-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:03.188597-06:00","labels":["backend","convex","frontend","orchestration","scheduling","ui"],"dependencies":[{"issue_id":"test-e4t3s3","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:08:03.3661-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s3","depends_on_id":"test-e4t3s1","type":"blocks","created_at":"2026-01-30T12:09:44.351213-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s3","depends_on_id":"test-e4t3s2","type":"blocks","created_at":"2026-01-30T12:09:44.570577-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t3s4","title":"Implement retry queue and failure recovery","description":"Create retry mechanism for failed syncs: 1) Convex scheduled function that queries failed SyncRecords, 2) Exponential backoff (1min, 5min, 30min, 2hr), 3) Max retry limit (5 attempts), 4) retrySyncRecord mutation that resets status and re-runs orchestration, 5) Query functions: getFailedSyncs, getSyncHistory, getSyncStatus. Include manual retry trigger for agents viewing failed syncs.\n\n**Context:** Network issues and API rate limits cause transient failures. Automatic retry with backoff recovers most failures without agent intervention, while manual retry gives control for persistent issues.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:03.60654-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:03.60654-06:00","labels":["backend","convex","integration","queue","reliability","security","testing"],"dependencies":[{"issue_id":"test-e4t3s4","depends_on_id":"test-e4t3","type":"parent-child","created_at":"2026-01-30T12:08:03.786973-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t3s4","depends_on_id":"test-e4t3s3","type":"blocks","created_at":"2026-01-30T12:09:44.765705-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4","title":"Implement OpenRouter fallback for low-confidence extractions","description":"Add fallback to GPT-4-turbo or Claude via OpenRouter when primary extraction confidence is below threshold. Re-extract with more capable model and merge/override results.\n\n**Context:** LFM is fast and cheap but may miss nuance. For calls where extraction confidence is low, escalating to a frontier model prevents bad data from reaching the CRM. This is the quality safety net.","design":"Set confidence threshold (e.g., \u003c0.7 on any critical field triggers fallback). OpenRouter integration with model selection. Design prompts for GPT-4/Claude that include original transcript + LFM extraction for comparison. Merge logic: prefer higher-confidence values. Track which extractions used fallback for cost monitoring.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:04.622919-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:04.622919-06:00","labels":["ai","backend","fallback"],"dependencies":[{"issue_id":"test-e4t4","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:07:04.738803-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4","depends_on_id":"test-e4t1","type":"blocks","created_at":"2026-01-30T12:09:45.101106-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s1","title":"Create OpenRouter client and model selection utilities","description":"Set up OpenRouter API integration with support for GPT-4-turbo and Claude models. Create a typed client that handles authentication, model selection, and request/response formatting. Include retry logic and error handling for API failures.\n\n**Context:** OpenRouter provides a unified API to multiple frontier models. Having a clean abstraction lets us easily swap models or add new ones without changing fallback logic.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:04.023142-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:04.023142-06:00","labels":["backend","dashboard","database","frontend","integration","react"],"dependencies":[{"issue_id":"test-e4t4s1","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:08:04.155679-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s2","title":"Implement confidence scoring and threshold detection","description":"Add confidence scoring to extraction results for critical fields (names, phone numbers, property addresses, intent signals). Define threshold constant (0.7) and create function to evaluate whether any critical field falls below threshold. Critical fields should be configurable per extraction type.\n\n**Context:** Low confidence on critical CRM fields like contact info or deal stage can corrupt the database. Detecting these cases early lets us route to better models before bad data syncs.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:04.336203-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:04.336203-06:00","labels":["backend","data-table","frontend","react","scheduling"],"dependencies":[{"issue_id":"test-e4t4s2","depends_on_id":"test-e4t4s1","type":"blocks","created_at":"2026-01-30T11:11:00.333484-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s2","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:08:04.494289-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s3","title":"Build fallback extraction with comparison prompts","description":"Create prompts for GPT-4/Claude that include both the original transcript AND the LFM extraction results for comparison. The frontier model should validate/correct the extraction rather than starting fresh. Implement the fallback extraction flow that triggers when confidence threshold is not met.\n\n**Context:** Showing the LFM extraction to the frontier model lets it focus on corrections rather than full re-extraction, which is faster and more accurate. The model can confirm good extractions and fix low-confidence ones.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:04.733283-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:04.733283-06:00","labels":["ai","backend","forms","frontend","react","sms","team-management"],"dependencies":[{"issue_id":"test-e4t4s3","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:08:04.920081-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s3","depends_on_id":"test-e4t4s1","type":"blocks","created_at":"2026-01-30T12:09:45.343912-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s3","depends_on_id":"test-e4t4s2","type":"blocks","created_at":"2026-01-30T12:09:45.532147-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t4s4","title":"Implement result merging and fallback tracking","description":"Create merge logic that combines LFM and fallback extractions, preferring higher-confidence values for each field. Track metadata about which extractions used fallback including: model used, fields corrected, cost incurred, and timestamp. Store this for cost monitoring and quality analysis.\n\n**Context:** Smart merging preserves LFM's good extractions while incorporating frontier model corrections. Tracking fallback usage is essential for understanding costs and identifying patterns where LFM struggles.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:05.235308-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:05.235308-06:00","labels":["backend","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e4t4s4","depends_on_id":"test-e4t4s2","type":"blocks","created_at":"2026-01-30T11:11:00.688847-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s4","depends_on_id":"test-e4t4","type":"parent-child","created_at":"2026-01-30T12:08:05.416026-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t4s4","depends_on_id":"test-e4t4s3","type":"blocks","created_at":"2026-01-30T12:09:45.716992-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5","title":"Build sync status dashboard UI and FUB settings page","description":"Create UI for: org-level FUB API key configuration with connection test button, and dashboard view showing sync status for recent calls (pending/syncing/synced/failed with details on click).\n\n**Context:** Agents and admins need visibility. Without UI, they can't configure FUB connection or see if syncs are working. This closes the loop on the extractionsyncvisibility flow.","design":"Settings page: API key input (masked), 'Test Connection' button with success/error feedback, save with validation. Dashboard component: list of recent syncs with status badges, expandable rows showing ExtractedData summary and sync logs. Use Convex real-time queries for live status updates. Role-based: only broker/team_lead can configure API keys.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:04.926063-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:04.926063-06:00","labels":["dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e4t5","depends_on_id":"test-e4","type":"parent-child","created_at":"2026-01-30T12:07:05.068834-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5","depends_on_id":"test-e4t3","type":"blocks","created_at":"2026-01-30T12:09:45.986452-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s1","title":"Create FUB settings page with API key configuration","description":"Build a settings page component at /settings/integrations/fub with: masked API key input field, 'Test Connection' button that calls a Convex action to validate the key against FUB API, success/error feedback display, and save button with validation. Store API key in organizations table (encrypted). Use role-based access to restrict to broker/team_lead roles only.\n\n**Context:** Admins need to securely configure their FUB connection before any syncing can work. This is the entry point for the entire integration - without a valid API key, nothing else functions.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:05.809355-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:05.809355-06:00","labels":["backend","demo","frontend","messaging","security","settings"],"dependencies":[{"issue_id":"test-e4t5s1","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:08:06.302918-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s2","title":"Build sync status dashboard component with real-time updates","description":"Create a dashboard component showing recent call syncs in a list view. Display: call date/contact name, sync status badge (pending/syncing/synced/failed with distinct colors), last sync attempt timestamp. Use Convex useQuery with real-time subscriptions so status updates appear live without refresh. Show most recent 50 syncs, paginated or with 'load more'.\n\n**Context:** Agents need visibility into whether their call data is actually making it to FUB. Real-time updates build confidence that the system is working and help quickly identify failures.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:06.737685-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:06.737685-06:00","labels":["backend","dashboard","demo","email","frontend","integration","real-time"],"dependencies":[{"issue_id":"test-e4t5s2","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:08:06.891724-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s2","depends_on_id":"test-e4t5s1","type":"blocks","created_at":"2026-01-30T12:09:46.170896-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s3","title":"Add expandable detail rows with sync logs and extracted data summary","description":"Enhance dashboard list items to be expandable on click. Expanded view shows: ExtractedData summary (contact name, key topics, action items truncated), sync attempt history with timestamps and error messages for failures, retry button for failed syncs. Keep collapsed view clean, reveal details progressively.\n\n**Context:** When something fails or agents want to verify what was synced, they need the details. Hiding complexity in expandable rows keeps the UI clean while providing full transparency when needed.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:07.124663-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:07.124663-06:00","labels":["backend","dashboard","demo","external-api","frontend","permissions","ux"],"dependencies":[{"issue_id":"test-e4t5s3","depends_on_id":"test-e4t5s1","type":"blocks","created_at":"2026-01-30T11:11:01.672999-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s3","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:08:07.271145-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s3","depends_on_id":"test-e4t5s2","type":"blocks","created_at":"2026-01-30T12:09:46.435089-06:00","created_by":"David Habedank"}]}
{"id":"test-e4t5s4","title":"Wire up navigation, verify end-to-end flow, and add empty states","description":"Add navigation links to settings and dashboard from main nav/sidebar. Create empty states: 'No API key configured' prompt on dashboard linking to settings, 'No syncs yet' state when no call data exists. Test complete flow: configure API key  make test call  see sync appear and update in real-time on dashboard.\n\n**Context:** Users need to discover these features and understand what to do when starting fresh. Empty states guide setup and the full flow verification ensures all pieces work together.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:07.527866-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:07.527866-06:00","labels":["backend","demo","documentation","frontend","integration","testing","ux"],"dependencies":[{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5s2","type":"blocks","created_at":"2026-01-30T11:11:01.917686-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5","type":"parent-child","created_at":"2026-01-30T12:08:07.734607-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5s1","type":"blocks","created_at":"2026-01-30T12:09:46.610707-06:00","created_by":"David Habedank"},{"issue_id":"test-e4t5s4","depends_on_id":"test-e4t5s3","type":"blocks","created_at":"2026-01-30T12:09:46.78818-06:00","created_by":"David Habedank"}]}
{"id":"test-e5","title":"Call Triggering \u0026 SMS Integration","description":"Implement multiple ways to trigger debrief calls: SMS keyword (DEBRIEF), dashboard button, and calendar auto-calls. Build SMS confirmations after calls complete and retry logic for missed calls.\n\n**Context:** Agents need frictionless ways to trigger calls. The calendar auto-call with retry is the 'set it and forget it' experience that makes RealHerd feel like a proactive manager.","acceptance_criteria":"- SMS inbound handling for DEBRIEF keyword triggers call within 30 seconds\n- Dashboard 'Call Me Now' button initiates immediate call\n- Lead/property context selectable before manual call\n- Calendar integration with Google Calendar and FUB calendar\n- Appointment end detection triggers auto-call after configurable delay\n- Retry logic: up to 3 attempts with configurable intervals\n- SMS fallback sent after all call attempts fail\n- SMS confirmation sent after successful call with summary\n- ScheduledDebrief model tracks calendar auto-calls and retry state\n- Broker can configure: delay, retry attempts, retry intervals, SMS fallback","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:06:56.536206-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:56.536206-06:00","labels":["automation","calendar","sms","triggers"],"dependencies":[{"issue_id":"test-e5","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:46.977305-06:00","created_by":"David Habedank"},{"issue_id":"test-e5","depends_on_id":"test-e3","type":"blocks","created_at":"2026-01-30T12:09:47.16801-06:00","created_by":"David Habedank"},{"issue_id":"test-e5","depends_on_id":"test-e4","type":"blocks","created_at":"2026-01-30T12:09:47.353401-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1","title":"Implement SMS inbound webhook for DEBRIEF keyword","description":"Create Telnyx SMS webhook endpoint that receives inbound messages, detects DEBRIEF keyword (case-insensitive), looks up agent by phone number, and queues an immediate call trigger. Must respond within 30 seconds of receiving the SMS.\n\n**Context:** SMS keyword trigger is the lowest-friction way for agents to request a debrief - they just text DEBRIEF from their phone mid-drive. This enables the 'hands-free' experience that makes RealHerd feel magical after showings.","design":"Use Convex HTTP action for webhook. Store incoming SMS in messages table for audit. Queue call via internal action to avoid webhook timeout. Validate sender phone against registered agents. Return appropriate SMS response for unknown numbers.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:05.268033-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:05.268033-06:00","labels":["backend","sms","telnyx","webhook"],"dependencies":[{"issue_id":"test-e5t1","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:05.430092-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s1","title":"Create SMS messages table schema for audit logging","description":"Add a messages table to Convex schema for storing all inbound SMS messages. Fields: id, from_phone (string, indexed), to_phone (string), body (string), received_at (number timestamp), processed (boolean), agent_id (optional Id\u003cagents\u003e), keyword_detected (optional string), created_at (number). This provides audit trail and debugging capability for all SMS interactions.\n\n**Context:** Audit logging is essential for debugging delivery issues, tracking agent engagement patterns, and maintaining compliance records. Storing before processing ensures no messages are lost even if downstream processing fails.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:08:07.97974-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:07.97974-06:00","labels":["backend","convex","database","real-time"],"dependencies":[{"issue_id":"test-e5t1s1","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:08:08.170062-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s2","title":"Implement Telnyx SMS webhook HTTP action","description":"Create Convex HTTP action at /api/webhooks/telnyx/sms that handles POST requests from Telnyx. Parse webhook payload to extract sender phone (from), recipient phone (to), and message body. Validate Telnyx webhook signature using TELNYX_WEBHOOK_SECRET environment variable. Store raw message in messages table immediately. Return 200 OK quickly to prevent timeout. Handle payload validation errors with appropriate 4xx responses.\n\n**Context:** Telnyx requires webhook response within 30 seconds or will retry. By storing the message first and processing asynchronously, we guarantee reliable message capture regardless of downstream processing time.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:08.349714-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:08.349714-06:00","labels":["api","backend","filtering","frontend","react","security"],"dependencies":[{"issue_id":"test-e5t1s2","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:08:08.509395-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s2","depends_on_id":"test-e5t1s1","type":"blocks","created_at":"2026-01-30T12:09:47.561119-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s3","title":"Implement DEBRIEF keyword detection and call queuing logic","description":"Create internal action processInboundSms that: 1) Normalizes message body (trim, uppercase) and checks for DEBRIEF keyword match (case-insensitive, handles 'DEBRIEF', 'debrief', ' debrief ', etc.). 2) Looks up agent by from_phone in agents table (normalize phone format with/without +1). 3) If agent found and DEBRIEF detected, queue immediate call via scheduleCallForAgent internal mutation. 4) Update messages record with agent_id and keyword_detected. 5) Queue SMS response via separate action. Handle unknown phone numbers by logging and sending informational response.\n\n**Context:** The keyword detection must be forgiving (whitespace, case) since agents are texting quickly, often while driving. Phone number normalization is critical since Telnyx may send different formats than what's stored in the agents table.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:08.71653-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:08.71653-06:00","labels":["api","backend","business-logic","frontend","performance","react","ui"],"dependencies":[{"issue_id":"test-e5t1s3","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:08:08.887082-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s3","depends_on_id":"test-e5t1s2","type":"blocks","created_at":"2026-01-30T12:09:47.7553-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s4","title":"Add SMS response sending for confirmation and error cases","description":"Create sendSmsResponse action that sends Telnyx SMS via their API. Implement response messages: 1) Success: 'Got it! Calling you now for your debrief.' 2) Unknown number: 'This number isn't registered with RealHerd. Contact your broker to get set up.' 3) No keyword match: No response (avoid spamming for random texts). Use TELNYX_API_KEY and TELNYX_PHONE_NUMBER environment variables. Include retry logic with exponential backoff for transient failures.\n\n**Context:** Immediate confirmation via SMS gives agents confidence their request was received, especially important since they may be driving and can't check an app. The 'calling you now' message sets expectations for the incoming call.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:09.07803-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:09.07803-06:00","labels":["backend","integration","performance","security","testing"],"dependencies":[{"issue_id":"test-e5t1s4","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:08:09.254857-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s4","depends_on_id":"test-e5t1s3","type":"blocks","created_at":"2026-01-30T12:09:48.363394-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t1s5","title":"Wire webhook handler to async processing and verify end-to-end flow","description":"Update the HTTP webhook handler to schedule processInboundSms as a background action immediately after storing the message. Add environment variables to Convex dashboard: TELNYX_WEBHOOK_SECRET, TELNYX_API_KEY, TELNYX_PHONE_NUMBER. Test full flow: 1) Send test SMS to Telnyx number, 2) Verify message stored in database, 3) Verify call queued for registered agent, 4) Verify confirmation SMS sent back. Document webhook URL for Telnyx portal configuration.\n\n**Context:** End-to-end verification ensures all pieces work together. The async handoff is critical for meeting Telnyx's 30-second timeout while still doing meaningful work like agent lookup and call queuing.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:09.433911-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:09.433911-06:00","labels":["backend","integration","testing"],"dependencies":[{"issue_id":"test-e5t1s5","depends_on_id":"test-e5t1","type":"parent-child","created_at":"2026-01-30T12:08:09.672099-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t1s5","depends_on_id":"test-e5t1s4","type":"blocks","created_at":"2026-01-30T12:09:48.630812-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2","title":"Build Dashboard 'Call Me Now' button with context selection","description":"Add prominent call trigger button to agent dashboard that initiates immediate debrief call. Include optional lead/property selector so agents can pre-load context for the AI before the call starts.\n\n**Context:** Dashboard trigger is for agents at their desk who want a quick debrief. The context selector is a power feature - if they select a lead/property, the AI can reference it during the call ('I see you just showed 123 Main St...').","design":"Button component with loading state and cooldown (prevent double-clicks). Lead selector uses existing leads data. Property selector may use FUB property data or manual entry. Call trigger uses same internal action as SMS pathway. Show call status feedback (queued  dialing  connected).","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:05.69453-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:05.69453-06:00","labels":["dashboard","frontend","ui"],"dependencies":[{"issue_id":"test-e5t2","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:05.961095-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2","depends_on_id":"test-e5t1","type":"blocks","created_at":"2026-01-30T12:09:48.81398-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s1","title":"Create CallMeNowButton component with loading and cooldown states","description":"Build a prominent 'Call Me Now' button component for the agent dashboard. Implement loading state (spinner/disabled while request processes), cooldown state (prevent double-clicks with 30-second cooldown timer showing countdown), and success/error feedback states. Use existing button patterns from the UI library. Button should be visually prominent (primary color, larger size) to stand out on dashboard.\n\n**Context:** This is the primary trigger point for immediate debrief calls. The cooldown prevents accidental duplicate calls which would waste Twilio credits and confuse agents. Visual prominence ensures agents can find it quickly when they want a debrief.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:09.858111-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:09.858111-06:00","labels":["component","forms","frontend","ui"],"dependencies":[{"issue_id":"test-e5t2s1","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:08:09.978532-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s2","title":"Build context selector for lead and property pre-loading","description":"Create a collapsible context selector panel that appears near the Call Me Now button. Include a lead dropdown/search using existing leads data from the dashboard state or API. Add a property field that can either select from FUB property data (if available) or allow manual address entry. Both fields are optional - agents can call without context. Store selected context in component state for passing to call trigger.\n\n**Context:** The context selector is a power feature that makes calls more valuable. When an agent selects '123 Main St' before calling, the AI can open with 'I see you just showed 123 Main St to the Johnsons...' which feels personalized and saves explanation time.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:10.177816-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:10.177816-06:00","labels":["component","drag-drop","frontend","settings","ui"],"dependencies":[{"issue_id":"test-e5t2s2","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:08:10.304317-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2s2","depends_on_id":"test-e5t2s1","type":"blocks","created_at":"2026-01-30T12:09:49.015945-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s3","title":"Implement call trigger action with status feedback","description":"Wire the Call Me Now button to trigger calls using the same internal action/API as the SMS pathway (reuse existing call initiation logic). Pass selected lead/property context as metadata in the call request. Implement real-time status feedback showing call progression: 'Queued'  'Dialing'  'Connected' (or error states). Use polling or websocket subscription to track call status. Display status in a toast or inline status indicator near the button.\n\n**Context:** Reusing the SMS pathway's call trigger ensures consistency and reduces code duplication. Status feedback is critical UX - agents need to know if the call is actually happening, especially since there's a delay between clicking and the phone ringing.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:10.491148-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:10.491148-06:00","labels":["analytics","api-integration","auth","frontend","permissions"],"dependencies":[{"issue_id":"test-e5t2s3","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:08:10.636303-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2s3","depends_on_id":"test-e5t2s2","type":"blocks","created_at":"2026-01-30T12:09:49.298516-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t2s4","title":"Integrate Call Me Now feature into agent dashboard and verify","description":"Add the CallMeNowButton with context selector to the agent dashboard in a prominent position (likely top-right or in a dedicated 'Quick Actions' section). Ensure responsive layout works on desktop and tablet. Run dev server and manually test the complete flow: open dashboard, optionally select lead/property context, click Call Me Now, observe status progression. Verify cooldown prevents rapid re-clicks.\n\n**Context:** Dashboard integration is the final step that makes this feature accessible to agents. Positioning matters - it needs to be visible but not intrusive to the main dashboard content.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:11.328106-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:11.328106-06:00","labels":["api","backend","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e5t2s4","depends_on_id":"test-e5t2","type":"parent-child","created_at":"2026-01-30T12:08:11.568845-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t2s4","depends_on_id":"test-e5t2s3","type":"blocks","created_at":"2026-01-30T12:09:49.781168-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3","title":"Create ScheduledDebrief model and calendar integration","description":"Build ScheduledDebrief Convex table to track calendar-triggered auto-calls. Integrate with Google Calendar and Follow Up Boss calendar to detect appointment end times. Implement configurable delay before auto-call (default 5 minutes after appointment ends).\n\n**Context:** Calendar auto-call is the flagship 'set it and forget it' feature. Agents block time for showings, and RealHerd automatically calls them after - no action required. This transforms RealHerd from a tool they use into a proactive AI manager.","design":"ScheduledDebrief stores: agentId, appointmentId, scheduledTime, status (pending/attempted/completed/failed), attemptCount, lastAttemptAt, appointmentContext. Use Convex cron to poll calendars every minute. OAuth for Google Calendar. FUB calendar via API polling. Broker configures delay per team (5-30 minutes typical).","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:07:06.350984-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:06.350984-06:00","labels":["backend","calendar","convex","fub-api","google-api"],"dependencies":[{"issue_id":"test-e5t3","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:06.47715-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3","depends_on_id":"test-e5t1","type":"blocks","created_at":"2026-01-30T12:09:50.063166-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s1","title":"Create ScheduledDebrief Convex schema and basic CRUD","description":"Define ScheduledDebrief table in Convex schema with fields: agentId (Id\u003c'agents'\u003e), appointmentId (string, external calendar ID), scheduledTime (number, unix timestamp), status (literal union: 'pending'|'attempted'|'completed'|'failed'), attemptCount (number, default 0), lastAttemptAt (optional number), appointmentContext (object with title, location, attendees, etc.), delayMinutes (number, default 5), calendarSource ('google'|'fub'). Add indexes on agentId, status, and scheduledTime. Implement mutations: createScheduledDebrief, updateScheduledDebriefStatus, markAttempted. Implement queries: getByAgent, getPendingDebriefs, getDebriefsByTimeRange.\n\n**Context:** The ScheduledDebrief model is the core data structure that enables the 'set it and forget it' auto-call feature. Clean schema design here enables reliable polling and retry logic later.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:11.759199-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:11.759199-06:00","labels":["api","backend","database","security"],"dependencies":[{"issue_id":"test-e5t3s1","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:08:12.01742-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s2","title":"Implement Google Calendar OAuth and appointment fetching","description":"Set up Google Calendar API OAuth2 flow for agent authorization. Store refresh tokens securely in Convex (add googleCalendarRefreshToken to agents table). Create a Convex action that uses Google Calendar API to fetch appointments ending in the next hour. Parse appointment data into normalized format: { id, title, startTime, endTime, location, attendees }. Handle OAuth token refresh automatically. Create query to check if agent has Google Calendar connected.\n\n**Context:** Google Calendar is the primary calendar for most agents. OAuth ensures secure access while letting agents 'connect once and forget' - critical for the frictionless experience.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:12.204603-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:12.204603-06:00","labels":["analytics","auth","backend","frontend","integration","oauth"],"dependencies":[{"issue_id":"test-e5t3s2","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:08:12.399775-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s2","depends_on_id":"test-e5t3s1","type":"blocks","created_at":"2026-01-30T12:09:50.289112-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s3","title":"Implement Follow Up Boss calendar API integration","description":"Create Convex action to poll Follow Up Boss calendar API for agent appointments. Use existing FUB API credentials from agent/team settings. Fetch appointments ending in the next hour. Normalize FUB appointment format to match Google Calendar format: { id, title, startTime, endTime, location, attendees }. Implement deduplication logic to handle appointments that exist in both Google and FUB calendars (prefer FUB data when duplicated, match by time overlap + similar title).\n\n**Context:** FUB is the source of truth for many teams' showing appointments. Supporting both calendars ensures we catch all appointments regardless of where agents book them.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:12.580224-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:12.580224-06:00","labels":["backend","components","frontend","integration","permissions","ux"],"dependencies":[{"issue_id":"test-e5t3s3","depends_on_id":"test-e5t3s2","type":"blocks","created_at":"2026-01-30T11:11:04.638144-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s3","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:08:12.714742-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s3","depends_on_id":"test-e5t3s1","type":"blocks","created_at":"2026-01-30T12:09:50.4917-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t3s4","title":"Implement Convex cron job for calendar polling and debrief scheduling","description":"Create Convex cron job that runs every minute. For each agent with calendar integration enabled: fetch appointments ending in the next 5-35 minutes (accounting for configurable delay). For each ending appointment, check if ScheduledDebrief already exists (by appointmentId). If not, create ScheduledDebrief with scheduledTime = appointmentEndTime + agent's configured delay. Add broker/team setting for default delay (5-30 minutes, default 5). Create a settings table entry or add to team table: autoCallDelayMinutes. Log all scheduling activity for debugging.\n\n**Context:** The cron job is the heart of the 'set it and forget it' system. Running every minute ensures we catch appointments as they end without overwhelming the calendar APIs. Configurable delay lets brokers tune the experience for their team's workflow.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:12.948777-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:12.948777-06:00","labels":["backend","cron","frontend","integration","testing","ux"],"dependencies":[{"issue_id":"test-e5t3s4","depends_on_id":"test-e5t3","type":"parent-child","created_at":"2026-01-30T12:08:13.071363-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s4","depends_on_id":"test-e5t3s2","type":"blocks","created_at":"2026-01-30T12:09:50.709258-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t3s4","depends_on_id":"test-e5t3s3","type":"blocks","created_at":"2026-01-30T12:09:51.006172-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4","title":"Implement retry logic and SMS fallback for missed calls","description":"Build retry system for unanswered calls: configurable attempts (default 3), configurable intervals (default 5/15/30 minutes). After all attempts exhausted, send SMS fallback prompting agent to text DEBRIEF when ready. Track all attempts in ScheduledDebrief.\n\n**Context:** Agents miss calls - they're driving, with clients, or just busy. Retry logic ensures debriefs happen without agent mental overhead. The SMS fallback closes the loop gracefully and re-engages them on their terms.","design":"Extend call status handling to detect no-answer/busy/voicemail. Update ScheduledDebrief with each attempt. Use Convex scheduled functions for retry timing. SMS fallback includes original appointment context. Broker configures: maxAttempts, retryIntervals[], enableSmsFallback. Consider exponential backoff as default interval pattern.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:06.663028-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:06.663028-06:00","labels":["backend","convex","retry","sms"],"dependencies":[{"issue_id":"test-e5t4","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:06.780433-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4","depends_on_id":"test-e5t3","type":"blocks","created_at":"2026-01-30T12:09:51.188026-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s1","title":"Extend call status detection and ScheduledDebrief tracking schema","description":"Update Twilio call status handler to detect and categorize no-answer, busy, voicemail, and failed call outcomes. Extend ScheduledDebrief schema to track: attemptNumber (current attempt count), attemptHistory (array of {timestamp, status, duration}), and nextRetryAt (scheduled time for next attempt). Add broker-configurable settings: maxAttempts (default 3), retryIntervals (default [5, 15, 30] minutes), enableSmsFallback (default true).\n\n**Context:** Accurate call outcome detection is the foundation - we need to know WHEN to retry. The attempt tracking in ScheduledDebrief provides audit trail and enables intelligent retry decisions. Broker configuration allows customization for different team cultures.\n\n**Testing Requirements:**\n- **Unit Tests:** Call status correctly categorized as retriable vs terminal; Attempt history properly appended on each call; Broker settings validated and defaults applied\n- **Integration Tests:** Twilio webhook updates ScheduledDebrief with correct status","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:13.312648-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:13.312648-06:00","labels":["api-integration","backend","database","schema"],"dependencies":[{"issue_id":"test-e5t4s1","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:08:13.473508-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s2","title":"Implement retry scheduling with configurable intervals","description":"Create scheduleRetryAttempt mutation that: checks if attempts \u003c maxAttempts, calculates next retry time from retryIntervals array (use last interval if attempts exceed array length for exponential-like behavior), schedules Convex function for next call attempt, updates ScheduledDebrief.nextRetryAt. Wire into call completion handler - when call fails with retriable status, automatically schedule next attempt.\n\n**Context:** The automatic retry removes mental overhead from agents - they don't need to remember to call back. Configurable intervals let brokers balance persistence with respect for agent time. The 5/15/30 minute default gives agents breathing room while ensuring timely follow-up.\n\n**Testing Requirements:**\n- **Unit Tests:** Correct interval selected based on attempt number; No retry scheduled when maxAttempts reached; nextRetryAt correctly calculated and stored\n- **Integration Tests:** End-to-end: missed call triggers scheduled retry at correct time","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:13.686221-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:13.686221-06:00","labels":["admin-interface","backend","frontend","react","scheduling"],"dependencies":[{"issue_id":"test-e5t4s2","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:08:13.803882-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s2","depends_on_id":"test-e5t4s1","type":"blocks","created_at":"2026-01-30T12:09:51.367696-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s3","title":"Build SMS fallback system for exhausted retries","description":"Create sendSmsFallback function triggered when all retry attempts exhausted and enableSmsFallback is true. SMS content includes: original appointment context (client name, property, time), instruction to text 'DEBRIEF' when ready to receive call. Use Twilio SMS API. Update ScheduledDebrief status to 'awaiting_sms_response' and store smsSentAt timestamp. Handle SMS delivery confirmation.\n\n**Context:** SMS fallback closes the loop gracefully - agents can engage on their terms rather than feeling hounded. Including appointment context refreshes their memory. The 'DEBRIEF' keyword creates a simple re-engagement path that works while driving (voice-to-text).\n\n**Testing Requirements:**\n- **Unit Tests:** SMS content correctly formatted with appointment details; SMS only sent when enableSmsFallback is true; ScheduledDebrief status updated after SMS sent\n- **Integration Tests:** Full flow: 3 failed calls  SMS sent with correct content","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:13.977668-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:13.977668-06:00","labels":["backend","dashboard","forms","frontend","notifications","sms","twilio"],"dependencies":[{"issue_id":"test-e5t4s3","depends_on_id":"test-e5t4s2","type":"blocks","created_at":"2026-01-30T11:11:05.887301-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s3","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:08:14.089723-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s3","depends_on_id":"test-e5t4s1","type":"blocks","created_at":"2026-01-30T12:09:51.554314-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t4s4","title":"Wire complete retry flow and verify end-to-end behavior","description":"Connect all components: call completion  retry decision  schedule or SMS fallback. Add logging for observability of retry flow. Create admin visibility into retry status (attempts made, next scheduled, SMS sent). Test complete scenarios: successful call on retry #2, all retries exhausted with SMS, broker with SMS disabled. Verify Convex scheduled functions execute at correct times.\n\n**Context:** The complete flow must work seamlessly - this is the 'set and forget' experience that makes RealHerd valuable. Admin visibility helps brokers understand engagement patterns and tune their settings.\n\n**Testing Requirements:**\n- **Unit Tests:** Retry flow state machine transitions correctly\n- **Integration Tests:** Scenario: Call answered on 2nd attempt - no further retries; Scenario: 3 missed calls  SMS sent  agent texts DEBRIEF; Scenario: SMS disabled - no SMS after exhausted retries","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:14.279198-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:14.279198-06:00","labels":["backend","deployment","frontend","integration","monitoring","real-time","routing","testing"],"dependencies":[{"issue_id":"test-e5t4s4","depends_on_id":"test-e5t4","type":"parent-child","created_at":"2026-01-30T12:08:14.443196-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s4","depends_on_id":"test-e5t4s2","type":"blocks","created_at":"2026-01-30T12:09:51.739527-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t4s4","depends_on_id":"test-e5t4s3","type":"blocks","created_at":"2026-01-30T12:09:51.905932-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5","title":"Build SMS confirmation with call summary after successful calls","description":"After a debrief call completes successfully, send SMS to agent with brief summary: leads mentioned, actions captured, and link to full debrief in dashboard. Must handle both manual triggers and auto-calls.\n\n**Context:** Post-call SMS confirmation gives agents immediate proof their debrief was captured. It's both a receipt and a nudge to review/approve in the dashboard. Reinforces the value of each call.","design":"Hook into call completion event. Generate summary from extracted debrief data (lead names, property addresses, action count). Keep SMS under 160 chars when possible, multi-part if needed. Include short link to debrief detail page. Use agent's registered phone number.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:06.914805-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:06.914805-06:00","labels":["backend","sms","telnyx"],"dependencies":[{"issue_id":"test-e5t5","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:07.015842-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5","depends_on_id":"test-e5t1","type":"blocks","created_at":"2026-01-30T12:09:52.374731-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5","depends_on_id":"test-e5t4","type":"blocks","created_at":"2026-01-30T12:09:52.856862-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s1","title":"Create SMS summary generator from debrief data","description":"Build a function that takes extracted debrief data (leads, actions, property addresses) and generates a concise SMS summary. Should prioritize: (1) lead count and names (truncated if needed), (2) action count, (3) short link placeholder. Target under 160 chars for single SMS, gracefully handle multi-part when content exceeds. Include TypeScript types for input debrief data and output SMS content.\n\n**Context:** The summary is the agent's immediate receipt proving their debrief was captured. It needs to be scannable at a glance while driving between showings. Quality of this summary directly impacts perceived value of the product.\n\n**Testing Requirements:**\n- **Unit Tests:** Generates valid SMS under 160 chars for minimal debrief (1 lead, 1 action); Handles truncation gracefully for 5+ leads; Includes all required elements: lead info, action count, link; Returns multi-part structure when content exceeds single SMS","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:14.669214-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:14.669214-06:00","labels":["backend","dependencies","sms","types"],"dependencies":[{"issue_id":"test-e5t5s1","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:08:15.00379-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s2","title":"Implement short link generation for debrief detail page","description":"Create a URL shortening utility that generates trackable short links to the debrief detail page in the dashboard. Links should include the debrief ID and be URL-safe. Consider using a simple base62 encoding of the debrief ID or integrate with existing short link service if available. Links must work for both manual and auto-call debriefs.\n\n**Context:** SMS character limits make full URLs impractical. Short links also enable click tracking to measure engagement with the dashboard. This is the bridge from passive SMS receipt to active dashboard engagement.\n\n**Testing Requirements:**\n- **Unit Tests:** Generates valid short URL for given debrief ID; Short URL resolves to correct dashboard detail page; Handles edge cases: very long IDs, special characters","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:15.294491-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:15.294491-06:00","labels":["backend","dashboard","frontend","security","ui"],"dependencies":[{"issue_id":"test-e5t5s2","depends_on_id":"test-e5t5s1","type":"blocks","created_at":"2026-01-30T11:11:06.816879-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s2","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:08:15.478852-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s3","title":"Hook SMS confirmation into call completion event","description":"Subscribe to the call completion event (from Task 5.1's call orchestration). On successful call completion: (1) retrieve the agent's registered phone number, (2) fetch extracted debrief data, (3) generate summary using 5.5.1, (4) generate short link using 5.5.2, (5) send SMS via existing SMS service. Must handle both manual trigger calls and auto-scheduled calls identically. Add appropriate error handling and logging.\n\n**Context:** This is the integration point that ties the SMS feature to the existing call flow. The confirmation must work seamlessly whether the agent manually triggered the call or it was auto-scheduled from their calendar. Reliability here builds trust in the system.\n\n**Testing Requirements:**\n- **Unit Tests:** Triggers SMS on successful call completion event; Correctly retrieves agent phone number from registration; Does not send SMS on failed/incomplete calls; Handles missing phone number gracefully (log warning, no crash)","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:15.755087-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:15.755087-06:00","labels":["backend","export","frontend","integration","routing","sms"],"dependencies":[{"issue_id":"test-e5t5s3","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:08:15.93207-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s3","depends_on_id":"test-e5t5s1","type":"blocks","created_at":"2026-01-30T12:09:53.050465-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s3","depends_on_id":"test-e5t5s2","type":"blocks","created_at":"2026-01-30T12:09:53.227136-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t5s4","title":"End-to-end verification of SMS confirmation flow","description":"Verify the complete SMS confirmation flow works for both call trigger types. Test scenarios: (1) Manual call trigger  successful completion  SMS received with correct summary and working link, (2) Auto-scheduled call  successful completion  SMS received. Verify SMS content matches expected format, link navigates to correct debrief, and timing is acceptable (SMS within 30 seconds of call end).\n\n**Context:** This final verification ensures the feature delivers on its promise: immediate proof that the debrief was captured. Any failure here breaks the trust loop that makes RealHerd feel like a proactive manager.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:16.120825-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:16.120825-06:00","labels":["backend","e2e","frontend","pdf","testing"],"dependencies":[{"issue_id":"test-e5t5s4","depends_on_id":"test-e5t5","type":"parent-child","created_at":"2026-01-30T12:08:16.368042-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t5s4","depends_on_id":"test-e5t5s3","type":"blocks","created_at":"2026-01-30T12:09:53.463051-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t6","title":"Create broker configuration UI for call triggering settings","description":"Build admin settings page for brokers to configure: auto-call delay after appointments, retry attempts count, retry intervals, SMS fallback toggle, and team-level overrides. Include sensible defaults.\n\n**Context:** Every brokerage has different rhythms. Some want calls 5 minutes after showings, others prefer 30. Broker configuration ensures RealHerd fits their workflow instead of imposing one.","design":"Settings page under broker admin section. Form with: delayMinutes (5-60), maxRetryAttempts (1-5), retryIntervals (array editor), enableSmsFallback (toggle). Store in brokerage settings. Support team-level overrides. Show preview of retry timeline based on settings.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:07.174848-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:07.174848-06:00","labels":["admin","frontend","settings","ui"],"dependencies":[{"issue_id":"test-e5t6","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:07.362237-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6","depends_on_id":"test-e5t3","type":"blocks","created_at":"2026-01-30T12:09:53.699155-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6","depends_on_id":"test-e5t4","type":"blocks","created_at":"2026-01-30T12:09:53.903954-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t6s1","title":"Create call configuration TypeScript types and schema","description":"Define TypeScript interfaces for broker call configuration: CallTriggerSettings with delayMinutes (5-60), maxRetryAttempts (1-5), retryIntervals (number[]), enableSmsFallback (boolean). Create Zod validation schema for form validation. Define TeamOverride type that extends base settings with teamId. Add these to the brokerage settings model/schema.\n\n**Context:** Type-safe configuration ensures brokers can only set valid values. The retry intervals array needs special attention - it defines wait times between each retry attempt and must match maxRetryAttempts length.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:16.823019-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:16.823019-06:00","labels":["backend","testing","types"],"dependencies":[{"issue_id":"test-e5t6s1","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:17.584003-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t6s2","title":"Build call settings form component with defaults","description":"Create CallSettingsForm component with: (1) delayMinutes number input with slider 5-60, default 15, (2) maxRetryAttempts dropdown 1-5, default 3, (3) retryIntervals dynamic array editor that adds/removes fields based on maxRetryAttempts, defaults [5,15,30] minutes, (4) enableSmsFallback toggle, default true. Use react-hook-form with Zod resolver. Include helpful labels explaining each setting's purpose.\n\n**Context:** Sensible defaults (15min delay, 3 retries at 5/15/30min, SMS fallback on) mean most brokers can use RealHerd without configuration. Power users can customize to match their brokerage rhythm.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:17.998702-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:17.998702-06:00","labels":["forms","frontend","testing"],"dependencies":[{"issue_id":"test-e5t6s2","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:18.174363-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6s2","depends_on_id":"test-e5t6s1","type":"blocks","created_at":"2026-01-30T12:09:54.102262-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t6s3","title":"Add retry timeline preview visualization","description":"Create RetryTimelinePreview component that visualizes the call sequence based on current form values. Show: initial call at T+delayMinutes, each retry at calculated intervals, SMS fallback indicator if enabled. Use a horizontal timeline with icons (phone for calls, message for SMS). Update in real-time as user changes form values. Include example: 'After a showing at 2pm: First call at 2:15pm, retry at 2:20pm, retry at 2:35pm, SMS at 3:05pm'.\n\n**Context:** Brokers think in terms of 'when will my agent get called after a showing' - the preview translates abstract settings into a concrete example they can understand and validate against their workflow.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:18.419142-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:18.419142-06:00","labels":["frontend","ux","visualization"],"dependencies":[{"issue_id":"test-e5t6s3","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:18.57454-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6s3","depends_on_id":"test-e5t6s2","type":"blocks","created_at":"2026-01-30T12:09:54.341838-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t6s4","title":"Implement settings page with team overrides and save functionality","description":"Create BrokerCallSettingsPage under /admin/settings/calls route. Include: (1) brokerage-wide default settings form, (2) team overrides section - list teams with 'Use custom settings' toggle, showing inherited values or override form, (3) Save button that persists to brokerage settings via API. Load existing settings on mount, show loading state. Display success/error toasts on save. Verify page renders correctly and settings persist across page refresh.\n\n**Context:** Team-level overrides let broker give autonomy to team leads - a luxury team might want longer delays while a high-volume team wants immediate calls. This flexibility without complexity is key to enterprise adoption.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:18.832686-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:18.832686-06:00","labels":["api","frontend","integration","testing"],"dependencies":[{"issue_id":"test-e5t6s4","depends_on_id":"test-e5t6","type":"parent-child","created_at":"2026-01-30T12:08:20.298357-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t6s4","depends_on_id":"test-e5t6s3","type":"blocks","created_at":"2026-01-30T12:09:54.530969-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t7","title":"Verify end-to-end call triggering flows","description":"Integration testing of all three trigger pathways (SMS keyword, dashboard button, calendar auto-call) through complete lifecycle including retries, SMS confirmations, and debrief creation. Verify broker settings are respected across all flows.\n\n**Context:** Call triggering is the entry point to RealHerd's core value. All three pathways must work reliably or agents lose trust. This verification ensures the system works as a cohesive whole.","design":"Create test scenarios document covering: SMS trigger happy path, SMS from unknown number, dashboard trigger with/without context, calendar auto-call with successful pickup, calendar auto-call with retries exhausted, broker settings respected. Use Convex test helpers for time manipulation in retry tests.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:07.539437-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:07.539437-06:00","labels":["integration","qa","testing"],"dependencies":[{"issue_id":"test-e5t7","depends_on_id":"test-e5","type":"parent-child","created_at":"2026-01-30T12:07:07.682879-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7","depends_on_id":"test-e5t2","type":"blocks","created_at":"2026-01-30T12:09:54.701064-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7","depends_on_id":"test-e5t5","type":"blocks","created_at":"2026-01-30T12:09:54.920229-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7","depends_on_id":"test-e5t6","type":"blocks","created_at":"2026-01-30T12:09:55.123177-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t7s1","title":"Create integration test scaffolding and test scenarios document","description":"Set up integration test file structure for call trigger flows. Create a test scenarios document (as code comments or separate .md) covering all test cases: SMS trigger happy path, SMS from unknown number, dashboard trigger with/without context, calendar auto-call with successful pickup, calendar auto-call with retries exhausted, broker settings respected. Configure Convex test helpers for time manipulation.\n\n**Context:** A clear test plan ensures comprehensive coverage of all trigger pathways. The scaffolding enables consistent test patterns across different trigger types.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:20.778843-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:20.778843-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s1","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:21.082091-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t7s2","title":"Implement SMS trigger pathway integration tests","description":"Write integration tests for SMS keyword triggers: (1) Happy path - known agent sends keyword, call initiates, SMS confirmation sent. (2) Unknown number - SMS from non-registered number handled gracefully. (3) Verify broker settings (business hours, enabled keywords) are respected. Test complete lifecycle including debrief creation after call completion.\n\n**Context:** SMS is often the quickest trigger method for agents in the field. Must handle edge cases like unknown numbers without crashing or revealing system internals.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:21.576518-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:21.576518-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s2","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:21.922317-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s2","depends_on_id":"test-e5t7s1","type":"blocks","created_at":"2026-01-30T12:09:55.299857-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t7s3","title":"Implement dashboard and calendar trigger integration tests","description":"Write integration tests for: (1) Dashboard button trigger with context data passed to call. (2) Dashboard trigger without context. (3) Calendar auto-call with successful pickup - verify call initiates at scheduled time, debrief created. (4) Calendar auto-call with retries - use Convex time manipulation to test retry scheduling at 5min/15min/30min intervals and behavior when retries exhausted.\n\n**Context:** Calendar auto-call with retry is the 'set it and forget it' experience that differentiates RealHerd. Time manipulation tests are critical to verify retry logic without waiting real minutes.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:22.223401-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:22.223401-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s3","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:22.355661-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s3","depends_on_id":"test-e5t7s1","type":"blocks","created_at":"2026-01-30T12:09:55.517635-06:00","created_by":"David Habedank"}]}
{"id":"test-e5t7s4","title":"Run full test suite and verify cross-pathway broker settings","description":"Execute all integration tests and verify: (1) All tests pass. (2) Broker-level settings (business hours, call limits, enabled features) are consistently enforced across SMS, dashboard, and calendar triggers. (3) Document any edge cases discovered. Fix any failing tests or implementation bugs found during verification.\n\n**Context:** Broker settings must work identically regardless of how a call is triggered. This final verification ensures the system works as a cohesive whole and agents can trust any trigger method.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:24.822002-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:24.822002-06:00","labels":["backend","testing"],"dependencies":[{"issue_id":"test-e5t7s4","depends_on_id":"test-e5t7","type":"parent-child","created_at":"2026-01-30T12:08:25.192567-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s4","depends_on_id":"test-e5t7s2","type":"blocks","created_at":"2026-01-30T12:09:55.711912-06:00","created_by":"David Habedank"},{"issue_id":"test-e5t7s4","depends_on_id":"test-e5t7s3","type":"blocks","created_at":"2026-01-30T12:09:55.997619-06:00","created_by":"David Habedank"}]}
{"id":"test-e6","title":"Database Check-In Calls","description":"Build the proactive check-in system that calls agents on a schedule to review leads needing attention. Implement lead selection algorithm, check-in conversation flow, and multi-lead updates.\n\n**Context:** Check-ins are the accountability mechanism - the 'virtual sales manager' that ensures no lead falls through cracks. This differentiates RealHerd from simple transcription tools.","acceptance_criteria":"- Check-in scheduling system with configurable frequency (e.g., every 3 days)\n- Lead selection algorithm prioritizes: days since contact, temperature, timeline proximity, stage staleness\n- Check-in conversation flow reviews 3-5 leads per call\n- Multi-lead updates tracked in single call\n- LeadUpdate model captures per-lead changes\n- Check-in configuration: frequency, lead count, preferred times, timezone\n- Check-in compliance tracking (did agent take the call?)\n- ScheduledCheckIn model for pending/completed/missed check-ins\n- Check-in conversation script implemented per PRD","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:06:56.745578-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:56.745578-06:00","labels":["accountability","check-ins","scheduling"],"dependencies":[{"issue_id":"test-e6","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:09:56.181038-06:00","created_by":"David Habedank"},{"issue_id":"test-e6","depends_on_id":"test-e3","type":"blocks","created_at":"2026-01-30T12:09:56.378968-06:00","created_by":"David Habedank"},{"issue_id":"test-e6","depends_on_id":"test-e4","type":"blocks","created_at":"2026-01-30T12:09:56.5687-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1","title":"Create ScheduledCheckIn and CheckInConfiguration models","description":"Define Convex schema for scheduled check-ins (pending/completed/missed status, scheduled time, agent assignment) and check-in configuration (frequency, lead count, preferred times, timezone). Include compliance tracking fields.\n\n**Context:** Check-ins are the accountability mechanism - the 'virtual sales manager' that ensures no lead falls through cracks. The data model must support scheduling, tracking compliance, and storing per-call results.","design":"ScheduledCheckIn: id, agentId, scheduledAt, status (pending/completed/missed), completedAt, leadsReviewed[], callId. CheckInConfiguration: agentId, frequencyDays, leadCount (3-5), preferredTimes[], timezone, enabled. Use Convex's native datetime handling.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":180,"created_at":"2026-01-30T12:07:07.830441-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:07.830441-06:00","labels":["backend","convex","database"],"dependencies":[{"issue_id":"test-e6t1","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:07.93511-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s1","title":"Define ScheduledCheckIn schema in Convex","description":"Create the ScheduledCheckIn table in Convex schema with fields: id (auto), agentId (Id\u003c'agents'\u003e), scheduledAt (number - timestamp), status (v.union of 'pending'|'completed'|'missed'), completedAt (optional number), leadsReviewed (v.array of Id\u003c'leads'\u003e), callId (optional Id\u003c'calls'\u003e). Add appropriate indexes for querying by agentId and status, and by scheduledAt for cron job lookups.\n\n**Context:** This is the core table that tracks each individual check-in instance. The status field enables compliance tracking, while leadsReviewed links check-ins to the leads discussed during each call.\n\n**Testing Requirements:**\n- **Unit Tests:** \n- **Integration Tests:** ","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:08:25.645453-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:25.645453-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e6t1s1","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:08:25.965679-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s2","title":"Define CheckInConfiguration schema in Convex","description":"Create the CheckInConfiguration table with fields: agentId (Id\u003c'agents'\u003e, unique index), frequencyDays (v.number - how often to check in), leadCount (v.number with validation comment for 3-5 range), preferredTimes (v.array of v.object with hour/minute for preferred call times), timezone (v.string - IANA timezone like 'America/New_York'), enabled (v.boolean). Add index on agentId for fast lookups.\n\n**Context:** Configuration controls when and how check-ins are scheduled for each agent. The preferredTimes array allows flexibility for agents with varying schedules. Timezone ensures calls are scheduled in the agent's local time.\n\n**Testing Requirements:**\n- **Unit Tests:** \n- **Integration Tests:** ","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:08:26.165138-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:26.165138-06:00","labels":["api","backend"],"dependencies":[{"issue_id":"test-e6t1s2","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:08:26.459007-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s2","depends_on_id":"test-e6t1s1","type":"blocks","created_at":"2026-01-30T12:09:56.756574-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s3","title":"Add TypeScript types and validators for check-in models","description":"Create src/lib/types/checkIn.ts with TypeScript interfaces matching the Convex schema: ScheduledCheckInDoc, CheckInConfigurationDoc, CheckInStatus type union. Add Zod validators for any client-side validation needs (e.g., validating leadCount is 3-5, timezone is valid IANA string). Export Doc types from Convex generated types.\n\n**Context:** Strong typing ensures type safety across the codebase when working with check-in data. Zod validators provide runtime validation for user inputs when creating/updating configurations.\n\n**Testing Requirements:**\n- **Unit Tests:** \n- **Integration Tests:** ","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:26.819313-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:26.819313-06:00","labels":["analytics","api","backend"],"dependencies":[{"issue_id":"test-e6t1s3","depends_on_id":"test-e6t1s1","type":"blocks","created_at":"2026-01-30T11:11:08.759193-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s3","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:08:27.029139-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s3","depends_on_id":"test-e6t1s2","type":"blocks","created_at":"2026-01-30T12:09:56.967796-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t1s4","title":"Verify schema integration and run Convex sync","description":"Run npx convex dev to sync schema changes. Verify both tables appear in Convex dashboard with correct indexes. Test that the schema integrates properly with existing agents table (foreign key relationships work). Document the schema in a brief comment block explaining the compliance tracking flow: configuration -\u003e scheduled check-ins -\u003e completion/miss tracking.\n\n**Context:** Final verification ensures the models are production-ready and properly integrated with the existing database. Documentation helps future developers understand the check-in flow.\n\n**Testing Requirements:**\n- **Unit Tests:** \n- **Integration Tests:** ","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":20,"created_at":"2026-01-30T12:08:27.371837-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:27.371837-06:00","labels":["alerts","api","backend","database"],"dependencies":[{"issue_id":"test-e6t1s4","depends_on_id":"test-e6t1s2","type":"blocks","created_at":"2026-01-30T11:11:08.97757-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s4","depends_on_id":"test-e6t1","type":"parent-child","created_at":"2026-01-30T12:08:27.599599-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t1s4","depends_on_id":"test-e6t1s3","type":"blocks","created_at":"2026-01-30T12:09:57.388783-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2","title":"Implement lead selection algorithm for check-ins","description":"Build the algorithm that selects which leads to review during check-in calls. Prioritize by: days since last contact, lead temperature, timeline proximity to purchase/move date, and stage staleness.\n\n**Context:** Not all leads are equal - the algorithm ensures agents focus on leads most at risk of falling through cracks. This intelligent prioritization is what makes RealHerd valuable vs manual CRM review.","design":"Convex query function that scores leads based on weighted factors. Return top N leads (configurable 3-5). Consider: daysSinceContact * 0.3 + temperatureScore * 0.25 + timelineUrgency * 0.25 + stageStaleness * 0.2. Exclude recently contacted leads (\u003c 24h).","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:08.110699-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:08.110699-06:00","labels":["algorithm","backend","convex"],"dependencies":[{"issue_id":"test-e6t2","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:08.25976-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2","depends_on_id":"test-e6t1","type":"blocks","created_at":"2026-01-30T12:09:57.575381-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s1","title":"Create TypeScript types and scoring constants for lead selection","description":"Define TypeScript interfaces for lead scoring: LeadScore (leadId, totalScore, breakdown), ScoringWeights (daysSinceContact, temperature, timelineUrgency, stageStaleness), and SelectionConfig (topN, minHoursSinceContact). Create constants file with default weights (0.3, 0.25, 0.25, 0.2) and default config (topN: 5, minHoursSinceContact: 24).\n\n**Context:** Clean type definitions ensure the scoring algorithm is maintainable and the weights are configurable for future tuning based on agent feedback.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:08:27.923024-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:27.923024-06:00","labels":["backend","frontend","layout","types"],"dependencies":[{"issue_id":"test-e6t2s1","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:08:28.112449-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s2","title":"Implement individual scoring functions for each factor","description":"Create pure helper functions: calculateDaysSinceContactScore(lastContactedAt: number): number (0-1, higher = more days), calculateTemperatureScore(temperature: 'cold'|'warm'|'hot'): number (cold=0.3, warm=0.6, hot=1.0), calculateTimelineUrgencyScore(targetDate: number | null): number (0-1, higher = closer to date), calculateStalenessScore(stageUpdatedAt: number, stage: string): number (0-1, based on expected time in stage). Each function should return normalized 0-1 scores.\n\n**Context:** Separate scoring functions make each factor testable independently and allow easy adjustment of individual scoring logic without touching the main algorithm.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:28.419865-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:28.419865-06:00","labels":["algorithm","backend","branding","frontend","navigation"],"dependencies":[{"issue_id":"test-e6t2s2","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:08:28.6195-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s2","depends_on_id":"test-e6t2s1","type":"blocks","created_at":"2026-01-30T12:09:57.754313-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s3","title":"Build Convex query function for lead selection","description":"Create convex/checkIns/selectLeadsForCheckIn.ts query that: 1) Accepts agentId and optional config overrides (topN, weights), 2) Fetches all leads for agent excluding those contacted within minHoursSinceContact, 3) Calculates total weighted score for each lead using the scoring functions, 4) Sorts by totalScore descending, 5) Returns top N leads with their score breakdowns. Include index on leads table for lastContactedAt if not exists.\n\n**Context:** This is the core intelligence of RealHerd - surfacing the right leads at the right time. The query must be efficient as it runs on every check-in initiation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:28.819872-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:28.819872-06:00","labels":["backend","components","convex","frontend"],"dependencies":[{"issue_id":"test-e6t2s3","depends_on_id":"test-e6t2s1","type":"blocks","created_at":"2026-01-30T11:11:09.802526-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s3","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:08:29.099121-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s3","depends_on_id":"test-e6t2s2","type":"blocks","created_at":"2026-01-30T12:09:58.018892-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t2s4","title":"Write integration tests and verify algorithm behavior","description":"Create test file with seed data covering edge cases: leads with various temperatures, recent/old contact dates, upcoming/distant target dates, different stage durations. Verify: 1) Hot lead with old contact date scores higher than cold lead with recent contact, 2) Lead with imminent target date surfaces before distant date, 3) Stale lead in same stage for weeks surfaces appropriately, 4) Algorithm handles null target dates gracefully. Run tests and verify passing.\n\n**Context:** The scoring algorithm directly impacts agent productivity - incorrect prioritization means missed opportunities. Comprehensive tests ensure the algorithm works as designed.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:29.623573-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:29.623573-06:00","labels":["backend","frontend","testing","ux"],"dependencies":[{"issue_id":"test-e6t2s4","depends_on_id":"test-e6t2s2","type":"blocks","created_at":"2026-01-30T11:11:10.210859-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s4","depends_on_id":"test-e6t2","type":"parent-child","created_at":"2026-01-30T12:08:29.862402-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t2s4","depends_on_id":"test-e6t2s3","type":"blocks","created_at":"2026-01-30T12:09:58.25604-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3","title":"Build check-in scheduling system with Convex cron","description":"Implement the cron job system that schedules check-in calls based on each agent's configuration. Create ScheduledCheckIn records at appropriate times, handle timezone conversions, and manage frequency settings.\n\n**Context:** Proactive scheduling is what makes this a 'virtual sales manager' - the system initiates accountability rather than waiting for agents to remember. Configurable frequency lets agents customize their accountability level.","design":"Convex cron job runs daily, creates ScheduledCheckIn records for next period. Respect agent timezone and preferred times. Handle edge cases: disabled configs, recently completed check-ins. Use Convex scheduler for the cron implementation.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:08.406448-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:08.406448-06:00","labels":["backend","convex","cron"],"dependencies":[{"issue_id":"test-e6t3","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:08.500214-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3","depends_on_id":"test-e6t1","type":"blocks","created_at":"2026-01-30T12:09:58.483881-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s1","title":"Create ScheduledCheckIn schema and types","description":"Define the ScheduledCheckIn table in Convex schema with fields: agentId (reference to users), scheduledFor (timestamp), status (enum: pending, completed, missed, cancelled), checkInConfigId (reference), createdAt. Create TypeScript types for scheduling logic including timezone handling utilities.\n\n**Context:** The ScheduledCheckIn records are the core data structure that bridges configuration (when/how often) with actual check-in execution. Clean schema design enables reliable scheduling and status tracking.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:30.143535-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:30.143535-06:00","labels":["backend","convex","database","frontend","real-time"],"dependencies":[{"issue_id":"test-e6t3s1","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:08:30.398683-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s2","title":"Implement timezone-aware scheduling utilities","description":"Create utility functions for: converting agent's preferred time to UTC for storage, calculating next check-in time based on frequency (daily/weekly/custom), determining if a check-in is due based on last completed check-in timestamp. Handle edge cases like DST transitions and invalid timezone strings.\n\n**Context:** Agents work in different timezones and want check-ins at their local preferred time. Getting timezone math wrong means calls at 3am or missed accountability windows.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:30.571804-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:30.571804-06:00","labels":["backend","frontend","utilities","visualization"],"dependencies":[{"issue_id":"test-e6t3s2","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:08:30.850564-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s2","depends_on_id":"test-e6t3s1","type":"blocks","created_at":"2026-01-30T12:09:58.684566-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s3","title":"Build Convex cron job for daily schedule generation","description":"Implement a Convex scheduled function (crons.ts) that runs daily at a fixed UTC time. The job should: 1) Query all active CheckInConfig records, 2) For each config, check if a ScheduledCheckIn already exists for the next period, 3) If not, calculate the next check-in time using the timezone utilities, 4) Create ScheduledCheckIn records with status='pending'. Skip configs where agent is disabled or check-in was recently completed within frequency window.\n\n**Context:** This is the heartbeat of the accountability system - it proactively creates the schedule so agents receive their check-in prompts at the right times without manual intervention.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:31.148673-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:31.148673-06:00","labels":["backend","convex","cron","frontend","search"],"dependencies":[{"issue_id":"test-e6t3s3","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:08:31.405613-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s3","depends_on_id":"test-e6t3s1","type":"blocks","created_at":"2026-01-30T12:09:58.927608-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s3","depends_on_id":"test-e6t3s2","type":"blocks","created_at":"2026-01-30T12:09:59.199514-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t3s4","title":"Add schedule management queries and verify end-to-end","description":"Create Convex queries: getUpcomingCheckIns(agentId) returns pending scheduled check-ins, getPendingCheckInsForProcessing() returns all due check-ins (scheduledFor \u003c= now). Create mutation updateScheduledCheckInStatus(id, status) for marking complete/missed/cancelled. Run the full flow: create a test config, trigger cron manually, verify ScheduledCheckIn record created with correct time.\n\n**Context:** These queries power both the agent-facing UI (showing upcoming check-ins) and the backend processing that actually triggers the check-in calls when time arrives.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:31.638732-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:31.638732-06:00","labels":["api","backend","convex","frontend","integration"],"dependencies":[{"issue_id":"test-e6t3s4","depends_on_id":"test-e6t3","type":"parent-child","created_at":"2026-01-30T12:08:31.776493-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t3s4","depends_on_id":"test-e6t3s3","type":"blocks","created_at":"2026-01-30T12:09:59.406943-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4","title":"Implement check-in conversation flow and script","description":"Build the conversation handler for check-in calls that reviews 3-5 leads with the agent. Implement the scripted flow per PRD: greeting, lead-by-lead review, collect updates, confirm changes, schedule follow-ups.\n\n**Context:** The conversation flow must feel natural while efficiently covering multiple leads. Each lead gets a quick status check and the agent can provide updates that get tracked. This is the core interaction that drives CRM hygiene.","design":"Integrate with existing Telnyx call handling. Use LFM for conversation, structured prompts per lead. Track which leads were discussed. Allow agent to skip leads or add notes. Conversation state machine: intro  lead_review (loop)  summary  close.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:08.629547-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:08.629547-06:00","labels":["backend","conversation","telnyx","voice"],"dependencies":[{"issue_id":"test-e6t4","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:08.753822-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4","depends_on_id":"test-e6t2","type":"blocks","created_at":"2026-01-30T12:09:59.737787-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s1","title":"Define conversation state machine and TypeScript types","description":"Create the state machine definition for check-in conversations with states: intro, lead_review (looping), summary, close. Define TypeScript types for conversation state, lead review results, agent responses, and transition events. Include types for tracking which leads were discussed, skipped, and what updates were collected.\n\n**Context:** The state machine ensures conversations follow a consistent flow while allowing flexibility for agent responses. Clear types prevent bugs when tracking multi-lead reviews and enable type-safe integration with the LFM prompting system.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:32.05684-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:32.05684-06:00","labels":["backend","database","types"],"dependencies":[{"issue_id":"test-e6t4s1","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:08:32.374071-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s2","title":"Build LFM prompt templates for each conversation phase","description":"Create structured prompt templates for: (1) greeting/intro that sets context, (2) individual lead review prompts that present lead name, last activity, and ask for status update, (3) summary prompt that recaps all changes, (4) closing prompt that confirms follow-ups. Each template should accept dynamic data (lead info, agent name, accumulated updates). Design prompts to feel conversational while efficiently extracting structured updates.\n\n**Context:** The prompts are the 'script' that makes check-ins feel like talking to a helpful sales manager rather than a robot. Good prompts extract actionable updates (status changes, notes, follow-up dates) without feeling like an interrogation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:32.664348-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:32.664348-06:00","labels":["ai","backend","business-logic"],"dependencies":[{"issue_id":"test-e6t4s2","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:08:32.901505-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s2","depends_on_id":"test-e6t4s1","type":"blocks","created_at":"2026-01-30T12:09:59.995175-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s3","title":"Implement conversation handler with Telnyx integration","description":"Build the main conversation handler class that: (1) initializes from incoming Telnyx call webhook, (2) manages state machine transitions, (3) iterates through 3-5 selected leads, (4) processes agent voice responses via LFM to extract intents (update status, add note, skip lead, schedule follow-up), (5) accumulates changes in conversation state, (6) handles interruptions and 'go back' requests. Integrate with existing Telnyx call handling infrastructure for audio I/O.\n\n**Context:** This is the core runtime that orchestrates the entire check-in experience. It must handle the messy reality of voice conversations - agents might interrupt, give partial answers, or want to revisit a lead. Robust state management prevents lost updates.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:08:33.135396-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:33.135396-06:00","labels":["backend","frontend","integration","ui"],"dependencies":[{"issue_id":"test-e6t4s3","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:08:33.309429-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s3","depends_on_id":"test-e6t4s1","type":"blocks","created_at":"2026-01-30T12:10:00.282542-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s3","depends_on_id":"test-e6t4s2","type":"blocks","created_at":"2026-01-30T12:10:00.48311-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t4s4","title":"Add conversation completion handler and verify end-to-end flow","description":"Implement the completion handler that fires when conversation reaches 'close' state: (1) persist all collected updates to lead records, (2) create any scheduled follow-up tasks, (3) log conversation summary for audit/review, (4) update agent's last check-in timestamp. Write integration test that simulates a complete 3-lead check-in call with mocked Telnyx/LFM responses. Verify all state transitions, updates persist correctly, and follow-ups are created.\n\n**Context:** The completion handler is where check-in conversations create real value - updates actually land in the CRM. Without reliable persistence, agents lose trust in the system. The integration test proves the full flow works before deploying to real agents.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:33.667737-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:33.667737-06:00","labels":["backend","deployment","integration","testing"],"dependencies":[{"issue_id":"test-e6t4s4","depends_on_id":"test-e6t4","type":"parent-child","created_at":"2026-01-30T12:08:33.977269-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t4s4","depends_on_id":"test-e6t4s3","type":"blocks","created_at":"2026-01-30T12:10:00.762796-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5","title":"Create LeadUpdate model and multi-lead update tracking","description":"Define the LeadUpdate model to capture per-lead changes from check-in calls. Track which leads were reviewed, what updates were made (temperature, notes, next actions), and link to the parent check-in call.\n\n**Context:** Each check-in call can update multiple leads - we need to track what changed for each lead and maintain the audit trail. This data also feeds into compliance tracking and analytics.","design":"LeadUpdate: id, checkInId, leadId, previousValues (snapshot), newValues, updateType (temperature/notes/stage/nextAction), timestamp. Batch create on call completion. Consider sync to Follow Up Boss.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:08.88797-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:08.88797-06:00","labels":["backend","convex","database"],"dependencies":[{"issue_id":"test-e6t5","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:08.991458-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5","depends_on_id":"test-e6t1","type":"blocks","created_at":"2026-01-30T12:10:01.029697-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5","depends_on_id":"test-e6t4","type":"blocks","created_at":"2026-01-30T12:10:01.264173-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s1","title":"Create LeadUpdate Prisma schema with snapshot fields","description":"Add LeadUpdate model to schema.prisma with: id (cuid), checkInId (relation to CheckInCall), leadId (relation to Lead), previousValues (Json - snapshot of lead state before update), newValues (Json - the changes applied), updateType (enum: TEMPERATURE, NOTES, STAGE, NEXT_ACTION, MULTIPLE), createdAt timestamp. Add proper indexes on checkInId and leadId for efficient queries. Include enum UpdateType with appropriate values.\n\n**Context:** The LeadUpdate model is the audit trail for every change made during check-ins. Storing previousValues as a JSON snapshot enables rollback capability and compliance reporting. The updateType enum helps filter and analyze what kinds of updates agents are making.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:34.250419-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:34.250419-06:00","labels":["backend","database","performance","prisma","testing"],"dependencies":[{"issue_id":"test-e6t5s1","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:08:34.434882-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s2","title":"Create LeadUpdate TypeScript types and Zod schemas","description":"Define TypeScript interfaces in src/types/leadUpdate.ts: LeadUpdateCreate (checkInId, leadId, previousValues, newValues, updateType), LeadUpdateResponse (full model with relations), LeadSnapshot (structure for previousValues/newValues capturing temperature, notes, stage, nextActionDate, nextActionType). Create Zod schemas for validation of create/update operations and snapshot structure.\n\n**Context:** Strong typing ensures data integrity when batch-creating updates at call completion. The LeadSnapshot type defines exactly what fields we track changes for, making the audit trail meaningful and queryable.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":40,"created_at":"2026-01-30T12:08:34.616468-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:34.616468-06:00","labels":["backend","frontend","optimization","typescript"],"dependencies":[{"issue_id":"test-e6t5s2","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:08:34.830574-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s2","depends_on_id":"test-e6t5s1","type":"blocks","created_at":"2026-01-30T12:10:01.677397-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s3","title":"Implement LeadUpdate service with batch create capability","description":"Create src/services/leadUpdateService.ts with methods: createLeadUpdate (single), batchCreateLeadUpdates (array - used on call completion), getUpdatesByCheckIn (for viewing call results), getUpdatesByLead (for lead history), calculateDiff (helper to generate previousValues/newValues from lead before/after states). Use Prisma transactions for batch operations to ensure atomicity.\n\n**Context:** Batch creation is critical because a single check-in call typically updates multiple leads. The calculateDiff helper automatically captures what changed, reducing error-prone manual tracking. Transaction wrapping ensures either all updates succeed or none do.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:35.083853-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:35.083853-06:00","labels":["backend","service","setup","testing","validation"],"dependencies":[{"issue_id":"test-e6t5s3","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:08:35.318057-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s3","depends_on_id":"test-e6t5s2","type":"blocks","created_at":"2026-01-30T12:10:01.968963-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t5s4","title":"Add LeadUpdate API routes and verify with tests","description":"Create API routes in src/app/api/lead-updates/route.ts: GET (list with checkInId or leadId filter), POST (batch create for call completion). Add src/app/api/lead-updates/[id]/route.ts for GET single. Include proper authentication middleware. Write integration tests verifying: batch create on call completion, filtering by checkIn, filtering by lead, proper error handling for invalid foreign keys.\n\n**Context:** These routes enable the check-in completion flow to persist all lead updates atomically, and allow the UI to display what changed during each call. The batch POST is the primary endpoint - called when an agent finishes their check-in to record all the updates discussed.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:35.569959-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:35.569959-06:00","labels":["api","backend","iteration","user-testing","validation"],"dependencies":[{"issue_id":"test-e6t5s4","depends_on_id":"test-e6t5","type":"parent-child","created_at":"2026-01-30T12:08:35.909286-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t5s4","depends_on_id":"test-e6t5s3","type":"blocks","created_at":"2026-01-30T12:10:02.250312-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6","title":"Add check-in compliance tracking and missed call handling","description":"Implement tracking for whether agents complete their scheduled check-ins. Mark check-ins as missed after timeout, track compliance rate, and optionally reschedule missed check-ins.\n\n**Context:** Compliance tracking closes the accountability loop - brokers can see which agents are engaging with the system. This data becomes valuable for team performance management and demonstrates ROI.","design":"Cron job marks pending check-ins as missed after window expires (e.g., 2 hours past scheduled time). Calculate compliance rate per agent. Store missedReason if agent declined. Consider notification for missed check-ins.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:09.145605-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:09.145605-06:00","labels":["analytics","backend","cron"],"dependencies":[{"issue_id":"test-e6t6","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:09.289074-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6","depends_on_id":"test-e6t3","type":"blocks","created_at":"2026-01-30T12:10:02.50393-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6","depends_on_id":"test-e6t5","type":"blocks","created_at":"2026-01-30T12:10:02.685162-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s1","title":"Add compliance tracking fields to database schema","description":"Extend the check-in schema with fields for compliance tracking: status enum (pending, completed, missed, declined), completedAt timestamp, missedAt timestamp, missedReason optional text field, and complianceWindow (minutes after scheduled time before marking missed, default 120).\n\n**Context:** The database needs to distinguish between completed, missed, and declined check-ins to calculate compliance rates and provide actionable data for brokers.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:36.137178-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:36.137178-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e6t6s1","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:08:36.38494-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s2","title":"Implement cron job to mark check-ins as missed","description":"Create a scheduled job (cron or serverless function) that runs every 15 minutes to find check-ins where: status is 'pending', scheduledTime + complianceWindow \u003c now. Update these to status='missed' and set missedAt timestamp. Log the number of check-ins marked missed for monitoring.\n\n**Context:** Automated marking ensures accountability without manual intervention. The 2-hour default window gives agents reasonable flexibility while still enforcing accountability.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:36.556255-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:36.556255-06:00","labels":["backend","cron"],"dependencies":[{"issue_id":"test-e6t6s2","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:08:36.678379-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6s2","depends_on_id":"test-e6t6s1","type":"blocks","created_at":"2026-01-30T12:10:02.861761-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s3","title":"Build compliance rate calculation API endpoint","description":"Create API endpoint GET /api/agents/:id/compliance that returns: totalCheckIns, completedCheckIns, missedCheckIns, declinedCheckIns, complianceRate (percentage), streakCurrent (consecutive completed), and optionally filter by date range. Also create a brokerage-level endpoint GET /api/brokerage/:id/compliance for aggregate team stats.\n\n**Context:** Compliance metrics are key for brokers to demonstrate ROI and identify agents who need coaching. The streak metric gamifies compliance and encourages consistent engagement.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:37.043103-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:37.043103-06:00","labels":["api","backend"],"dependencies":[{"issue_id":"test-e6t6s3","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:08:37.413994-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6s3","depends_on_id":"test-e6t6s1","type":"blocks","created_at":"2026-01-30T12:10:03.05951-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t6s4","title":"Add missed check-in notification and optional reschedule","description":"When a check-in is marked missed: 1) Send notification to agent (push/SMS based on preferences) with option to complete now or reschedule, 2) Optionally notify broker/team lead if agent has multiple consecutive misses (configurable threshold, default 3). Include a 'complete now' deep link in notifications.\n\n**Context:** Notifications create a feedback loop - agents are reminded they missed without being punished. Escalation to brokers only happens for patterns, not one-offs, maintaining trust while ensuring accountability.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:37.766918-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:37.766918-06:00","labels":["backend","notifications"],"dependencies":[{"issue_id":"test-e6t6s4","depends_on_id":"test-e6t6","type":"parent-child","created_at":"2026-01-30T12:08:38.090574-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t6s4","depends_on_id":"test-e6t6s2","type":"blocks","created_at":"2026-01-30T12:10:03.280936-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t7","title":"Build check-in configuration UI and verification","description":"Create the settings page where agents configure their check-in preferences: frequency, lead count, preferred times, timezone. Include a test button to preview which leads would be selected. Verify full check-in flow works end-to-end.\n\n**Context:** Agents need control over their accountability settings to ensure buy-in. The preview feature builds trust by showing the algorithm's decisions. This UI makes the feature accessible to non-technical users.","design":"Settings form with frequency selector (daily/every 2 days/etc), lead count slider (3-5), time picker for preferred slots, timezone auto-detect with override. Preview shows sample leads that would be selected. Use shadcn/ui components.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:09.514592-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:09.514592-06:00","labels":["frontend","settings","ui"],"dependencies":[{"issue_id":"test-e6t7","depends_on_id":"test-e6","type":"parent-child","created_at":"2026-01-30T12:07:09.693721-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7","depends_on_id":"test-e6t2","type":"blocks","created_at":"2026-01-30T12:10:03.49651-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7","depends_on_id":"test-e6t3","type":"blocks","created_at":"2026-01-30T12:10:03.66898-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7","depends_on_id":"test-e6t6","type":"blocks","created_at":"2026-01-30T12:10:03.852559-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t7s1","title":"Create check-in settings form schema and types","description":"Define TypeScript types and Zod schema for check-in configuration: frequency (daily/every_2_days/every_3_days/weekly), lead_count (3-5 range), preferred_times (array of time slots), timezone (string). Create the form validation schema with appropriate constraints and error messages.\n\n**Context:** Type-safe configuration ensures the form and backend stay in sync. Zod schema provides runtime validation and integrates with react-hook-form for the UI.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:08:38.38853-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:38.38853-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e6t7s1","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:38.562751-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t7s2","title":"Build check-in settings form UI with shadcn/ui","description":"Create CheckInSettings component with: Select for frequency options, Slider for lead count (3-5), TimePicker for preferred check-in times (allow multiple slots), timezone selector with auto-detect (Intl.DateTimeFormat().resolvedOptions().timeZone) and manual override. Use react-hook-form with the Zod schema. Include save button that calls the settings API.\n\n**Context:** This is the primary UI for agents to control their accountability settings. Auto-detecting timezone reduces friction while the override handles edge cases like traveling agents.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:38.747303-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:38.747303-06:00","labels":["frontend"],"dependencies":[{"issue_id":"test-e6t7s2","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:38.888424-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7s2","depends_on_id":"test-e6t7s1","type":"blocks","created_at":"2026-01-30T12:10:04.059399-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t7s3","title":"Implement lead preview feature with test button","description":"Add 'Preview Check-in' button to settings form that calls a preview endpoint with current form values. Display the sample leads that would be selected in a card list showing: lead name, last contact date, priority score, and reason for selection. Show loading state during API call and empty state if no leads qualify.\n\n**Context:** The preview builds trust by making the algorithm transparent. Agents can see exactly which leads would be selected before committing to settings, increasing buy-in to the accountability system.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:39.082826-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:39.082826-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e6t7s3","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:39.286062-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7s3","depends_on_id":"test-e6t7s2","type":"blocks","created_at":"2026-01-30T12:10:04.292098-06:00","created_by":"David Habedank"}]}
{"id":"test-e6t7s4","title":"Verify end-to-end check-in flow and add to settings page","description":"Wire CheckInSettings component into the app's settings page. Test complete flow: configure settings  save  preview leads  verify scheduler picks up new settings  confirm check-in triggers at configured time (can use shorter interval for testing). Add success toast on save, error handling for API failures.\n\n**Context:** End-to-end verification ensures the entire accountability system works together: settings  scheduler  lead selection  notification. This is the moment of truth for the feature.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:39.775352-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:39.775352-06:00","labels":["frontend","integration"],"dependencies":[{"issue_id":"test-e6t7s4","depends_on_id":"test-e6t7","type":"parent-child","created_at":"2026-01-30T12:08:39.956659-06:00","created_by":"David Habedank"},{"issue_id":"test-e6t7s4","depends_on_id":"test-e6t7s3","type":"blocks","created_at":"2026-01-30T12:10:04.483611-06:00","created_by":"David Habedank"}]}
{"id":"test-e7","title":"Organization \u0026 Team Management","description":"Build multi-tenant support for brokerages with organization settings, agent invitation flows, team creation, and role-based permissions. Implement agent onboarding call.\n\n**Context:** Brokerages are the primary buyer - they need to manage their organization, invite agents, and configure settings. The onboarding call sets expectations for new agents.","acceptance_criteria":"- Organization creation with FUB API key, check-in settings, debrief settings\n- Agent invitation via email and SMS\n- Agent onboarding welcome call explaining how RealHerd works\n- Team creation with leader assignment\n- Team-level settings override organization defaults\n- Role-based permissions: broker sees all, team_lead sees team, agent sees self\n- Agent activation/deactivation controls\n- Agent phone number verification\n- Agent preferences: timezone, quiet hours, voice gender, auto-call opt-out","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:06:56.946143-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:56.946143-06:00","labels":["multi-tenant","onboarding","organization","teams"],"dependencies":[{"issue_id":"test-e7","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:10:04.668787-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1","title":"Create organization data model and settings schema","description":"Design and implement the Convex schema for organizations including FUB API key storage, check-in settings (timing, frequency), debrief settings, and default preferences. Include proper indexes for multi-tenant queries.\n\n**Context:** Brokerages are the primary buyer - the organization model is the foundation for all multi-tenant functionality. Settings here cascade down to teams and agents as defaults.","design":"Use Convex schema with proper field types. Store FUB API key encrypted. Include fields for: name, fub_api_key, check_in_settings (JSON), debrief_settings (JSON), default_timezone, default_quiet_hours, created_at, updated_at. Add index on clerk_org_id for fast lookups.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":240,"created_at":"2026-01-30T12:07:09.918505-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:09.918505-06:00","labels":["backend","database","schema"],"dependencies":[{"issue_id":"test-e7t1","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:07:10.049244-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s1","title":"Create Convex schema for organizations table","description":"Define the organizations table in Convex schema with all required fields: name (string), clerk_org_id (string), fub_api_key_encrypted (string), check_in_settings (object with timing/frequency), debrief_settings (object), default_timezone (string), default_quiet_hours (object with start/end), created_at (number), updated_at (number). Add index on clerk_org_id for fast multi-tenant lookups.\n\n**Context:** This is the foundational schema that all other multi-tenant features depend on. The clerk_org_id index is critical for performant queries since every API call will filter by organization.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:40.188473-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:40.188473-06:00","labels":["backend","convex","database"],"dependencies":[{"issue_id":"test-e7t1s1","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:08:40.433505-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s2","title":"Create TypeScript types for organization settings","description":"Define TypeScript interfaces for CheckInSettings (check_in_time, frequency, reminder_before_minutes), DebriefSettings (enabled, frequency, send_time), and QuietHours (start_hour, end_hour, timezone_override). Export these types for use in mutations, queries, and frontend components.\n\n**Context:** Strong typing prevents configuration errors that could result in agents getting check-ins at wrong times or missing debriefs entirely. These settings cascade as defaults to teams and agents.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":30,"created_at":"2026-01-30T12:08:40.663836-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:40.663836-06:00","labels":["backend","typescript"],"dependencies":[{"issue_id":"test-e7t1s2","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:08:40.935784-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s2","depends_on_id":"test-e7t1s1","type":"blocks","created_at":"2026-01-30T12:10:04.860584-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s3","title":"Implement FUB API key encryption utilities","description":"Create utility functions for encrypting FUB API keys before storage and decrypting when needed for API calls. Use environment variable for encryption key. Implement encryptApiKey(plaintext) and decryptApiKey(ciphertext) functions with AES-256-GCM encryption.\n\n**Context:** FUB API keys grant full access to a brokerage's CRM data. Encryption at rest is essential for security compliance and protecting customer data if database is compromised.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:41.232453-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:41.232453-06:00","labels":["backend","security"],"dependencies":[{"issue_id":"test-e7t1s3","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:08:41.603041-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s3","depends_on_id":"test-e7t1s1","type":"blocks","created_at":"2026-01-30T12:10:05.183566-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t1s4","title":"Create organization CRUD mutations and queries","description":"Implement Convex mutations: createOrganization (with validation), updateOrganizationSettings (partial updates), setFubApiKey (encrypts before storage). Implement queries: getOrganization (by clerk_org_id), getOrganizationSettings (returns decrypted settings). All functions should validate clerk_org_id matches authenticated user's organization.\n\n**Context:** These mutations are the API for all organization management. Security is critical - every operation must verify the caller belongs to the organization they're modifying.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:41.8074-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:41.8074-06:00","labels":["api","backend","convex"],"dependencies":[{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1","type":"parent-child","created_at":"2026-01-30T12:08:41.993814-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1s1","type":"blocks","created_at":"2026-01-30T12:10:05.425749-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1s2","type":"blocks","created_at":"2026-01-30T12:10:06.052862-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t1s4","depends_on_id":"test-e7t1s3","type":"blocks","created_at":"2026-01-30T12:10:06.415248-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2","title":"Build organization settings UI and FUB API integration","description":"Create the organization settings page where brokers can configure their brokerage: add FUB API key, set default check-in/debrief settings, and manage organization-wide preferences. Validate FUB API key by making a test API call.\n\n**Context:** Broker admins need a central place to configure their brokerage. FUB integration is essential - it's where all their lead data lives. Invalid API keys must be caught early.","design":"Settings page with sections: General, FUB Integration, Check-in Defaults, Debrief Defaults. Use shadcn/ui form components. FUB validation: call /users endpoint to verify key works. Show connection status badge.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:10.19046-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:10.19046-06:00","labels":["api","frontend","settings"],"dependencies":[{"issue_id":"test-e7t2","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:07:10.306033-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t2","depends_on_id":"test-e7t1","type":"blocks","created_at":"2026-01-30T12:10:06.723607-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s1","title":"Create organization settings page layout with shadcn/ui form sections","description":"Build the organization settings page at /settings/organization with tabbed or sectioned layout containing: General (org name, timezone), FUB Integration, Check-in Defaults, and Debrief Defaults sections. Use shadcn/ui Card, Tabs, and Form components. Include page header with save button. Wire up basic Next.js routing and page structure.\n\n**Context:** This establishes the UI foundation that all subsequent settings functionality will plug into. Clean section organization helps brokers find settings quickly.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:42.202887-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:42.202887-06:00","labels":["frontend","ui"],"dependencies":[{"issue_id":"test-e7t2s1","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:08:42.370427-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s2","title":"Build FUB API key input form with validation API route","description":"Create the FUB Integration section with: API key input field (password type with show/hide toggle), 'Test Connection' button, and connection status badge (untested/connected/failed). Create API route POST /api/settings/fub/validate that accepts API key, calls FUB /users endpoint to verify, returns success/failure. Show loading state during validation.\n\n**Context:** FUB integration is essential - all lead data lives there. Invalid API keys must be caught immediately before broker wastes time configuring other settings. Test connection gives immediate feedback.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:42.573222-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:42.573222-06:00","labels":["api","backend","frontend"],"dependencies":[{"issue_id":"test-e7t2s2","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:08:42.699605-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t2s2","depends_on_id":"test-e7t2s1","type":"blocks","created_at":"2026-01-30T12:10:07.236851-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s3","title":"Implement settings persistence with database and server actions","description":"Create server actions to save/load organization settings. Save validated FUB API key (encrypted) to organization record. Implement check-in defaults (frequency options: daily/weekly, default time, reminder enabled), debrief defaults (questions template, required fields). Load existing settings on page mount. Show toast on successful save.\n\n**Context:** Settings must persist so brokers don't lose configuration. Encryption for API keys is critical for security. Defaults reduce setup friction for agents.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:42.945086-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:42.945086-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e7t2s3","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:08:43.088702-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t2s3","depends_on_id":"test-e7t2s2","type":"blocks","created_at":"2026-01-30T12:10:07.586577-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t2s4","title":"Add settings page to navigation and verify complete flow","description":"Add Organization Settings link to main navigation (visible only to broker/admin roles). Implement role-based access check on settings page (redirect non-admins). Run through complete flow: navigate to settings, configure all sections, save, refresh, verify. Fix any edge cases discovered.\n\n**Context:** Only broker admins should access org settings - agents shouldn't change FUB keys or defaults. Complete flow verification catches integration issues before release.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:43.296906-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:43.296906-06:00","labels":["auth","frontend"],"dependencies":[{"issue_id":"test-e7t2s4","depends_on_id":"test-e7t2","type":"parent-child","created_at":"2026-01-30T12:08:43.458656-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t2s4","depends_on_id":"test-e7t2s3","type":"blocks","created_at":"2026-01-30T12:10:07.917451-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3","title":"Implement agent invitation and onboarding flow","description":"Build the agent invitation system: broker enters email/phone, agent receives invite via email and SMS, agent completes signup with phone verification, system triggers welcome onboarding call explaining how RealHerd works.\n\n**Context:** Getting agents into the system smoothly is critical for adoption. The onboarding call sets expectations - agents need to understand RealHerd will be calling them regularly about their leads.","design":"Invitation flow: 1) Broker adds agent (email + phone), 2) System sends email invite + SMS, 3) Agent clicks link and signs up via Clerk, 4) Phone verification via Telnyx SMS, 5) Trigger onboarding call via Telnyx. Store invitation status: pending, accepted, expired. Onboarding call script introduces RealHerd, explains check-ins/debriefs, gets agent preferences.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:07:10.544522-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:10.544522-06:00","labels":["backend","clerk","frontend","onboarding","telnyx"],"dependencies":[{"issue_id":"test-e7t3","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:07:10.76434-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3","depends_on_id":"test-e7t1","type":"blocks","created_at":"2026-01-30T12:10:08.272328-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s1","title":"Create invitation data model and database schema","description":"Create Prisma schema for agent invitations: AgentInvitation model with fields: id, brokerageId (FK), invitedByUserId (FK), email, phone, status (enum: PENDING, ACCEPTED, EXPIRED), inviteToken (unique), expiresAt, createdAt, updatedAt. Add index on inviteToken for quick lookups. Create migration and generate Prisma client.\n\n**Context:** The invitation system needs persistent state to track who was invited, by whom, and whether they completed signup. The token enables secure invite links.\n\n**Testing Requirements:**\n- **Unit Tests:** Verify invitation model validates required fields; Test invitation token uniqueness constraint; Test status enum values\n- **Integration Tests:** Create invitation and verify database persistence; Test foreign key relationships to brokerage and user","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:43.69982-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:43.69982-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e7t3s1","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:08:43.913336-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s2","title":"Build invitation API and multi-channel delivery (email + SMS)","description":"Create POST /api/invitations endpoint that: 1) Validates broker has permission to invite to their brokerage, 2) Creates AgentInvitation record with secure token (crypto.randomUUID), 3) Sends email via Resend with branded invite template containing signup link, 4) Sends SMS via Telnyx with short invite message and link. Include error handling for invalid email/phone. Create GET /api/invitations/[token] to validate tokens.\n\n**Context:** Dual-channel delivery (email + SMS) maximizes the chance agents see and act on invitations. The broker initiating must have proper permissions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test invitation creation with valid broker permissions; Test token generation produces unique values; Test validation rejects invalid email/phone formats\n- **Integration Tests:** End-to-end invitation creation triggers both email and SMS; Test token validation endpoint returns correct invitation status; Test expired invitations are rejected","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:44.117315-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:44.117315-06:00","labels":["api","backend","resend","telnyx"],"dependencies":[{"issue_id":"test-e7t3s2","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:08:44.267718-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3s2","depends_on_id":"test-e7t3s1","type":"blocks","created_at":"2026-01-30T12:10:08.488356-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s3","title":"Implement agent signup flow with phone verification","description":"Create /invite/[token] page that: 1) Validates invitation token and shows error if invalid/expired, 2) Pre-fills email from invitation, 3) Uses Clerk SignUp component for account creation, 4) After Clerk signup, triggers Telnyx SMS verification to confirm phone ownership, 5) On successful verification, updates invitation status to ACCEPTED, links agent to brokerage. Handle edge cases: already-registered email, expired tokens, failed phone verification.\n\n**Context:** Phone verification is critical because RealHerd will be calling agents - we must verify they own the number. Clerk handles auth, Telnyx handles phone verification.\n\n**Testing Requirements:**\n- **Unit Tests:** Test token validation logic; Test phone verification code validation; Test invitation status transitions\n- **Integration Tests:** Full signup flow from invite link to verified account; Test handling of already-registered email; Test expired token shows appropriate error","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:08:44.497562-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:44.497562-06:00","labels":["backend","clerk","frontend","telnyx"],"dependencies":[{"issue_id":"test-e7t3s3","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:08:44.676235-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3s3","depends_on_id":"test-e7t3s2","type":"blocks","created_at":"2026-01-30T12:10:08.720778-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t3s4","title":"Trigger welcome onboarding call for new agents","description":"After successful signup and phone verification, trigger automated onboarding call via Telnyx: 1) Create TelnyxService.initiateOnboardingCall(agentId) method, 2) Call script introduces RealHerd, explains regular check-ins about their leads, describes debrief process after appointments, asks for preferred call times. Store call result and any preferences captured. Add retry logic if call goes to voicemail - schedule callback. Create simple admin view to see onboarding call status.\n\n**Context:** The onboarding call sets expectations - agents need to understand RealHerd will call them regularly. This first call establishes the relationship and gathers preferences that improve future interactions.\n\n**Testing Requirements:**\n- **Unit Tests:** Test onboarding call initiation logic; Test voicemail detection and retry scheduling; Test preference storage from call results\n- **Integration Tests:** Verify call triggers after successful signup flow; Test retry logic schedules follow-up call on voicemail; Admin view shows correct onboarding status","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:44.847291-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:44.847291-06:00","labels":["backend","telnyx","voice"],"dependencies":[{"issue_id":"test-e7t3s4","depends_on_id":"test-e7t3","type":"parent-child","created_at":"2026-01-30T12:08:45.00277-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t3s4","depends_on_id":"test-e7t3s3","type":"blocks","created_at":"2026-01-30T12:10:08.946746-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4","title":"Build team management with hierarchy and settings inheritance","description":"Create team data model and UI for creating teams, assigning team leaders, adding agents to teams, and configuring team-level settings that override organization defaults. Include team member listing with roles.\n\n**Context:** Teams allow brokerages to organize agents by specialty or location. Team leads need visibility into their team's performance. Settings inheritance (org  team  agent) reduces configuration burden.","design":"Team schema: name, org_id, leader_id (agent), settings (overrides). TeamMember junction table: team_id, agent_id, joined_at. Settings inheritance: get org defaults, merge team overrides, merge agent overrides. UI: team list, team detail with members, drag-drop member assignment.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:10.995038-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:10.995038-06:00","labels":["backend","frontend","teams"],"dependencies":[{"issue_id":"test-e7t4","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:07:11.135911-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4","depends_on_id":"test-e7t1","type":"blocks","created_at":"2026-01-30T12:10:09.547705-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4","depends_on_id":"test-e7t3","type":"blocks","created_at":"2026-01-30T12:10:09.936858-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s1","title":"Create Team and TeamMember database schema with Drizzle","description":"Define Team table (id, name, org_id FK, leader_id FK to agents, settings JSONB for overrides, created_at, updated_at) and TeamMember junction table (team_id, agent_id, role enum, joined_at). Add proper indexes for org_id and leader_id lookups. Create TypeScript types for Team, TeamMember, and TeamSettings. Include migration file.\n\n**Context:** Teams are the organizational unit between org and agent. The settings JSONB allows team-level overrides that sit between org defaults and agent preferences in the inheritance chain.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:45.218817-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:45.218817-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e7t4s1","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:08:45.412248-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s2","title":"Implement settings inheritance utility and team CRUD API routes","description":"Create getEffectiveSettings(orgId, teamId?, agentId?) utility that merges settings in order: org defaults  team overrides  agent overrides. Implement API routes: GET /api/teams (list by org), POST /api/teams (create), GET /api/teams/[id] (detail with members), PUT /api/teams/[id] (update including settings), DELETE /api/teams/[id], POST /api/teams/[id]/members (add member), DELETE /api/teams/[id]/members/[agentId] (remove member).\n\n**Context:** Settings inheritance is the key value prop - reduces configuration burden by letting teams override only what's different from org. CRUD routes power the management UI.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:45.591152-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:45.591152-06:00","labels":["api","backend"],"dependencies":[{"issue_id":"test-e7t4s2","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:08:45.815419-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4s2","depends_on_id":"test-e7t4s1","type":"blocks","created_at":"2026-01-30T12:10:10.169921-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s3","title":"Build team list and team detail UI components","description":"Create TeamList component showing all teams in org with member count, leader name, and quick actions. Create TeamDetail page with: team info header (name, leader dropdown), member list table with role badges and remove button, settings form showing inherited values with override toggles. Use React Query for data fetching. Include empty states and loading skeletons.\n\n**Context:** Team leads need quick visibility into their team composition. Brokerage owners need to manage multiple teams. Settings UI must clearly show what's inherited vs overridden.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:46.168298-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:46.168298-06:00","labels":["frontend","ui"],"dependencies":[{"issue_id":"test-e7t4s3","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:08:46.316251-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4s3","depends_on_id":"test-e7t4s2","type":"blocks","created_at":"2026-01-30T12:10:10.453868-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t4s4","title":"Add drag-drop member assignment and verify complete team management flow","description":"Implement drag-drop interface for assigning agents to teams using @dnd-kit/core. Show unassigned agents pool and team drop zones. Handle optimistic updates with rollback on error. Test complete flow: create team  assign leader  drag agents to team  configure team settings  verify settings inheritance applies to team members.\n\n**Context:** Drag-drop makes bulk team assignment fast for brokerages onboarding many agents. This final subtask ensures the entire team management feature works end-to-end.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:46.746952-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:46.746952-06:00","labels":["feature","frontend","ui"],"dependencies":[{"issue_id":"test-e7t4s4","depends_on_id":"test-e7t4","type":"parent-child","created_at":"2026-01-30T12:08:46.896282-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t4s4","depends_on_id":"test-e7t4s3","type":"blocks","created_at":"2026-01-30T12:10:10.720994-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5","title":"Implement role-based permissions and agent management","description":"Build permission system where broker sees all agents/data, team_lead sees only their team, agent sees only themselves. Include agent activation/deactivation controls and agent preference management (timezone, quiet hours, voice gender, auto-call opt-out).\n\n**Context:** Proper access control is essential for brokerages - agents shouldn't see each other's performance, but brokers need the full picture. Agent preferences ensure calls happen at appropriate times and with preferred settings.","design":"Permission checks on all queries: getAgents(), getCallLogs(), getMetrics() filter by role. Use Clerk roles (broker, team_lead, agent). Agent status: active, inactive, suspended. Preferences stored on agent profile: timezone, quiet_hours (start/end), voice_gender (male/female), auto_call_enabled. Quiet hours checked before any outbound call.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:11.457094-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:11.457094-06:00","labels":["backend","frontend","permissions","security"],"dependencies":[{"issue_id":"test-e7t5","depends_on_id":"test-e7","type":"parent-child","created_at":"2026-01-30T12:07:11.597627-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5","depends_on_id":"test-e7t3","type":"blocks","created_at":"2026-01-30T12:10:11.444795-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5","depends_on_id":"test-e7t4","type":"blocks","created_at":"2026-01-30T12:10:11.696406-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s1","title":"Create role-based permission types and utility functions","description":"Define TypeScript types for user roles (broker, team_lead, agent) and agent status (active, inactive, suspended). Create permission utility functions that determine data access: canViewAgent(viewerRole, viewerId, targetAgentId), canViewTeam(viewerRole, teamId), getVisibleAgentIds(role, userId). Integrate with Clerk's role metadata. Include agent preferences type: timezone, quiet_hours {start, end}, voice_gender ('male'|'female'), auto_call_enabled.\n\n**Context:** Foundation for all permission checks. Brokers see everything, team leads see their team, agents see only themselves. These utilities will be used across all data-fetching functions.\n\n**Testing Requirements:**\n- **Unit Tests:** Permission functions return correct access for each role; Edge cases: user viewing themselves, team lead viewing agent outside team","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:47.469114-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:47.469114-06:00","labels":["backend","security"],"dependencies":[{"issue_id":"test-e7t5s1","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:08:47.626415-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s2","title":"Implement permission-filtered data queries","description":"Wrap existing data queries with permission checks: getAgents() filters by role visibility, getCallLogs() only returns logs for visible agents, getMetrics() aggregates only accessible data. Add brokerage_id and team_id to agent records if not present. Create getAgentProfile() for preferences. All queries should accept the current user context and filter appropriately.\n\n**Context:** This is where the rubber meets the road - every data access point must respect the role hierarchy. A team lead querying call logs must only see their team's calls.\n\n**Testing Requirements:**\n- **Unit Tests:** Broker sees all agents; Team lead sees only team members; Agent sees only self; Invalid access attempts return empty/error\n- **Integration Tests:** End-to-end query with different role contexts","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:48.062478-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:48.062478-06:00","labels":["backend","database","security"],"dependencies":[{"issue_id":"test-e7t5s2","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:08:48.932062-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s2","depends_on_id":"test-e7t5s1","type":"blocks","created_at":"2026-01-30T12:10:11.944838-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s3","title":"Build agent management API endpoints","description":"Create tRPC/API routes for agent management: updateAgentStatus(agentId, status) - only broker/team_lead can change, updateAgentPreferences(agentId, prefs) - agent can update own or admin override, getAgentPreferences(agentId). Add quiet hours validation helper: isWithinQuietHours(agentId) to check before outbound calls. Ensure all endpoints verify caller has permission to modify target agent.\n\n**Context:** Brokers need to activate/deactivate agents (offboarding, performance issues). Agents need control over their call preferences - calling during quiet hours would be a terrible user experience.\n\n**Testing Requirements:**\n- **Unit Tests:** Status changes persist correctly; Preferences update and retrieve; Quiet hours calculation works across timezones\n- **Integration Tests:** Full flow: broker deactivates agent, agent can't receive calls; Quiet hours block outbound call initiation","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:49.194649-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:49.194649-06:00","labels":["api","backend"],"dependencies":[{"issue_id":"test-e7t5s3","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:08:49.4147-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s3","depends_on_id":"test-e7t5s1","type":"blocks","created_at":"2026-01-30T12:10:12.165537-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s3","depends_on_id":"test-e7t5s2","type":"blocks","created_at":"2026-01-30T12:10:12.549305-06:00","created_by":"David Habedank"}]}
{"id":"test-e7t5s4","title":"Add permission checks to existing UI and verify end-to-end","description":"Update dashboard components to use permission-filtered queries. Add agent management UI section for brokers/team leads: agent list with status toggles, preference editor for each agent. Add preferences panel for agents to edit their own settings. Verify the complete flow: login as broker (see all), login as team lead (see team only), login as agent (see self only). Test status changes and preference updates.\n\n**Context:** Users need to actually see and interact with these controls. The UI must reflect what each role is allowed to see and do - a team lead shouldn't even see the 'manage all agents' button.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:49.678206-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:49.678206-06:00","labels":["frontend","testing"],"dependencies":[{"issue_id":"test-e7t5s4","depends_on_id":"test-e7t5","type":"parent-child","created_at":"2026-01-30T12:08:49.851284-06:00","created_by":"David Habedank"},{"issue_id":"test-e7t5s4","depends_on_id":"test-e7t5s3","type":"blocks","created_at":"2026-01-30T12:10:12.741868-06:00","created_by":"David Habedank"}]}
{"id":"test-e8","title":"Brokerage Dashboard \u0026 Visibility","description":"Build the management dashboard for brokers and team leads with activity feeds, pipeline overview, agent summaries, stale lead alerts, and check-in compliance reports.\n\n**Context:** Pipeline visibility is the killer feature for brokers - they pay for RealHerd to finally see what their agents are doing. The dashboard must provide actionable insights.","acceptance_criteria":"- Activity feed shows recent calls across org/team with filtering\n- Pipeline overview displays leads by stage and temperature\n- Agent activity summary shows calls made, leads updated, compliance\n- Stale lead alerts highlight leads needing attention\n- Check-in compliance report shows who's taking calls\n- Filtering by agent, date range, lead temperature, call type\n- Export capabilities for reports\n- Mobile-responsive design\n- Agent view shows personal call history, transcripts, upcoming check-ins","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":2400,"created_at":"2026-01-30T12:06:57.169067-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:57.169067-06:00","labels":["dashboard","reporting","visibility"],"dependencies":[{"issue_id":"test-e8","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:10:12.966207-06:00","created_by":"David Habedank"},{"issue_id":"test-e8","depends_on_id":"test-e4","type":"blocks","created_at":"2026-01-30T12:10:13.432554-06:00","created_by":"David Habedank"},{"issue_id":"test-e8","depends_on_id":"test-e6","type":"blocks","created_at":"2026-01-30T12:10:13.616512-06:00","created_by":"David Habedank"},{"issue_id":"test-e8","depends_on_id":"test-e7","type":"blocks","created_at":"2026-01-30T12:10:13.810164-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1","title":"Build activity feed component with real-time updates","description":"Create the core activity feed that shows recent calls across the organization/team. Must support real-time updates via Convex subscriptions, filtering by agent/date range/call type, and pagination for historical data.\n\n**Context:** The activity feed is the broker's window into what's happening NOW. This is what they check first thing in the morning and throughout the day. Real-time updates are critical - brokers want to see calls appearing live, not refreshing to check.","design":"Use Convex useQuery with real-time subscriptions for live updates. Build a reusable ActivityFeedItem component. Implement filter state with URL params for shareability. Consider virtualized list for performance with large datasets. Filters: agent dropdown (populated from team members), date picker, call type (inbound/outbound/check-in).","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:11.739183-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:11.739183-06:00","labels":["convex","dashboard","frontend","real-time"],"dependencies":[{"issue_id":"test-e8t1","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:07:11.872487-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s1","title":"Create Convex query with real-time subscription for activity feed","description":"Build the Convex query function that fetches recent calls with real-time subscriptions. Query should support: filtering by agentId, dateRange (start/end timestamps), callType (inbound/outbound/check-in), and pagination with cursor-based approach. Return call data with agent name, contact info, call duration, outcome, and timestamp. Ensure proper indexing for performance.\n\n**Context:** Real-time updates are critical - brokers want to see calls appearing live without refreshing. This query powers the entire activity feed and must be efficient for organizations with 20-100 agents generating many calls daily.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:50.132982-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:50.132982-06:00","labels":["backend","convex","real-time"],"dependencies":[{"issue_id":"test-e8t1s1","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:08:50.314153-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s2","title":"Build reusable ActivityFeedItem component","description":"Create a polished ActivityFeedItem component that displays: agent avatar/name, contact name with link to profile, call type badge (inbound/outbound/check-in with distinct colors), call duration, timestamp (relative like '2 min ago'), and call outcome/notes preview. Include hover state showing full notes. Use consistent styling with the dashboard theme. Component should accept a single call object as prop.\n\n**Context:** This is what brokers look at dozens of times per day - it needs to be scannable, information-dense but not cluttered. The component will be reused in the main feed and potentially in agent detail views.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:50.536366-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:50.536366-06:00","labels":["component","frontend","ui"],"dependencies":[{"issue_id":"test-e8t1s2","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:08:50.704498-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s2","depends_on_id":"test-e8t1s1","type":"blocks","created_at":"2026-01-30T12:10:14.08813-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s3","title":"Implement filter controls with URL param state","description":"Build filter bar with: agent dropdown (populated from team members via Convex query), date range picker (today/yesterday/last 7 days/custom), and call type multi-select (inbound/outbound/check-in). Sync all filter state bidirectionally with URL search params using nuqs or similar. Filters should persist on page refresh and be shareable via URL. Include clear filters button.\n\n**Context:** URL params enable brokers to share specific views with team leads ('look at John's calls from last week') and maintain context when refreshing. This is a power-user feature that saves time.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:50.942459-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:50.942459-06:00","labels":["frontend","state-management","ux"],"dependencies":[{"issue_id":"test-e8t1s3","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:08:51.065478-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s3","depends_on_id":"test-e8t1s1","type":"blocks","created_at":"2026-01-30T12:10:14.286235-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t1s4","title":"Assemble ActivityFeed with virtualization and pagination","description":"Create the main ActivityFeed component that combines: useQuery subscription for real-time data, ActivityFeedItem list rendering, filter controls, infinite scroll pagination (load more on scroll to bottom), and empty states. Implement virtualized list using @tanstack/react-virtual or similar for performance with 500+ items. Add loading skeleton states. Handle new items appearing at top with smooth animation or 'New activity' banner option.\n\n**Context:** Performance is critical - a brokerage with 50 agents making 10 calls/day each creates 500 daily entries. The feed must stay snappy. The 'new activity' indicator prevents jarring list jumps while keeping users informed.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:51.309375-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:51.309375-06:00","labels":["frontend","integration","performance"],"dependencies":[{"issue_id":"test-e8t1s4","depends_on_id":"test-e8t1","type":"parent-child","created_at":"2026-01-30T12:08:51.451878-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s4","depends_on_id":"test-e8t1s2","type":"blocks","created_at":"2026-01-30T12:10:14.475041-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t1s4","depends_on_id":"test-e8t1s3","type":"blocks","created_at":"2026-01-30T12:10:14.645502-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2","title":"Implement pipeline overview with stage/temperature visualization","description":"Build the pipeline view showing leads grouped by stage and colored by temperature. Display counts, allow drill-down to lead lists, and show movement trends (leads moving forward vs stuck).\n\n**Context:** Pipeline visibility is THE killer feature - brokers pay for RealHerd to see what their agents are doing. This view answers 'how healthy is our pipeline?' at a glance. Stage progression and temperature distribution tell the broker where to focus coaching.","design":"Kanban-style board or funnel visualization for stages. Color coding for temperature (hot=red, warm=orange, cold=blue). Click stage to see lead list. Show delta indicators () for week-over-week changes. Use Convex aggregation queries for counts. Consider chart.js or recharts for trend visualization.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:12.044328-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:12.044328-06:00","labels":["convex","dashboard","frontend","visualization"],"dependencies":[{"issue_id":"test-e8t2","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:07:12.150117-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2","depends_on_id":"test-e8t1","type":"blocks","created_at":"2026-01-30T12:10:14.841032-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s1","title":"Create pipeline data aggregation queries in Convex","description":"Build Convex queries to aggregate leads by stage and temperature. Create `getPipelineStats` query that returns: counts per stage (lead, contacted, qualified, showing, offer, closed, lost), counts per temperature (hot, warm, cold) within each stage, and week-over-week deltas. Include filters for brokerage_id and optional agent_id. Use Convex indexes efficiently for aggregation.\n\n**Context:** The pipeline view needs real-time aggregated data. Efficient queries are critical since brokers will load this view frequently. Week-over-week deltas help identify trends (improving vs declining pipeline health).","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:51.657396-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:51.657396-06:00","labels":["backend","convex","queries"],"dependencies":[{"issue_id":"test-e8t2s1","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:08:51.778767-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s2","title":"Build pipeline stage visualization component","description":"Create a Kanban-style or funnel visualization component showing all pipeline stages as columns/sections. Each stage shows: count badge, temperature distribution (colored segments or mini-bars), and delta indicator ( with week-over-week change). Use color coding: hot=red/rose, warm=orange/amber, cold=blue. Make stages clickable for drill-down. Use shadcn Card components and Tailwind for styling.\n\n**Context:** This is the primary visual that brokers see - it must communicate pipeline health at a glance. The temperature coloring lets them instantly spot where hot leads are concentrated and where cold leads might need attention or cleanup.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:51.982512-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:51.982512-06:00","labels":["frontend","react","visualization"],"dependencies":[{"issue_id":"test-e8t2s2","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:08:52.145635-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s2","depends_on_id":"test-e8t2s1","type":"blocks","created_at":"2026-01-30T12:10:15.059652-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s3","title":"Add trend chart for pipeline movement","description":"Integrate recharts (lightweight, React-native) to show a 30-day trend line of leads moving forward vs stuck. Create a simple area or line chart showing: leads advancing stages (positive), leads going cold or lost (negative). Add tooltip on hover showing exact counts. Query should fetch historical snapshots or calculate from activity log. Keep chart minimal - this is secondary to the main pipeline view.\n\n**Context:** Trends answer 'are things getting better or worse?' A broker seeing consistent forward movement knows their team is performing. Flatline or negative trends trigger coaching conversations.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:52.356244-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:52.356244-06:00","labels":["charts","frontend","recharts"],"dependencies":[{"issue_id":"test-e8t2s3","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:08:52.53062-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s3","depends_on_id":"test-e8t2s1","type":"blocks","created_at":"2026-01-30T12:10:15.309979-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t2s4","title":"Wire up drill-down navigation and verify end-to-end","description":"Connect stage clicks to navigate to filtered lead list (route: /leads?stage=qualified). Pass stage and optional temperature as query params. Ensure back navigation returns to pipeline view. Add loading states to pipeline view while queries run. Test complete flow: load pipeline  click stage  see filtered leads  back to pipeline. Verify real-time updates when leads change stage in another tab.\n\n**Context:** The drill-down is how brokers take action - seeing '12 cold leads in Showing stage' is useless if they can't immediately see WHO those leads are. Seamless navigation makes the dashboard actionable rather than just informational.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:52.778344-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:52.778344-06:00","labels":["frontend","integration","navigation"],"dependencies":[{"issue_id":"test-e8t2s4","depends_on_id":"test-e8t2","type":"parent-child","created_at":"2026-01-30T12:08:53.04457-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s4","depends_on_id":"test-e8t2s2","type":"blocks","created_at":"2026-01-30T12:10:15.508307-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t2s4","depends_on_id":"test-e8t2s3","type":"blocks","created_at":"2026-01-30T12:10:15.706257-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3","title":"Create agent activity summary with compliance metrics","description":"Build agent summary cards/table showing per-agent metrics: calls made, leads updated, check-in compliance rate, and last activity. Support sorting and filtering to identify top performers and those needing attention.\n\n**Context:** This answers the broker's question: 'Who's working and who's coasting?' Compliance metrics show which agents are actually doing the check-in calls vs letting AI handle everything. Brokers use this for coaching conversations and commission discussions.","design":"Table view with sortable columns. Summary cards for quick visual scan. Compliance = (completed check-ins / scheduled check-ins) * 100. Include sparklines for 7-day activity trend. Clicking agent name drills into their detailed view. Role-based: broker sees all agents, team_lead sees their team only.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:12.302977-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:12.302977-06:00","labels":["convex","dashboard","frontend","metrics"],"dependencies":[{"issue_id":"test-e8t3","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:07:12.531322-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3","depends_on_id":"test-e8t1","type":"blocks","created_at":"2026-01-30T12:10:15.987143-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s1","title":"Create TypeScript types and interfaces for agent activity metrics","description":"Define TypeScript interfaces for agent activity data: AgentActivitySummary (agent_id, name, calls_made, leads_updated, scheduled_checkins, completed_checkins, compliance_rate, last_activity_at, daily_activity_counts[]), AgentActivityFilters (date_range, team_id, min_compliance, sort_by, sort_order), and API response types. Include role-based visibility types (broker sees all, team_lead sees team only).\n\n**Context:** Strong typing ensures consistent data flow from API to UI. These types define the contract between backend metrics calculations and frontend display components.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:53.281961-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:53.281961-06:00","labels":["frontend","types"],"dependencies":[{"issue_id":"test-e8t3s1","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:08:53.49279-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s2","title":"Build agent activity API endpoint with role-based filtering","description":"Create GET /api/dashboard/agent-activity endpoint that: 1) Queries check-in logs, call records, and lead updates per agent, 2) Calculates compliance rate as (completed_checkins / scheduled_checkins) * 100, 3) Aggregates 7-day daily activity counts for sparklines, 4) Applies role-based filtering (broker: all agents in brokerage, team_lead: only their team members), 5) Supports sorting by any metric column and filtering by date range/min compliance. Use Supabase RLS for security.\n\n**Context:** This endpoint powers the entire agent summary view. Role-based filtering is critical - brokers should never see agents from other brokerages, team leads should only see their direct reports.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:53.686962-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:53.686962-06:00","labels":["api","backend","security"],"dependencies":[{"issue_id":"test-e8t3s2","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:08:53.903578-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s2","depends_on_id":"test-e8t3s1","type":"blocks","created_at":"2026-01-30T12:10:16.211151-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s3","title":"Build AgentActivityTable component with sorting, filtering, and sparklines","description":"Create React component with: 1) Sortable table columns (Agent Name, Calls Made, Leads Updated, Compliance %, Last Activity), 2) Summary cards at top showing quick stats (total agents, avg compliance, agents needing attention), 3) Inline sparkline charts showing 7-day activity trend per agent, 4) Filter controls for date range and minimum compliance threshold, 5) Row click handler to navigate to agent detail view, 6) Visual indicators for compliance (green \u003e80%, yellow 50-80%, red \u003c50%). Use TanStack Table for sorting/filtering logic.\n\n**Context:** This is the primary interface for brokers to answer 'who's working and who's coasting?' Quick visual scanning via summary cards and color-coded compliance helps identify coaching targets immediately.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:08:54.079762-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:54.079762-06:00","labels":["component","dashboard","frontend"],"dependencies":[{"issue_id":"test-e8t3s3","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:08:54.224241-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s3","depends_on_id":"test-e8t3s1","type":"blocks","created_at":"2026-01-30T12:10:16.416918-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s3","depends_on_id":"test-e8t3s2","type":"blocks","created_at":"2026-01-30T12:10:16.608341-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t3s4","title":"Integrate agent activity summary into dashboard and verify end-to-end","description":"Wire AgentActivityTable into main dashboard layout. Connect to API endpoint with React Query for data fetching and caching. Add loading skeletons and error states. Test complete flow: 1) Login as broker, verify all agents visible, 2) Login as team_lead, verify only team members visible, 3) Test all sorting options, 4) Test filter combinations, 5) Click agent row and verify navigation to detail view works. Run dev server and manually verify the feature.\n\n**Context:** Integration testing catches issues that unit tests miss - especially role-based visibility and navigation flows. This validates the complete user journey for the broker's primary use case.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:54.388369-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:54.388369-06:00","labels":["frontend","integration","testing"],"dependencies":[{"issue_id":"test-e8t3s4","depends_on_id":"test-e8t3","type":"parent-child","created_at":"2026-01-30T12:08:54.528593-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t3s4","depends_on_id":"test-e8t3s3","type":"blocks","created_at":"2026-01-30T12:10:16.876469-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4","title":"Build stale lead alerts and check-in compliance report","description":"Create alerting components that highlight: leads with no activity in X days (stale), missed check-ins, and declining temperature trends. Build exportable compliance report showing scheduled vs completed check-ins by agent/date.\n\n**Context:** Stale lead alerts are the early warning system - a lead going cold is recoverable, a forgotten lead is lost. The compliance report is what brokers use in weekly team meetings and for documenting performance issues. Export to CSV is non-negotiable for their existing processes.","design":"Stale threshold configurable (default 7 days). Alert badges on dashboard with drill-down lists. Compliance report as separate page with date range selector. Export function generates CSV with headers matching their existing spreadsheets. Consider email digest option (future enhancement).","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":300,"created_at":"2026-01-30T12:07:12.676189-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:12.676189-06:00","labels":["convex","dashboard","export","frontend","reporting"],"dependencies":[{"issue_id":"test-e8t4","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:07:12.793078-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4","depends_on_id":"test-e8t3","type":"blocks","created_at":"2026-01-30T12:10:17.0911-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s1","title":"Create stale lead detection query and configurable threshold settings","description":"Build database query to identify leads with no activity (notes, status changes, temperature updates) within configurable days threshold. Create settings interface for threshold configuration (default 7 days). Query should return lead details plus days_since_activity and last_activity_type.\n\n**Context:** Stale lead detection is the foundation for alerts - without accurate detection, the alerting system provides false confidence. Configurable threshold accommodates different brokerage pacing expectations.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:54.694556-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:54.694556-06:00","labels":["backend","database"],"dependencies":[{"issue_id":"test-e8t4s1","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:08:54.842839-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s2","title":"Build alert badge components and drill-down list views","description":"Create alert badge components showing counts for: stale leads (no activity \u003e threshold), missed check-ins (scheduled but not completed), declining temperature trends (2+ consecutive drops). Build drill-down list views accessible from each badge with lead details and quick action buttons.\n\n**Context:** Alert badges are the visual early warning system on the dashboard. Drill-down enables immediate action - seeing '12 stale leads' is useless without being able to click through and address them.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:55.015205-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:55.015205-06:00","labels":["components","frontend"],"dependencies":[{"issue_id":"test-e8t4s2","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:08:55.157618-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4s2","depends_on_id":"test-e8t4s1","type":"blocks","created_at":"2026-01-30T12:10:17.306576-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s3","title":"Create check-in compliance report page with date range selector","description":"Build dedicated compliance report page showing scheduled vs completed check-ins aggregated by agent and date. Include date range selector (week/month/custom). Display completion percentage, missed check-ins list, and trends. This is what brokers review in weekly team meetings.\n\n**Context:** The compliance report is the broker's management tool - it's the documented evidence of agent performance. Must be clear enough to discuss in meetings and defensible for HR documentation.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:55.356613-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:55.356613-06:00","labels":["frontend","reporting"],"dependencies":[{"issue_id":"test-e8t4s3","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:08:55.516276-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4s3","depends_on_id":"test-e8t4s1","type":"blocks","created_at":"2026-01-30T12:10:17.505625-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t4s4","title":"Implement CSV export with headers matching existing spreadsheet format","description":"Add export function to compliance report that generates CSV file. Headers must match their existing spreadsheet format: Agent Name, Date, Scheduled Check-ins, Completed Check-ins, Completion Rate, Missed Leads. Include date range in filename. Test download works in all supported browsers.\n\n**Context:** CSV export is non-negotiable - brokerages have existing processes built around spreadsheets. If export doesn't match their format, they'll manually reformat every week, breeding resentment.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":45,"created_at":"2026-01-30T12:08:55.812915-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:55.812915-06:00","labels":["export","frontend"],"dependencies":[{"issue_id":"test-e8t4s4","depends_on_id":"test-e8t4","type":"parent-child","created_at":"2026-01-30T12:08:55.960217-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t4s4","depends_on_id":"test-e8t4s3","type":"blocks","created_at":"2026-01-30T12:10:17.668475-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5","title":"Build agent personal view with call history and transcripts","description":"Create the agent-facing dashboard showing their personal call history, full transcripts with playback, upcoming scheduled check-ins, and their own performance metrics. This is what agents see when they log in.\n\n**Context:** Agents need their own view - they shouldn't see org-wide data, just their leads and calls. The transcript access helps them remember conversations and prepare for follow-ups. Upcoming check-ins are their daily to-do list.","design":"Reuse activity feed component filtered to current user. Transcript viewer with audio player (Telnyx recordings). Upcoming check-ins as sortable list with lead context. Personal stats card showing their metrics. Mobile-first since agents are often on phones between showings.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:13.293372-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:13.293372-06:00","labels":["agent-view","convex","dashboard","frontend","mobile"],"dependencies":[{"issue_id":"test-e8t5","depends_on_id":"test-e8","type":"parent-child","created_at":"2026-01-30T12:07:13.458023-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5","depends_on_id":"test-e8t1","type":"blocks","created_at":"2026-01-30T12:10:18.355664-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5","depends_on_id":"test-e8t3","type":"blocks","created_at":"2026-01-30T12:10:18.546814-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s1","title":"Create agent dashboard page layout and personal stats card","description":"Build the main agent dashboard page at /agent/dashboard with mobile-first responsive layout. Create a PersonalStatsCard component showing agent-specific metrics: total calls made, leads assigned, conversion rate, and upcoming check-ins count. Use existing UI components (Card, stats display patterns). Fetch stats from API filtered to current authenticated user only.\n\n**Context:** This establishes the agent's home view - distinct from the org-wide broker dashboard. Stats card gives agents quick visibility into their own performance without exposing org data. Mobile-first is critical since agents check between showings.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:56.142737-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:56.142737-06:00","labels":["dashboard","frontend"],"dependencies":[{"issue_id":"test-e8t5s1","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:08:56.61377-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s2","title":"Add filtered activity feed for agent's own call history","description":"Reuse the existing ActivityFeed component from the broker dashboard but configure it to filter exclusively to the current authenticated user's calls. Add API endpoint or query parameter to filter calls by agent_id. Display call history with lead name, call duration, outcome, and timestamp. Include pagination for agents with high call volumes.\n\n**Context:** Reusing the activity feed component reduces code duplication and ensures visual consistency. The filter ensures agents see only their leads and calls - this is a privacy/data isolation requirement, not just UX preference.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:08:56.835339-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:56.835339-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e8t5s2","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:08:57.084082-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5s2","depends_on_id":"test-e8t5s1","type":"blocks","created_at":"2026-01-30T12:10:18.839085-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s3","title":"Build transcript viewer with Telnyx audio playback","description":"Create TranscriptViewer component that displays full call transcripts with speaker labels (agent vs lead). Integrate Telnyx recording playback using their audio URL format. Add playback controls (play/pause, seek, speed adjustment). Sync transcript text highlighting with audio position if timestamps are available. Include call metadata header (date, duration, lead info).\n\n**Context:** Transcript access helps agents remember conversation details and prepare for follow-ups. Audio playback is essential for reviewing tone and catching details the transcript might miss. This is a key retention feature - agents value being able to reference past conversations.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:08:57.464282-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:57.464282-06:00","labels":["frontend","integration"],"dependencies":[{"issue_id":"test-e8t5s3","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:08:57.688723-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5s3","depends_on_id":"test-e8t5s2","type":"blocks","created_at":"2026-01-30T12:10:19.064726-06:00","created_by":"David Habedank"}]}
{"id":"test-e8t5s4","title":"Add upcoming check-ins list with lead context and sorting","description":"Create UpcomingCheckIns component showing scheduled follow-up calls as a sortable list. Display lead name, phone, property interest, scheduled time, and last contact summary. Add sorting options (by date, by lead priority). Include quick actions: call now, reschedule, mark complete. Link each item to lead detail view. This becomes the agent's daily to-do list.\n\n**Context:** Upcoming check-ins are the agent's daily workflow - what calls to make today. Including lead context (property interest, last conversation) helps agents prepare without opening multiple screens. Quick actions reduce friction for the most common tasks.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:58.051562-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:58.051562-06:00","labels":["frontend","workflow"],"dependencies":[{"issue_id":"test-e8t5s4","depends_on_id":"test-e8t5","type":"parent-child","created_at":"2026-01-30T12:08:58.213563-06:00","created_by":"David Habedank"},{"issue_id":"test-e8t5s4","depends_on_id":"test-e8t5s1","type":"blocks","created_at":"2026-01-30T12:10:19.264727-06:00","created_by":"David Habedank"}]}
{"id":"test-e9","title":"Polish \u0026 Production Readiness","description":"Final polish including onboarding flows, empty states with Shep mascot, error handling, loading states, settings pages, help integration, and performance optimization.\n\n**Context:** A new brokerage should be able to go live within 30 minutes. Polish and onboarding flows are what make the difference between a demo and a product.","acceptance_criteria":"- Org setup onboarding flow guides broker through FUB connection and settings\n- Agent setup onboarding explains what to expect\n- Empty states feature Shep mascot with helpful messages\n- Error handling provides clear recovery paths\n- Loading states are smooth and branded\n- Settings pages for org, team, and personal preferences\n- Help/support integration\n- Performance optimized: fast page loads, real-time updates\n- New brokerage can complete setup in under 30 minutes","status":"open","priority":1,"issue_type":"epic","owner":"david@habedank.org","estimated_minutes":1920,"created_at":"2026-01-30T12:06:57.386175-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:06:57.386175-06:00","labels":["onboarding","polish","production","ux"],"dependencies":[{"issue_id":"test-e9","depends_on_id":"test-e1","type":"blocks","created_at":"2026-01-30T12:10:19.496303-06:00","created_by":"David Habedank"},{"issue_id":"test-e9","depends_on_id":"test-e7","type":"blocks","created_at":"2026-01-30T12:10:19.699137-06:00","created_by":"David Habedank"},{"issue_id":"test-e9","depends_on_id":"test-e8","type":"blocks","created_at":"2026-01-30T12:10:19.96163-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1","title":"Build org setup onboarding wizard","description":"Create a multi-step onboarding flow that guides new brokerage owners through initial setup: connecting Follow Up Boss, configuring org settings, inviting team members, and understanding key features. Include progress indicators, skip/back navigation, and completion celebration.\n\n**Context:** A new brokerage should be able to go live within 30 minutes. The onboarding wizard is the critical path to achieving this - it must be intuitive enough that brokers don't need support calls to get started. This directly impacts customer acquisition and reduces churn from failed setups.","design":"Use a wizard pattern with distinct steps: 1) Welcome/org name, 2) FUB API connection with validation, 3) Basic settings (timezone, business hours), 4) Invite team members, 5) Success/next steps. Store progress in Convex so users can resume. Include inline help tooltips. Consider using shadcn/ui Stepper or custom progress component.","status":"open","priority":0,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:07:14.099457-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:14.099457-06:00","labels":["frontend","onboarding","ux"],"dependencies":[{"issue_id":"test-e9t1","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:07:14.246995-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s1","title":"Create wizard state management and progress persistence","description":"Build the core wizard infrastructure: 1) Create Convex schema for onboarding_progress table with fields: orgId, currentStep, completedSteps[], stepData (JSON for each step's saved data), startedAt, lastUpdatedAt. 2) Create mutations: saveWizardProgress, completeStep, skipStep. 3) Create queries: getOnboardingProgress, isOnboardingComplete. 4) Build React context/hook (useOnboardingWizard) that manages local wizard state, syncs to Convex, handles navigation (next/back/skip), and enables resume from last position on page reload.\n\n**Context:** Progress persistence is critical - if a user closes their browser mid-setup or gets interrupted, they must be able to resume exactly where they left off. This reduces abandonment and frustration during the critical first-time experience.\n\n**Testing Requirements:**\n- **Unit Tests:** saveWizardProgress correctly updates Convex; getOnboardingProgress returns correct step on reload; skip step marks step as skipped but allows progression\n- **Integration Tests:** Full flow: start wizard, complete 2 steps, reload page, verify resume at step 3","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:08:58.447515-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:58.447515-06:00","labels":["backend","convex","frontend"],"dependencies":[{"issue_id":"test-e9t1s1","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:08:58.57987-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s2","title":"Build wizard UI shell with step navigation and progress indicator","description":"Create the visual wizard container: 1) WizardShell component with header showing org name, progress stepper, and step content area. 2) Progress indicator showing 5 steps with icons: Welcome, Connect CRM, Settings, Team, Complete. Use shadcn/ui components or custom stepper with completed/current/upcoming states. 3) Navigation footer with Back, Skip (where allowed), and Next/Continue buttons. 4) Step transition animations (fade or slide). 5) Responsive design - works on tablet for brokers setting up on-the-go. Wire to useOnboardingWizard hook from 9.1.1.\n\n**Context:** The wizard UI must feel polished and trustworthy - first impressions matter. Clear progress indication reduces anxiety ('how much longer?') and skip options prevent users from getting stuck on optional steps.\n\n**Testing Requirements:**\n- **Unit Tests:** Progress indicator shows correct step highlighted; Back button disabled on step 1; Skip button hidden on required steps\n- **Integration Tests:** Navigate through all steps, verify progress updates","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:08:58.814418-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:58.814418-06:00","labels":["frontend","ui"],"dependencies":[{"issue_id":"test-e9t1s2","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:08:59.41137-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t1s2","depends_on_id":"test-e9t1s1","type":"blocks","created_at":"2026-01-30T12:10:20.198624-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s3","title":"Implement wizard step content components","description":"Build the 5 step components: 1) WelcomeStep: org name input with validation, friendly welcome message explaining what's coming. 2) ConnectFUBStep: API key input field, 'Test Connection' button that validates against FUB API, success/error states with helpful troubleshooting tips, link to FUB docs for finding API key. 3) SettingsStep: timezone dropdown (auto-detect default), business hours picker (start/end time for each day). 4) InviteTeamStep: email input with add/remove, role selector (admin/agent), optional - can skip. 5) SuccessStep: celebration animation (confetti or checkmark), summary of what was configured, clear CTA buttons for 'View Dashboard' and 'Import First Contacts'. Each step saves data to wizard context on completion.\n\n**Context:** Each step must be self-contained and accomplishable in under 5 minutes. The FUB connection step is highest-friction - inline help and clear error messages are essential. The celebration at the end creates positive emotional association with the product.\n\n**Testing Requirements:**\n- **Unit Tests:** Org name validates minimum length; FUB API test shows error for invalid key; Timezone auto-detects correctly\n- **Integration Tests:** Complete full wizard flow with valid data, verify all data persisted to Convex","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:08:59.694134-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:08:59.694134-06:00","labels":["frontend","integration","ui"],"dependencies":[{"issue_id":"test-e9t1s3","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:08:59.89599-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t1s3","depends_on_id":"test-e9t1s2","type":"blocks","created_at":"2026-01-30T12:10:20.461383-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t1s4","title":"Add inline help, error handling, and completion flow","description":"Polish the wizard experience: 1) Add tooltip help icons next to complex fields (API key, business hours) with contextual explanations. 2) Implement comprehensive error handling: network failures show retry option, validation errors highlight specific fields, FUB connection errors provide specific troubleshooting (wrong key format, expired key, rate limited). 3) Add loading states for async operations (FUB validation, saving). 4) Create 'Resume Setup' banner that appears on dashboard if onboarding incomplete. 5) Track onboarding analytics: time per step, skip rates, drop-off points (for future optimization). 6) Test complete flow end-to-end and verify new org can start using RealHerd immediately after completion.\n\n**Context:** Error handling and help text are what separate a frustrating setup from a delightful one. Users who get stuck on errors without guidance will churn. Analytics help us identify and fix friction points over time.\n\n**Testing Requirements:**\n- **Unit Tests:** Error messages display correctly for each error type; Resume banner only shows when onboarding incomplete\n- **Integration Tests:** Simulate network failure mid-wizard, verify graceful recovery; Complete wizard, verify resume banner disappears, dashboard accessible","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:00.139906-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:00.139906-06:00","labels":["analytics","frontend","ux"],"dependencies":[{"issue_id":"test-e9t1s4","depends_on_id":"test-e9t1","type":"parent-child","created_at":"2026-01-30T12:09:00.305396-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t1s4","depends_on_id":"test-e9t1s3","type":"blocks","created_at":"2026-01-30T12:10:20.620435-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2","title":"Create empty states with Shep mascot","description":"Design and implement empty state components featuring Shep (the shepherd mascot) with contextual, helpful messages for all key views: no contacts, no calls scheduled, no team members, no tasks, etc. Each empty state should guide users toward the action that fills it.\n\n**Context:** Empty states are the first thing new users see after setup. They set the tone for the product and can either delight users or make the product feel broken. Shep as a friendly guide reinforces the 'herding your contacts' brand metaphor.","design":"Create a reusable EmptyState component that accepts: illustration variant (Shep poses), title, description, and optional CTA button. Design 5-6 Shep illustrations (welcoming, encouraging, celebrating, thinking). Use Tailwind animations for subtle movement. Messages should be warm and actionable, not generic 'no data'.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:14.441611-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:14.441611-06:00","labels":["design","frontend","ux"],"dependencies":[{"issue_id":"test-e9t2","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:07:14.711969-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2","depends_on_id":"test-e9t1","type":"blocks","created_at":"2026-01-30T12:10:20.895412-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s1","title":"Create reusable EmptyState component with Shep illustration system","description":"Build the base EmptyState component in components/ui/EmptyState.tsx that accepts: illustration variant (string for Shep pose), title (string), description (string), and optional CTA button (label + onClick). Create a ShepIllustration subcomponent that renders different SVG poses based on variant prop. Define TypeScript interfaces for all props. Use Tailwind for layout (centered flex column) and add subtle float/bounce animation using Tailwind's animate utilities.\n\n**Context:** This foundational component will be reused across all empty states in the app. Getting the API right means consistent UX and easy adoption by other devs. The Shep mascot system reinforces the 'herding your contacts' brand.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:00.649653-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:00.649653-06:00","labels":["design-system","frontend"],"dependencies":[{"issue_id":"test-e9t2s1","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:09:00.864452-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s2","title":"Design and implement 5 Shep illustration variants as SVG components","description":"Create 5 Shep pose illustrations as React SVG components: 1) 'welcoming' - Shep with open arms for first-time empty states, 2) 'encouraging' - Shep pointing forward for 'add your first X', 3) 'celebrating' - Shep jumping for success states, 4) 'thinking' - Shep with hand on chin for search-no-results, 5) 'relaxed' - Shep sitting for 'all caught up' states. Each SVG should be ~200x200px, use the brand color palette, and include animatable elements (ears, tail) via CSS classes.\n\n**Context:** These illustrations humanize empty states and turn potentially frustrating moments into delightful brand touchpoints. Variety prevents the app from feeling monotonous.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:09:03.02691-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:03.02691-06:00","labels":["design","frontend"],"dependencies":[{"issue_id":"test-e9t2s2","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:09:05.734985-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2s2","depends_on_id":"test-e9t2s1","type":"blocks","created_at":"2026-01-30T12:10:21.148632-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s3","title":"Implement contextual empty states for all key views","description":"Add EmptyState components to these views with Shep variant, warm/actionable copy, and relevant CTAs: 1) Contacts list - 'welcoming' Shep, 'Your herd starts here', CTA 'Add your first contact', 2) Call schedule - 'encouraging' Shep, 'No calls on the calendar', CTA 'Schedule a call', 3) Team members (for brokerages) - 'welcoming' Shep, 'Build your team', CTA 'Invite an agent', 4) Tasks - 'relaxed' Shep, 'All caught up!', no CTA, 5) Search results - 'thinking' Shep, 'No matches found', suggestion to adjust filters.\n\n**Context:** These are the first things new users see after setup. Each empty state should clearly guide users to the action that fills it, reducing confusion and accelerating time-to-value.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:06.745372-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:06.745372-06:00","labels":["frontend","ux"],"dependencies":[{"issue_id":"test-e9t2s3","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:09:06.91913-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2s3","depends_on_id":"test-e9t2s2","type":"blocks","created_at":"2026-01-30T12:10:21.3924-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t2s4","title":"Add Tailwind animations and verify all empty states render correctly","description":"Implement subtle Tailwind animations for Shep illustrations: gentle floating (translateY oscillation), ear wiggle on hover, and fade-in on mount. Add these as custom Tailwind animation utilities in tailwind.config.js if needed. Manually test each empty state by: 1) Creating fresh account, 2) Navigating to each view (contacts, calls, team, tasks), 3) Verifying correct Shep variant and copy displays, 4) Clicking CTAs and confirming navigation works, 5) Testing search empty state by entering non-matching query.\n\n**Context:** Animation adds polish that differentiates a demo from a product. Manual verification ensures the full user flow works as new users will experience it during the critical first 30 minutes.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:09:07.156965-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:07.156965-06:00","labels":["frontend","polish","testing"],"dependencies":[{"issue_id":"test-e9t2s4","depends_on_id":"test-e9t2","type":"parent-child","created_at":"2026-01-30T12:09:07.313895-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t2s4","depends_on_id":"test-e9t2s3","type":"blocks","created_at":"2026-01-30T12:10:21.623124-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3","title":"Implement error handling and loading states","description":"Create a comprehensive error boundary system with user-friendly error messages, retry mechanisms, and clear recovery paths. Build consistent loading states (skeletons, spinners) that match the RealHerd brand. Handle network failures, API errors, and edge cases gracefully.\n\n**Context:** Real estate agents often work on mobile with spotty connections. Error handling must help them recover without losing work. Professional error handling is what separates a polished product from a prototype.","design":"Create ErrorBoundary wrapper with fallback UI options (inline vs full-page). Build toast notification system for transient errors. Implement skeleton loaders matching actual content layout for key pages (contacts list, call queue, dashboard). Add retry buttons with exponential backoff. Use Convex's optimistic updates where possible. Error messages should explain what happened AND what to do.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":360,"created_at":"2026-01-30T12:07:15.052261-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:15.052261-06:00","labels":["error-handling","frontend","ux"],"dependencies":[{"issue_id":"test-e9t3","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:07:15.233704-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s1","title":"Create ErrorBoundary component with fallback UI options","description":"Build a React ErrorBoundary wrapper component that catches JavaScript errors in child components. Create two fallback UI modes: (1) inline error display for component-level failures (shows error card in place of failed component), and (2) full-page error display for critical failures (centered error message with RealHerd branding). Include 'Try Again' button that resets the error boundary state. Add error logging hook for future analytics integration. Style to match RealHerd brand (professional, reassuring tone).\n\n**Context:** Error boundaries prevent the entire app from crashing when one component fails. Real estate agents need to continue working even when parts of the UI have issues - they can't afford to lose a call or contact mid-workflow.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":60,"created_at":"2026-01-30T12:09:07.531177-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:07.531177-06:00","labels":["error-handling","frontend"],"dependencies":[{"issue_id":"test-e9t3s1","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:09:07.685289-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s2","title":"Build toast notification system for transient errors","description":"Implement a toast/snackbar notification system using a context provider pattern. Support types: error (red), warning (yellow), success (green), info (blue). Features: auto-dismiss after configurable duration (default 5s for errors, 3s for success), manual dismiss button, stack multiple toasts, persist important errors until dismissed. Create useToast() hook for easy triggering from any component. Include action button support (e.g., 'Retry' on network errors). Position toasts in bottom-right, mobile-responsive.\n\n**Context:** Transient errors like failed API calls need non-blocking notification so agents can continue their current task while being informed of issues. Toast notifications are less disruptive than modals for recoverable errors.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:09:07.947408-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:07.947408-06:00","labels":["error-handling","frontend"],"dependencies":[{"issue_id":"test-e9t3s2","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:09:08.185872-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s3","title":"Implement skeleton loaders for key pages","description":"Create skeleton loader components that match the actual content layout for: (1) ContactsList - rows with avatar circle, name rectangle, phone rectangle; (2) CallQueue - card skeletons with contact info and action button placeholders; (3) Dashboard - stat card skeletons, chart placeholder, recent activity list skeleton. Use subtle pulse animation (not harsh flash). Build reusable Skeleton primitives (SkeletonText, SkeletonAvatar, SkeletonCard, SkeletonButton) that can compose into page-specific loaders. Ensure skeletons have same dimensions as real content to prevent layout shift.\n\n**Context:** Skeleton loaders reduce perceived wait time and prevent jarring layout shifts. When an agent opens the app on a slow connection, they should immediately see the structure of the page loading rather than a blank screen or spinning wheel.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:08.408927-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:08.408927-06:00","labels":["frontend","loading-states"],"dependencies":[{"issue_id":"test-e9t3s3","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:09:08.571697-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t3s4","title":"Add retry mechanisms with exponential backoff and integrate error handling system","description":"Create a useRetry() hook that wraps async operations with: exponential backoff (1s, 2s, 4s, max 3 retries), automatic retry on network errors, manual retry trigger via returned function. Integrate with toast system to show 'Retrying...' and 'Retry failed' messages. Create a NetworkErrorBoundary that detects offline state (navigator.onLine + online/offline events) and shows appropriate UI with 'Retry when online' button. Wire ErrorBoundary and toast system to key data-fetching components (ContactsList, CallQueue, Dashboard). Ensure Convex queries show skeletons while loading and toast on failure.\n\n**Context:** Mobile connections are unreliable. Automatic retry with backoff handles temporary blips without user intervention, while manual retry gives agents control when automation fails. This is the final integration that ties error handling, loading states, and retry logic together.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:08.757306-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:08.757306-06:00","labels":["error-handling","frontend","integration"],"dependencies":[{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3","type":"parent-child","created_at":"2026-01-30T12:09:08.907971-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3s1","type":"blocks","created_at":"2026-01-30T12:10:21.860179-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3s2","type":"blocks","created_at":"2026-01-30T12:10:22.150683-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t3s4","depends_on_id":"test-e9t3s3","type":"blocks","created_at":"2026-01-30T12:10:22.36798-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4","title":"Build settings pages (org, team, personal)","description":"Create settings interfaces for all three levels: org settings (billing, FUB connection, global preferences), team settings (team-specific rules, lead assignment), and personal settings (notification preferences, working hours, voice settings). Include proper role-based access control.\n\n**Context:** Settings are where power users customize RealHerd to their workflow. Well-organized settings reduce support requests and increase stickiness. The three-tier structure (org/team/personal) matches the Clerk role hierarchy.","design":"Use tabbed interface within each settings level. Org settings: FUB reconnect, billing portal link, member management, default AI settings. Team settings: team roster, lead routing rules, team-specific prompts. Personal: notification channels, working hours for call routing, voice clone management. Auto-save with success feedback. Validate changes before applying.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":420,"created_at":"2026-01-30T12:07:15.419194-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:15.419194-06:00","labels":["frontend","rbac","settings"],"dependencies":[{"issue_id":"test-e9t4","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:07:15.541427-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4","depends_on_id":"test-e9t1","type":"blocks","created_at":"2026-01-30T12:10:22.588545-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s1","title":"Create settings page layout with role-based tab navigation","description":"Build the shared settings layout component with tabbed navigation that dynamically shows/hides sections based on Clerk user roles. Org admins see all three levels (org/team/personal), team leads see team + personal, agents see only personal settings. Use shadcn Tabs component with proper URL routing (/settings/org, /settings/team, /settings/personal). Include breadcrumb navigation and settings sidebar for sub-sections within each level.\n\n**Context:** The three-tier settings structure must match Clerk's role hierarchy exactly. Getting the navigation and access control right first prevents security issues and ensures users only see settings they can actually modify.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:09.132076-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:09.132076-06:00","labels":["auth","frontend"],"dependencies":[{"issue_id":"test-e9t4s1","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:09:09.275332-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s2","title":"Build organization settings section","description":"Create org settings page with sub-tabs: (1) FUB Connection - show connection status, reconnect button, last sync time; (2) Billing - embed Stripe customer portal link or iframe; (3) Members - list org members with role badges, invite button (defer actual invite to Clerk); (4) AI Defaults - default AI temperature, persona settings, call recording preferences. Use form with auto-save pattern: debounce changes, show saving/saved indicator, validate before applying. Store org settings in database with org_id foreign key.\n\n**Context:** Org settings control billing and FUB connection - the two most critical integration points. Brokerage owners need to manage these without support tickets. Auto-save reduces friction but requires clear feedback so users know changes took effect.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:09:09.490799-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:09.490799-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e9t4s2","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:09:09.628814-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s2","depends_on_id":"test-e9t4s1","type":"blocks","created_at":"2026-01-30T12:10:22.838831-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s3","title":"Build team settings section","description":"Create team settings page with sub-tabs: (1) Team Roster - show team members with roles, allow team lead to add/remove members from team; (2) Lead Routing - configure round-robin vs manual assignment, set routing rules (e.g., by zip code, lead source); (3) Team Prompts - override org-level AI prompts with team-specific versions, preview prompt with sample data. Include team selector dropdown for org admins who manage multiple teams. Form uses same auto-save pattern as org settings.\n\n**Context:** Team leads customize RealHerd for their specific team workflow. Lead routing rules are particularly important - bad routing means lost leads. The prompt override system lets teams differentiate their AI voice without affecting other teams.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":105,"created_at":"2026-01-30T12:09:09.844732-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:09.844732-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e9t4s3","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:09:09.999489-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s3","depends_on_id":"test-e9t4s1","type":"blocks","created_at":"2026-01-30T12:10:23.256454-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t4s4","title":"Build personal settings section with notification and voice preferences","description":"Create personal settings page with sub-tabs: (1) Notifications - toggle email/SMS/push for different event types (new lead, call completed, daily digest), set quiet hours; (2) Working Hours - define availability windows for call routing (M-F 9-5, etc.), timezone selector; (3) Voice Settings - manage voice clone status, upload new voice sample, preview current voice. All settings auto-save. Include 'Reset to Team Defaults' button where applicable. Test the complete settings flow end-to-end.\n\n**Context:** Personal settings directly impact agent daily experience. Working hours affect when calls get routed to them - wrong settings mean missed leads or after-hours calls. Voice clone management is where agents personalize their AI caller.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":105,"created_at":"2026-01-30T12:09:10.305256-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:10.305256-06:00","labels":["backend","frontend"],"dependencies":[{"issue_id":"test-e9t4s4","depends_on_id":"test-e9t4","type":"parent-child","created_at":"2026-01-30T12:09:10.590441-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t4s4","depends_on_id":"test-e9t4s1","type":"blocks","created_at":"2026-01-30T12:10:23.46503-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5","title":"Performance optimization and production hardening","description":"Audit and optimize application performance: implement code splitting, optimize Convex queries with proper indexes, add caching strategies, minimize bundle size, ensure real-time updates are efficient. Add production monitoring, error tracking, and analytics. Verify the 30-minute setup target is achievable.\n\n**Context:** Agents need the app to be fast - they're often on calls and can't wait for slow loads. Real-time updates must be instant for the call queue feature to work. Production hardening ensures we don't lose customer trust to preventable outages.","design":"Use Next.js dynamic imports for heavy components (call interface, charts). Add Convex indexes for frequent queries (contacts by agent, calls by status). Implement React.memo/useMemo for expensive renders. Set up error tracking (Sentry or similar). Add basic analytics for funnel tracking. Performance budget: initial load \u003c3s, interactions \u003c100ms. Test the full onboarding flow to verify 30-minute target.","status":"open","priority":1,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":480,"created_at":"2026-01-30T12:07:15.808552-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:07:15.808552-06:00","labels":["devops","monitoring","performance"],"dependencies":[{"issue_id":"test-e9t5","depends_on_id":"test-e9","type":"parent-child","created_at":"2026-01-30T12:07:15.963916-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5","depends_on_id":"test-e9t1","type":"blocks","created_at":"2026-01-30T12:10:24.023513-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5","depends_on_id":"test-e9t2","type":"blocks","created_at":"2026-01-30T12:10:24.270108-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5","depends_on_id":"test-e9t3","type":"blocks","created_at":"2026-01-30T12:10:24.463416-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5","depends_on_id":"test-e9t4","type":"blocks","created_at":"2026-01-30T12:10:24.668777-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s1","title":"Implement code splitting and bundle optimization","description":"Add Next.js dynamic imports for heavy components: call interface, analytics charts, bulk import dialogs. Configure proper chunk splitting in next.config.js. Use bundle analyzer to identify and reduce large dependencies. Target: main bundle \u003c200KB gzipped.\n\n**Context:** Agents on calls can't wait for slow loads. Code splitting ensures the critical path loads fast while heavy features load on-demand.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:10.879589-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:10.879589-06:00","labels":["frontend","performance"],"dependencies":[{"issue_id":"test-e9t5s1","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:09:11.020797-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s2","title":"Add Convex indexes and optimize database queries","description":"Audit all Convex queries and add indexes for: contacts by agentId, contacts by status, calls by agentId, calls by status, calls by scheduledAt. Review query patterns and ensure we're not over-fetching. Add pagination to list queries that could grow large.\n\n**Context:** Real-time updates must be instant for the call queue feature. Proper indexes make the difference between 10ms and 500ms query times at scale.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":75,"created_at":"2026-01-30T12:09:11.221623-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:11.221623-06:00","labels":["backend","convex","performance"],"dependencies":[{"issue_id":"test-e9t5s2","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:09:11.382013-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s3","title":"Add React performance optimizations and rendering efficiency","description":"Implement React.memo for contact cards, call queue items, and table rows. Add useMemo for expensive computations (filtering, sorting). Use useCallback for event handlers passed to child components. Virtualize long lists (contacts, call history) with react-virtual or similar.\n\n**Context:** Expensive re-renders cause UI jank during real-time updates. When a call status changes, only that item should re-render, not the entire list.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":90,"created_at":"2026-01-30T12:09:11.70814-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:11.70814-06:00","labels":["frontend","performance"],"dependencies":[{"issue_id":"test-e9t5s3","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:09:11.904423-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s3","depends_on_id":"test-e9t5s1","type":"blocks","created_at":"2026-01-30T12:10:24.879459-06:00","created_by":"David Habedank"}]}
{"id":"test-e9t5s4","title":"Set up production monitoring, error tracking, and verify 30-minute onboarding","description":"Integrate Sentry for error tracking with proper source maps. Add basic analytics (Vercel Analytics or PostHog) for funnel tracking: signup  org created  first contact  first call. Set up performance monitoring for Core Web Vitals. Run full onboarding flow 3 times, document any friction points, verify 30-minute target is achievable.\n\n**Context:** Production hardening prevents losing customer trust to preventable outages. The 30-minute setup target is a key product promise - we must verify it's real.","status":"open","priority":2,"issue_type":"task","owner":"david@habedank.org","estimated_minutes":120,"created_at":"2026-01-30T12:09:12.46881-06:00","created_by":"David Habedank","updated_at":"2026-01-30T12:09:12.46881-06:00","labels":["devops","monitoring","testing"],"dependencies":[{"issue_id":"test-e9t5s4","depends_on_id":"test-e9t5","type":"parent-child","created_at":"2026-01-30T12:09:13.143383-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s4","depends_on_id":"test-e9t5s2","type":"blocks","created_at":"2026-01-30T12:10:25.128617-06:00","created_by":"David Habedank"},{"issue_id":"test-e9t5s4","depends_on_id":"test-e9t5s3","type":"blocks","created_at":"2026-01-30T12:10:25.356388-06:00","created_by":"David Habedank"}]}
